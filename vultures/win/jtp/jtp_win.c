/*	SCCS Id: @(#)jtp_win.c	3.0	2000/9/10	*/
/* Copyright (c) Jaakko Peltonen, 2000				  */
/* NetHack may be freely redistributed.  See license for details. */

#include <stdio.h>
#include <math.h>
#if defined(__GNUC__)
#include <unistd.h>
#endif
#include <string.h>
#include <ctype.h>
#include "jtp_gen.h"
#include "jtp_gra.h"
#include "jtp_mou.h"
#include "jtp_txt.h"
#include "jtp_gfl.h"
#include "jtp_keys.h"
#include "jtp_win.h"
#include "jtp_tile.h"
#include "epri.h"
#include "winjtp.h"
#include "jtp_sdl.h"

#include "global.h"
#include "rm.h"
#include "display.h"
#include "patchlevel.h"

/*----------------------------------------------------------------
  Defines (constants)
-----------------------------------------------------------------*/
/* Command used by NetHack for travel (from src/cmd.c) */
#define CMD_TRAVEL (char)0x90

/* Directory separator: DOS-style (backslash) or Unix-style (slash) */
#ifdef UNIX
#define JTP_USE_UNIX_STYLE_DIRECTORY_SEPARATOR
#endif
#ifdef __BEOS__
#define JTP_USE_UNIX_STYLE_DIRECTORY_SEPARATOR
#endif


/* Wall display styles (game option) */
enum jtp_wall_display_style {
  JTP_WALL_DISPLAY_STYLE_FULL=0,
  JTP_WALL_DISPLAY_STYLE_HALF_HEIGHT,
  JTP_WALL_DISPLAY_STYLE_TRANSPARENT
};

/* Maximum height (in pixels) of displayed menu items */
#define JTP_MAX_MENUITEMS_HEIGHT 450

/* Location and dimensions of the status window graphic, in pixels */
#define JTP_STATUSBAR_WIDTH 800
#define JTP_STATUSBAR_HEIGHT 100

/* Magic pixel positions within the statusbar graphic  */
#define STATUS_XPOS 220
#define STATUS_YPOS  15

/* Dimensions of NetHack logo screen & character generation graphic */
#define JTP_NH_LOGO_WIDTH 800
#define JTP_NH_LOGO_HEIGHT 600

/* Map dimensions in glyphs */
#define JTP_MAP_WIDTH COLNO
#define JTP_MAP_HEIGHT ROWNO

/* Message shading: old messages grow darker */
#define JTP_MAX_MESSAGE_COLORS 16

/* Indices into warning colors */
enum jtp_warn_type {
  JTP_WARN_NONE = 0,
  JTP_WARN_NORMAL,
  JTP_WARN_MORE,
  JTP_WARN_ALERT,
  JTP_WARN_CRITICAL,
  JTP_MAX_WARN
};

/* Length of an unknown path (for comparison). Must be greater than any real path! */
#define JTP_UNKNOWN_PATH_LENGTH (3*JTP_MAP_WIDTH*JTP_MAP_HEIGHT)

/* Maximum length of an autopilot move. */
#define JTP_MAX_MOVE_LENGTH (COLNO*ROWNO)

/* Lighting constants */
#define JTP_AMBIENT_LIGHT 32 /*ambient light on the map = minimum lighting level*/


/* Font indices. Currently, there're only 2 fonts (large & small). */
#define JTP_FONT_SMALL 0
#define JTP_FONT_LARGE 1
#define JTP_MAX_FONTS  2
#define JTP_FONT_INTRO     JTP_FONT_LARGE
#define JTP_FONT_MENU      JTP_FONT_SMALL
#define JTP_FONT_HEADLINE  JTP_FONT_LARGE
#define JTP_FONT_BUTTON    JTP_FONT_LARGE
#define JTP_FONT_TOOLTIP   JTP_FONT_SMALL
#define JTP_FONT_STATUS    JTP_FONT_SMALL
#define JTP_FONT_MESSAGE   JTP_FONT_SMALL
#define JTP_FONT_INPUT     JTP_FONT_SMALL

/* Event sound types */
enum jtp_event_sound {
  JTP_EVENT_SOUND_TYPE_NONE = 0,
  JTP_EVENT_SOUND_TYPE_SND,
  JTP_EVENT_SOUND_TYPE_MUS,
  JTP_EVENT_SOUND_TYPE_RANDOM_SONG,
  JTP_EVENT_SOUND_TYPE_CD_AUDIO,
};
	
/* On-screen hotspots */
enum jtp_hotspot {
  JTP_HOTSPOT_NONE = 0,
  JTP_HOTSPOT_SCROLL_UP,
  JTP_HOTSPOT_SCROLL_DOWN,
  JTP_HOTSPOT_SCROLL_LEFT,
  JTP_HOTSPOT_SCROLL_RIGHT,
  JTP_HOTSPOT_MAP,
  JTP_HOTSPOT_MINI_MAP,
  JTP_HOTSPOT_STATUSBAR,
  JTP_HOTSPOT_BUTTON_LOOK,
  JTP_HOTSPOT_BUTTON_EXTENDED,
  JTP_HOTSPOT_BUTTON_MAP,
  JTP_HOTSPOT_BUTTON_SPELLBOOK,
  JTP_HOTSPOT_BUTTON_INVENTORY,
  JTP_HOTSPOT_BUTTON_MESSAGES,
  JTP_HOTSPOT_BUTTON_OPTIONS,
  JTP_HOTSPOT_BUTTON_HELP
};
	
/* Lighting constants */
#define JTP_MAX_LIGHTS 10
#define JTP_BRILLIANCE 65.0

/* 
 * Tile drawing: pixel coordinate difference from a square to
 * the one next to it in the map. Because of isometry,
 * this is not the same as the width/height of a tile!
 */
#ifdef JTP_USE_SMALL_MAP_TILES
#define JTP_MAP_XMOD 46
#define JTP_MAP_YMOD 18
#else
#define JTP_MAP_XMOD 56
#define JTP_MAP_YMOD 22
#endif

/* Floor pattern dimensions (eg. 3x3) */
#define JTP_FLOOR_PATTERN_WIDTH 3
#define JTP_FLOOR_PATTERN_HEIGHT 3

/* Carpet dimensions (eg. 3x2) */
#define JTP_CARPET_WIDTH 3
#define JTP_CARPET_HEIGHT 3

/* Wall styles */
enum jtp_wall_style {
  JTP_WALL_STYLE_BRICK = 0,
  JTP_WALL_STYLE_BRICK_BANNER,
  JTP_WALL_STYLE_BRICK_PAINTING,
  JTP_WALL_STYLE_BRICK_POCKET,
  JTP_WALL_STYLE_BRICK_PILLAR,
  JTP_WALL_STYLE_ROUGH,
  JTP_WALL_STYLE_STUCCO,
  JTP_WALL_STYLE_VINE_COVERED,
  JTP_WALL_STYLE_MARBLE,
  JTP_WALL_STYLE_DARK,
  JTP_WALL_STYLE_LIGHT,
  JTP_MAX_WALL_STYLES
};

/* Floor styles */
enum jtp_floor_style {
  JTP_FLOOR_STYLE_COBBLESTONE = 0,
  JTP_FLOOR_STYLE_ROUGH,
  JTP_FLOOR_STYLE_CERAMIC,
  JTP_FLOOR_STYLE_MOSS_COVERED,
  JTP_FLOOR_STYLE_MARBLE,
  JTP_FLOOR_STYLE_LAVA,
  JTP_FLOOR_STYLE_WATER,
  JTP_FLOOR_STYLE_ICE,
  JTP_FLOOR_STYLE_MURAL,
  JTP_FLOOR_STYLE_MURAL_2,
  JTP_FLOOR_STYLE_CARPET,
  JTP_FLOOR_STYLE_ROUGH_LIT,
  JTP_FLOOR_STYLE_AIR,
  JTP_FLOOR_STYLE_DARK,
  JTP_MAX_FLOOR_STYLES
};

/* Floor edge styles */
#define JTP_FLOOR_EDGE_STYLE_COBBLESTONE 0
#define JTP_MAX_FLOOR_EDGE_STYLES 1

/* Tile graphic indices, cmap tiles */
enum jtp_tile {
  JTP_TILE_INVALID = -1,
/* Wall tiles */
  JTP_TILE_WALL_GENERIC,
  JTP_TILE_WALL_BRICK,
  JTP_TILE_WALL_ROUGH,
  JTP_TILE_WALL_DARK,
  JTP_TILE_WALL_LIGHT,
/* Floor tiles */
  JTP_TILE_FLOOR_COBBLESTONE,
  JTP_TILE_FLOOR_ROUGH,
  JTP_TILE_FLOOR_LAVA,
  JTP_TILE_FLOOR_WATER,
  JTP_TILE_FLOOR_ICE,
  JTP_TILE_FLOOR_CARPETED,
  JTP_TILE_FLOOR_ROUGH_LIT,
  JTP_TILE_FLOOR_AIR,
  JTP_TILE_FLOOR_DARK,
/* Door tiles */
  JTP_TILE_VDOOR_WOOD_OPEN,
  JTP_TILE_VDOOR_WOOD_CLOSED,
  JTP_TILE_HDOOR_WOOD_OPEN,
  JTP_TILE_HDOOR_WOOD_CLOSED,
  JTP_TILE_DOOR_WOOD_BROKEN,
/* Other cmap tiles */
  JTP_TILE_STAIRS_UP,
  JTP_TILE_STAIRS_DOWN,
  JTP_TILE_FOUNTAIN,
  JTP_TILE_ALTAR,
  JTP_TILE_TRAP_TELEPORTER,
  JTP_TILE_TREE,
  JTP_TILE_TRAP_PIT,
  JTP_TILE_GAS_TRAP,
  JTP_TILE_GRAVE,
  JTP_TILE_SINK,
  JTP_TILE_TRAP_BEAR,
  JTP_TILE_TRAP_MAGIC,
  JTP_TILE_TRAP_WATER,
  JTP_TILE_TRAP_DOOR,
  JTP_TILE_FLOOR_NOT_VISIBLE,
  JTP_TILE_TRAP_ANTI_MAGIC,
  JTP_TILE_TRAP_ARROW,
  JTP_TILE_TRAP_SLEEPGAS,
  JTP_TILE_ROLLING_BOULDER_TRAP,
  JTP_TILE_TRAP_FIRE,
  JTP_TILE_ZAP_HORIZONTAL,
  JTP_TILE_ZAP_VERTICAL,
  JTP_TILE_ZAP_SLANT_LEFT,
  JTP_TILE_ZAP_SLANT_RIGHT,
  JTP_TILE_LADDER_DOWN,
  JTP_TILE_LADDER_UP,
  JTP_TILE_EXPLOSION_NORTHWEST,
  JTP_TILE_EXPLOSION_NORTH,
  JTP_TILE_EXPLOSION_NORTHEAST,
  JTP_TILE_EXPLOSION_WEST,
  JTP_TILE_EXPLOSION_CENTER,
  JTP_TILE_EXPLOSION_EAST,
  JTP_TILE_EXPLOSION_SOUTHWEST,
  JTP_TILE_EXPLOSION_SOUTH,
  JTP_TILE_EXPLOSION_SOUTHEAST,
  JTP_TILE_THRONE,
  JTP_TILE_BARS,
  JTP_TILE_HILITE_PET,
  JTP_TILE_TRAP_POLYMORPH,
  JTP_TILE_RESIST_SPELL_1,
  JTP_TILE_RESIST_SPELL_2,
  JTP_TILE_RESIST_SPELL_3,
  JTP_TILE_RESIST_SPELL_4,
  JTP_TILE_WEB_TRAP,
  JTP_TILE_DART_TRAP,
  JTP_TILE_FALLING_ROCK_TRAP,
  JTP_TILE_SQUEAKY_BOARD,
  JTP_TILE_LAND_MINE,
  JTP_TILE_MAGIC_PORTAL,
  JTP_TILE_TILE_SPIKED_PIT,
  JTP_TILE_HOLE,
  JTP_TILE_LEVEL_TELEPORTER,
  JTP_TILE_MAGIC_TRAP,
  JTP_TILE_DIGBEAM,
  JTP_TILE_FLASHBEAM,
  JTP_TILE_BOOMLEFT,
  JTP_TILE_BOOMRIGHT,
  JTP_TILE_HCDBRIDGE,
  JTP_TILE_VCDBRIDGE,
  JTP_TILE_HODBRIDGE,
  JTP_TILE_VODBRIDGE,
  JTP_TILE_CLOUD,

/* Tile graphic indices, object tiles */
  JTP_TILE_MISC,
  JTP_TILE_BOULDER,
  JTP_TILE_BONES,
  JTP_TILE_STATUE,
  JTP_TILE_CHEST,
  JTP_TILE_COINS,
  JTP_TILE_BOOK,
  JTP_TILE_HELMET,
  JTP_TILE_SHIELD,
  JTP_TILE_BOOTS,
  JTP_TILE_SPEAR,
  JTP_TILE_WATER,
  JTP_TILE_SCROLL,
  JTP_TILE_WAND,
  JTP_TILE_SWORD,
  JTP_TILE_BLUE_GLASS,
  JTP_TILE_GREEN_GLASS,
  JTP_TILE_RED_GLASS,
  JTP_TILE_YELLOW_GLASS,
  JTP_TILE_WHITE_GLASS,
  JTP_TILE_BLACK_GLASS,
  JTP_TILE_VIOLET_GLASS,
  JTP_TILE_ORANGE_GLASS,
  JTP_TILE_HAMMER,
  JTP_TILE_AXE,
  JTP_TILE_LANTERN,
  JTP_TILE_RING,
  JTP_TILE_AMULET,
  JTP_TILE_LEATHER_ARMOR,
  JTP_TILE_PLATE_MAIL,
  JTP_TILE_SCALE_MAIL,
  JTP_TILE_RING_MAIL,
  JTP_TILE_CHAIN_MAIL,
  JTP_TILE_CLOAK,
  JTP_TILE_TRIDENT,
  JTP_TILE_CAMERA,
  JTP_TILE_FEDORA,
  JTP_TILE_CLUB,
  JTP_TILE_ARROW,
  JTP_TILE_PEAR,
  JTP_TILE_APPLE,
  JTP_TILE_DAGGER,
  JTP_TILE_KEY,
  JTP_TILE_BOW,
  JTP_TILE_WHIP,
  JTP_TILE_CANDLE,
  JTP_TILE_EGG,
  JTP_TILE_GLOVES,
  JTP_TILE_BELL,
  JTP_TILE_MACE,
  JTP_TILE_TOOLED_HORN,
  JTP_TILE_CRYSTAL_BALL,
  JTP_TILE_FROST_HORN,
  JTP_TILE_UNICORN_HORN,
  JTP_TILE_HAWAIIAN_SHIRT,
  JTP_TILE_CREDIT_CARD,
  JTP_TILE_MIRROR,
  JTP_TILE_CROSSBOW,
  JTP_TILE_CONICAL_HAT,
  JTP_TILE_MAGIC_MARKER,
  JTP_TILE_STAFF,
  JTP_TILE_FOOD_RATION,
  JTP_TILE_PANCAKE,
  JTP_TILE_TRIPE_RATION,
  JTP_TILE_MEAT_STICK,
  JTP_TILE_SHURIKEN,
  JTP_TILE_STONE,
  JTP_TILE_PICKAXE,
  JTP_TILE_TIN,
  JTP_TILE_CANDY_BAR,
  JTP_TILE_FORTUNE_COOKIE,
  JTP_TILE_CREAM_PIE,
  JTP_TILE_LEMBAS_WAFER,
  JTP_TILE_ORANGE,
  JTP_TILE_BANANA,
  JTP_TILE_MELON,
  JTP_TILE_EUCALYPTUS_LEAF,
  JTP_TILE_KELP_FROND,
  JTP_TILE_SLIME_MOLD,
  JTP_TILE_CARROT,
  JTP_TILE_SPRIG_OF_WOLFSBANE,
  JTP_TILE_CLOVE_OF_GARLIC,
  JTP_TILE_CRAM_RATION,
  JTP_TILE_HUGE_CHUNK_OF_MEAT,
  JTP_TILE_MEATBALL,
  JTP_TILE_K_RATION,
  JTP_TILE_C_RATION,
  JTP_TILE_LUMP_OF_ROYAL_JELLY,
  JTP_TILE_MEAT_RING,
  JTP_TILE_AGATE,
  JTP_TILE_AMBER,
  JTP_TILE_AMETHYST,
  JTP_TILE_AQUAMARINE,
  JTP_TILE_BLACK_OPAL,
  JTP_TILE_CHRYSOBERYL,
  JTP_TILE_CITRINE,
  JTP_TILE_DIAMOND,
  JTP_TILE_DILITHIUM_CRYSTAL,
  JTP_TILE_EMERALD,
  JTP_TILE_FLUORITE,
  JTP_TILE_GARNET,
  JTP_TILE_JACINTH,
  JTP_TILE_JADE,
  JTP_TILE_JASPER,
  JTP_TILE_JET,
  JTP_TILE_OBSIDIAN,
  JTP_TILE_OPAL,
  JTP_TILE_RUBY,
  JTP_TILE_SAPPHIRE,
  JTP_TILE_TOPAZ,
  JTP_TILE_TURQUOISE,
  JTP_TILE_LUCKSTONE,
  JTP_TILE_FLINT,
  JTP_TILE_LOADSTONE,
  JTP_TILE_TINNING_KIT,
  JTP_TILE_FIRE_HORN,
  JTP_TILE_RUBY_POTION,
  JTP_TILE_PINK_POTION,
  JTP_TILE_ORANGE_POTION,
  JTP_TILE_YELLOW_POTION,
  JTP_TILE_EMERALD_POTION,
  JTP_TILE_DARK_GREEN_POTION,
  JTP_TILE_CYAN_POTION,
  JTP_TILE_SKY_BLUE_POTION,
  JTP_TILE_BRILLIANT_BLUE_POTION,
  JTP_TILE_MAGENTA_POTION,
  JTP_TILE_PURPLE_RED_POTION,
  JTP_TILE_PUCE_POTION,
  JTP_TILE_MILKY_POTION,
  JTP_TILE_SWIRLY_POTION,
  JTP_TILE_BUBBLY_POTION,
  JTP_TILE_SMOKY_POTION,
  JTP_TILE_CLOUDY_POTION,
  JTP_TILE_EFFERVESCENT_POTION,
  JTP_TILE_BLACK_POTION,
  JTP_TILE_GOLDEN_POTION,
  JTP_TILE_BROWN_POTION,
  JTP_TILE_FIZZY_POTION,
  JTP_TILE_DARK_POTION,
  JTP_TILE_WHITE_POTION,
  JTP_TILE_MURKY_POTION,
  JTP_TILE_HOLY_WATER,
  JTP_TILE_UNHOLY_WATER,
  JTP_TILE_SACK,
  JTP_TILE_BAG_OF_HOLDING,
  JTP_TILE_OILSKIN_SACK,
  JTP_TILE_BAG_OF_TRICKS,
  JTP_TILE_ICE_BOX,
  JTP_TILE_LARGE_BOX,
  JTP_TILE_TOUCHSTONE,
  JTP_TILE_UNIDENTIFIED_BAG,
  JTP_TILE_ROCKS,
  JTP_TILE_BROWN_GLASS,
  JTP_TILE_HEALTHSTONE,
  JTP_TILE_WHETSTONE, 
  JTP_TILE_BOOMERANG,

/* Tile graphic indices, monster tiles */
v v v v v v v
  JTP_TILE_KNIGHT,
  JTP_TILE_LITTLE_DOG,
  JTP_TILE_GREEN_SLIME,
  JTP_TILE_LIZARD,
  JTP_TILE_SPIDER,
  JTP_TILE_GOBLIN,
  JTP_TILE_EYE,
  JTP_TILE_IMP,
  JTP_TILE_FIRE_ELEMENTAL,
  JTP_TILE_OGRE,
  JTP_TILE_NAGA,
  JTP_TILE_KITTEN,
  JTP_TILE_WIZARD,
  JTP_TILE_VALKYRIE,
  JTP_TILE_RANGER,
  JTP_TILE_NYMPH,
  JTP_TILE_WATER_NYMPH,
  JTP_TILE_SKELETON,
  JTP_TILE_GHOST,
  JTP_TILE_WRAITH,
  JTP_TILE_HUMAN_ZOMBIE,
  JTP_TILE_RAT,
  JTP_TILE_TROLL,
  JTP_TILE_GIANT_BAT,
  JTP_TILE_MOUNTAIN_CENTAUR,
  JTP_TILE_GIANT_ANT,
  JTP_TILE_ARCHEOLOGIST,
  JTP_TILE_BEE,
  JTP_TILE_TOURIST,
  JTP_TILE_ROGUE,
  JTP_TILE_PRIEST,
  JTP_TILE_YELLOW_LIGHT,
  JTP_TILE_BLACK_LIGHT,
  JTP_TILE_YELLOW_MOLD,
  JTP_TILE_RED_MOLD,
  JTP_TILE_VIOLET_FUNGUS,
  JTP_TILE_BROWN_MOLD,
  JTP_TILE_SHRIEKER,
  JTP_TILE_COCKATRICE,
  JTP_TILE_KRAKEN,
  JTP_TILE_GIANT_EEL,
  JTP_TILE_SHARK,
  JTP_TILE_PYROLISK,
  JTP_TILE_CHICKATRICE,
  JTP_TILE_ACID_BLOB,
  JTP_TILE_QUIVERING_BLOB,
  JTP_TILE_GELATINOUS_CUBE,
  JTP_TILE_LICHEN,
  JTP_TILE_GREEN_MOLD,
  JTP_TILE_STALKER,
  JTP_TILE_AIR_ELEMENTAL,
  JTP_TILE_EARTH_ELEMENTAL,
  JTP_TILE_WATER_ELEMENTAL,
  JTP_TILE_SMALL_MIMIC,
  JTP_TILE_LARGE_MIMIC,
  JTP_TILE_GIANT_MIMIC,
  JTP_TILE_JACKAL,
  JTP_TILE_FOX,
  JTP_TILE_COYOTE,
  JTP_TILE_DOG,
  JTP_TILE_LARGE_DOG,
  JTP_TILE_ROCK_PIERCER,
  JTP_TILE_IRON_PIERCER,
  JTP_TILE_GLASS_PIERCER,
  JTP_TILE_WATER_DEMON,
  JTP_TILE_GECKO,
  JTP_TILE_NEWT,
  JTP_TILE_SHOPKEEPER,
  JTP_TILE_GAS_SPORE,
  JTP_TILE_HOUSECAT,
  JTP_TILE_LARGE_CAT,
  JTP_TILE_PONY,
  JTP_TILE_HORSE,
  JTP_TILE_WARHORSE,
  JTP_TILE_FREEZING_SPHERE,
  JTP_TILE_FLAMING_SPHERE,
  JTP_TILE_SHOCKING_SPHERE,
  JTP_TILE_ROTHE,
  JTP_TILE_GNOME,
  JTP_TILE_GREEN_ELF,
  JTP_TILE_DWARF,
  JTP_TILE_WATER_MOCCASIN,
  JTP_TILE_MANES,
  JTP_TILE_HOBBIT,
  JTP_TILE_BLACK_UNICORN,
  JTP_TILE_GRAY_UNICORN,
  JTP_TILE_WHITE_UNICORN,
  JTP_TILE_SOLDIER_ANT,
  JTP_TILE_FIRE_ANT,
  JTP_TILE_ELVENKING,
  JTP_TILE_ELF_LORD,
  JTP_TILE_GREY_ELF,
  JTP_TILE_WOODLAND_ELF,
  JTP_TILE_ELF,
  JTP_TILE_ROCK_MOLE,
  JTP_TILE_DWARF_LORD,
  JTP_TILE_DWARF_KING,
  JTP_TILE_GNOME_LORD,
  JTP_TILE_GNOME_KING,
  JTP_TILE_GNOMISH_WIZARD,
  JTP_TILE_ORC,
  JTP_TILE_HILL_ORC,
  JTP_TILE_MORDOR_ORC,
  JTP_TILE_URUK_HAI,
  JTP_TILE_HOBGOBLIN,
  JTP_TILE_BUGBEAR,
  JTP_TILE_KOBOLD,
  JTP_TILE_LARGE_KOBOLD,
  JTP_TILE_KOBOLD_LORD,
  JTP_TILE_KOBOLD_SHAMAN,
  JTP_TILE_ORC_CAPTAIN,
  JTP_TILE_ORC_SHAMAN,
  JTP_TILE_LEPRECHAUN,
  JTP_TILE_GARTER_SNAKE,
  JTP_TILE_SNAKE,
  JTP_TILE_PIT_VIPER,
  JTP_TILE_PYTHON,
  JTP_TILE_COBRA,
  JTP_TILE_GIANT,
  JTP_TILE_ETTIN,
  JTP_TILE_ROGUE_LEVEL_A,
  JTP_TILE_ROGUE_LEVEL_B,
  JTP_TILE_ROGUE_LEVEL_C,
  JTP_TILE_ROGUE_LEVEL_D,
  JTP_TILE_ROGUE_LEVEL_E,
  JTP_TILE_ROGUE_LEVEL_F,
  JTP_TILE_ROGUE_LEVEL_G,
  JTP_TILE_ROGUE_LEVEL_H,
  JTP_TILE_ROGUE_LEVEL_I,
  JTP_TILE_ROGUE_LEVEL_J,
  JTP_TILE_ROGUE_LEVEL_K,
  JTP_TILE_ROGUE_LEVEL_L,
  JTP_TILE_ROGUE_LEVEL_M,
  JTP_TILE_ROGUE_LEVEL_N,
  JTP_TILE_ROGUE_LEVEL_O,
  JTP_TILE_ROGUE_LEVEL_P,
  JTP_TILE_ROGUE_LEVEL_Q,
  JTP_TILE_ROGUE_LEVEL_R,
  JTP_TILE_ROGUE_LEVEL_S,
  JTP_TILE_ROGUE_LEVEL_T,
  JTP_TILE_ROGUE_LEVEL_U,
  JTP_TILE_ROGUE_LEVEL_V,
  JTP_TILE_ROGUE_LEVEL_W,
  JTP_TILE_ROGUE_LEVEL_X,
  JTP_TILE_ROGUE_LEVEL_Y,
  JTP_TILE_ROGUE_LEVEL_Z,
  JTP_TILE_COUATL,
  JTP_TILE_ALEAX,
  JTP_TILE_ANGEL,
  JTP_TILE_KI_RIN,
  JTP_TILE_ARCHON,
  JTP_TILE_VAMPIRE_BAT,
  JTP_TILE_RAVEN,
  JTP_TILE_FOREST_CENTAUR,
  JTP_TILE_PLAINS_CENTAUR,
  JTP_TILE_BAT,
  JTP_TILE_BABY_GRAY_DRAGON,
  JTP_TILE_BABY_SILVER_DRAGON,
  JTP_TILE_BABY_RED_DRAGON,
  JTP_TILE_BABY_WHITE_DRAGON,
  JTP_TILE_BABY_ORANGE_DRAGON,
  JTP_TILE_BABY_BLACK_DRAGON,
  JTP_TILE_BABY_BLUE_DRAGON,
  JTP_TILE_BABY_YELLOW_DRAGON,
  JTP_TILE_BABY_GREEN_DRAGON,
  JTP_TILE_GRAY_DRAGON,
  JTP_TILE_SILVER_DRAGON,
  JTP_TILE_RED_DRAGON,
  JTP_TILE_WHITE_DRAGON,
  JTP_TILE_ORANGE_DRAGON,
  JTP_TILE_BLACK_DRAGON,
  JTP_TILE_BLUE_DRAGON,
  JTP_TILE_YELLOW_DRAGON,
  JTP_TILE_GREEN_DRAGON,
  JTP_TILE_QUANTUM_MECHANIC,
  JTP_TILE_STONE_GIANT,
  JTP_TILE_HILL_GIANT,
  JTP_TILE_FIRE_GIANT,
  JTP_TILE_FROST_GIANT,
  JTP_TILE_STORM_GIANT,
  JTP_TILE_TITAN,
  JTP_TILE_MINOTAUR,
  JTP_TILE_JABBERWOCK,
  JTP_TILE_UMBER_HULK,
  JTP_TILE_KEYSTONE_KOP,
  JTP_TILE_KOP_SERGEANT,
  JTP_TILE_KOP_LIEUTENANT,
  JTP_TILE_KOP_KAPTAIN,
  JTP_TILE_LICH,
  JTP_TILE_DEMILICH,
  JTP_TILE_MASTER_LICH,
  JTP_TILE_ARCH_LICH,
  JTP_TILE_KOBOLD_MUMMY,
  JTP_TILE_GNOME_MUMMY,
  JTP_TILE_DWARF_MUMMY,
  JTP_TILE_ORC_MUMMY,
  JTP_TILE_ELF_MUMMY,
  JTP_TILE_HUMAN_MUMMY,
  JTP_TILE_ETTIN_MUMMY,
  JTP_TILE_GIANT_MUMMY,
  JTP_TILE_RED_NAGA_HATCHLING,
  JTP_TILE_BLACK_NAGA_HATCHLING,
  JTP_TILE_GOLDEN_NAGA_HATCHLING,
  JTP_TILE_GUARDIAN_NAGA_HATCHLING,
  JTP_TILE_RED_NAGA,
  JTP_TILE_BLACK_NAGA,
  JTP_TILE_GOLDEN_NAGA,
  JTP_TILE_GUARDIAN_NAGA,
  JTP_TILE_OGRE_LORD,
  JTP_TILE_OGRE_KING,
  JTP_TILE_GRAY_OOZE,
  JTP_TILE_BROWN_PUDDING,
  JTP_TILE_BLACK_PUDDING,
  JTP_TILE_RUST_MONSTER,
  JTP_TILE_DISENCHANTER,
  JTP_TILE_ICE_TROLL,
  JTP_TILE_ROCK_TROLL,
  JTP_TILE_WATER_TROLL,
  JTP_TILE_OLOG_HAI,
  JTP_TILE_VAMPIRE,
  JTP_TILE_VAMPIRE_LORD,
  JTP_TILE_BARROW_WIGHT,
  JTP_TILE_NAZGUL,
  JTP_TILE_XORN,
  JTP_TILE_MONKEY,
  JTP_TILE_APE,
  JTP_TILE_OWLBEAR,
  JTP_TILE_YETI,
  JTP_TILE_CARNIVOROUS_APE,
  JTP_TILE_SASQUATCH,
  JTP_TILE_KOBOLD_ZOMBIE,
  JTP_TILE_GNOME_ZOMBIE,
  JTP_TILE_DWARF_ZOMBIE,
  JTP_TILE_ORC_ZOMBIE,
  JTP_TILE_ELF_ZOMBIE,
  JTP_TILE_GIANT_ZOMBIE,
  JTP_TILE_ETTIN_ZOMBIE,
  JTP_TILE_HOMUNCULUS,
  JTP_TILE_LEMURE,
  JTP_TILE_QUASIT,
  JTP_TILE_TENGU,
  JTP_TILE_WUMPUS,
  JTP_TILE_ORACLE,
  JTP_TILE_LAWFUL_PRIEST,
  JTP_TILE_NEUTRAL_PRIEST,
  JTP_TILE_CHAOTIC_PRIEST,
  JTP_TILE_UNALIGNED_PRIEST,
  JTP_TILE_WATCHMAN,
  JTP_TILE_WATCH_CAPTAIN,
  JTP_TILE_SOLDIER,
  JTP_TILE_SERGEANT,
  JTP_TILE_LIEUTENANT,
  JTP_TILE_CAPTAIN,
  JTP_TILE_GRID_BUG,
  JTP_TILE_XAN,
  JTP_TILE_GARGOYLE,
  JTP_TILE_WINGED_GARGOYLE,
  JTP_TILE_DINGO,
  JTP_TILE_WOLF,
  JTP_TILE_WEREWOLF,
  JTP_TILE_WARG,
  JTP_TILE_WINTER_WOLF_CUB,
  JTP_TILE_WINTER_WOLF,
  JTP_TILE_HELL_HOUND_PUP,
  JTP_TILE_HELL_HOUND,
  JTP_TILE_JAGUAR,
  JTP_TILE_LYNX,
  JTP_TILE_PANTHER,
  JTP_TILE_TIGER,
  JTP_TILE_MIND_FLAYER,
  JTP_TILE_MASTER_MIND_FLAYER,
  JTP_TILE_SUCCUBUS,
  JTP_TILE_INCUBUS,
  JTP_TILE_GREMLIN,
  JTP_TILE_BABY_PURPLE_WORM,
  JTP_TILE_PURPLE_WORM,
  JTP_TILE_BABY_LONG_WORM,
  JTP_TILE_LONG_WORM,
  JTP_TILE_LONG_WORM_TAIL,
  JTP_TILE_MUMAK,
  JTP_TILE_LEOCROTTA,
  JTP_TILE_TITANOTHERE,
  JTP_TILE_BALUCHITHERIUM,
  JTP_TILE_MASTADON,
  JTP_TILE_ZRUTY,
  JTP_TILE_WIZARD_OF_YENDOR,
v v v v v v v
  JTP_TILE_STRAW_GOLEM,
  JTP_TILE_PAPER_GOLEM,
  JTP_TILE_ROPE_GOLEM,
  JTP_TILE_GOLD_GOLEM,
  JTP_TILE_LEATHER_GOLEM,
  JTP_TILE_WOOD_GOLEM,
  JTP_TILE_FLESH_GOLEM,
  JTP_TILE_CLAY_GOLEM,
  JTP_TILE_STONE_GOLEM,
  JTP_TILE_GLASS_GOLEM,
  JTP_TILE_IRON_GOLEM,
*************
*************
v v v v v v v
  JTP_TILE_KNIGHT,
  JTP_TILE_LITTLE_DOG,
  JTP_TILE_GREEN_SLIME,
  JTP_TILE_LIZARD,
  JTP_TILE_SPIDER,
  JTP_TILE_GOBLIN,
  JTP_TILE_EYE,
  JTP_TILE_IMP,
  JTP_TILE_FIRE_ELEMENTAL,
  JTP_TILE_OGRE,
  JTP_TILE_NAGA,
  JTP_TILE_KITTEN,
  JTP_TILE_WIZARD,
  JTP_TILE_VALKYRIE,
  JTP_TILE_RANGER,
  JTP_TILE_NYMPH,
  JTP_TILE_WATER_NYMPH,
  JTP_TILE_SKELETON,
  JTP_TILE_GHOST,
  JTP_TILE_WRAITH,
  JTP_TILE_HUMAN_ZOMBIE,
  JTP_TILE_STONE_GOLEM,
  JTP_TILE_RAT,
  JTP_TILE_TROLL,
  JTP_TILE_GIANT_BAT,
  JTP_TILE_MOUNTAIN_CENTAUR,
  JTP_TILE_GIANT_ANT,
  JTP_TILE_ARCHEOLOGIST,
  JTP_TILE_BEE,
  JTP_TILE_TOURIST,
  JTP_TILE_ROGUE,
  JTP_TILE_PRIEST,
  JTP_TILE_YELLOW_LIGHT,
  JTP_TILE_BLACK_LIGHT,
  JTP_TILE_YELLOW_MOLD,
  JTP_TILE_RED_MOLD,
  JTP_TILE_VIOLET_FUNGUS,
  JTP_TILE_BROWN_MOLD,
  JTP_TILE_SHRIEKER,
  JTP_TILE_COCKATRICE,
  JTP_TILE_KRAKEN,
  JTP_TILE_GIANT_EEL,
  JTP_TILE_SHARK,
  JTP_TILE_PYROLISK,
  JTP_TILE_CHICKATRICE,
  JTP_TILE_ACID_BLOB,
  JTP_TILE_QUIVERING_BLOB,
  JTP_TILE_GELATINOUS_CUBE,
  JTP_TILE_LICHEN,
  JTP_TILE_GREEN_MOLD,
  JTP_TILE_STALKER,
  JTP_TILE_AIR_ELEMENTAL,
  JTP_TILE_EARTH_ELEMENTAL,
  JTP_TILE_WATER_ELEMENTAL,
  JTP_TILE_SMALL_MIMIC,
  JTP_TILE_LARGE_MIMIC,
  JTP_TILE_GIANT_MIMIC,
  JTP_TILE_JACKAL,
  JTP_TILE_FOX,
  JTP_TILE_COYOTE,
  JTP_TILE_DOG,
  JTP_TILE_LARGE_DOG,
  JTP_TILE_ROCK_PIERCER,
  JTP_TILE_IRON_PIERCER,
  JTP_TILE_GLASS_PIERCER,
  JTP_TILE_WATER_DEMON,
  JTP_TILE_GECKO,
  JTP_TILE_NEWT,
  JTP_TILE_SHOPKEEPER,
  JTP_TILE_GAS_SPORE,
  JTP_TILE_HOUSECAT,
  JTP_TILE_LARGE_CAT,
  JTP_TILE_PONY,
  JTP_TILE_HORSE,
  JTP_TILE_WARHORSE,
  JTP_TILE_FREEZING_SPHERE,
  JTP_TILE_FLAMING_SPHERE,
  JTP_TILE_SHOCKING_SPHERE,
  JTP_TILE_ROTHE,
  JTP_TILE_GNOME,
  JTP_TILE_GREEN_ELF,
  JTP_TILE_DWARF,
  JTP_TILE_WATER_MOCCASIN,
  JTP_TILE_MANES,
  JTP_TILE_HOBBIT,
  JTP_TILE_BLACK_UNICORN,
  JTP_TILE_GRAY_UNICORN,
  JTP_TILE_WHITE_UNICORN,
  JTP_TILE_SOLDIER_ANT,
  JTP_TILE_FIRE_ANT,
  JTP_TILE_ELVENKING,
  JTP_TILE_ELF_LORD,
  JTP_TILE_GREY_ELF,
  JTP_TILE_WOODLAND_ELF,
  JTP_TILE_ELF,
  JTP_TILE_ROCK_MOLE,
  JTP_TILE_DWARF_LORD,
  JTP_TILE_DWARF_KING,
  JTP_TILE_GNOME_LORD,
  JTP_TILE_GNOME_KING,
  JTP_TILE_GNOMISH_WIZARD,
  JTP_TILE_ORC,
  JTP_TILE_HILL_ORC,
  JTP_TILE_MORDOR_ORC,
  JTP_TILE_URUK_HAI,
  JTP_TILE_HOBGOBLIN,
  JTP_TILE_BUGBEAR,
  JTP_TILE_KOBOLD,
  JTP_TILE_LARGE_KOBOLD,
  JTP_TILE_KOBOLD_LORD,
  JTP_TILE_KOBOLD_SHAMAN,
  JTP_TILE_ORC_CAPTAIN,
  JTP_TILE_ORC_SHAMAN,
  JTP_TILE_LEPRECHAUN,
  JTP_TILE_GARTER_SNAKE,
  JTP_TILE_SNAKE,
  JTP_TILE_PIT_VIPER,
  JTP_TILE_PYTHON,
  JTP_TILE_COBRA,
  JTP_TILE_GIANT,
  JTP_TILE_ETTIN,
  JTP_TILE_ROGUE_LEVEL_A,
  JTP_TILE_ROGUE_LEVEL_B,
  JTP_TILE_ROGUE_LEVEL_C,
  JTP_TILE_ROGUE_LEVEL_D,
  JTP_TILE_ROGUE_LEVEL_E,
  JTP_TILE_ROGUE_LEVEL_F,
  JTP_TILE_ROGUE_LEVEL_G,
  JTP_TILE_ROGUE_LEVEL_H,
  JTP_TILE_ROGUE_LEVEL_I,
  JTP_TILE_ROGUE_LEVEL_J,
  JTP_TILE_ROGUE_LEVEL_K,
  JTP_TILE_ROGUE_LEVEL_L,
  JTP_TILE_ROGUE_LEVEL_M,
  JTP_TILE_ROGUE_LEVEL_N,
  JTP_TILE_ROGUE_LEVEL_O,
  JTP_TILE_ROGUE_LEVEL_P,
  JTP_TILE_ROGUE_LEVEL_Q,
  JTP_TILE_ROGUE_LEVEL_R,
  JTP_TILE_ROGUE_LEVEL_S,
  JTP_TILE_ROGUE_LEVEL_T,
  JTP_TILE_ROGUE_LEVEL_U,
  JTP_TILE_ROGUE_LEVEL_V,
  JTP_TILE_ROGUE_LEVEL_W,
  JTP_TILE_ROGUE_LEVEL_X,
  JTP_TILE_ROGUE_LEVEL_Y,
  JTP_TILE_ROGUE_LEVEL_Z,
  JTP_TILE_COUATL,
  JTP_TILE_ALEAX,
  JTP_TILE_ANGEL,
  JTP_TILE_KI_RIN,
  JTP_TILE_ARCHON,
  JTP_TILE_VAMPIRE_BAT,
  JTP_TILE_RAVEN,
  JTP_TILE_FOREST_CENTAUR,
  JTP_TILE_PLAINS_CENTAUR,
  JTP_TILE_BAT,
  JTP_TILE_BABY_GRAY_DRAGON,
  JTP_TILE_BABY_SILVER_DRAGON,
  JTP_TILE_BABY_RED_DRAGON,
  JTP_TILE_BABY_WHITE_DRAGON,
  JTP_TILE_BABY_ORANGE_DRAGON,
  JTP_TILE_BABY_BLACK_DRAGON,
  JTP_TILE_BABY_BLUE_DRAGON,
  JTP_TILE_BABY_YELLOW_DRAGON,
  JTP_TILE_BABY_GREEN_DRAGON,
  JTP_TILE_GRAY_DRAGON,
  JTP_TILE_SILVER_DRAGON,
  JTP_TILE_RED_DRAGON,
  JTP_TILE_WHITE_DRAGON,
  JTP_TILE_ORANGE_DRAGON,
  JTP_TILE_BLACK_DRAGON,
  JTP_TILE_BLUE_DRAGON,
  JTP_TILE_YELLOW_DRAGON,
  JTP_TILE_GREEN_DRAGON,
  JTP_TILE_QUANTUM_MECHANIC,
  JTP_TILE_STONE_GIANT,
  JTP_TILE_HILL_GIANT,
  JTP_TILE_FIRE_GIANT,
  JTP_TILE_FROST_GIANT,
  JTP_TILE_STORM_GIANT,
  JTP_TILE_TITAN,
  JTP_TILE_MINOTAUR,
  JTP_TILE_JABBERWOCK,
  JTP_TILE_UMBER_HULK,
  JTP_TILE_KEYSTONE_KOP,
  JTP_TILE_KOP_SERGEANT,
  JTP_TILE_KOP_LIEUTENANT,
  JTP_TILE_KOP_KAPTAIN,
  JTP_TILE_LICH,
  JTP_TILE_DEMILICH,
  JTP_TILE_MASTER_LICH,
  JTP_TILE_ARCH_LICH,
  JTP_TILE_KOBOLD_MUMMY,
  JTP_TILE_GNOME_MUMMY,
  JTP_TILE_DWARF_MUMMY,
  JTP_TILE_ORC_MUMMY,
  JTP_TILE_ELF_MUMMY,
  JTP_TILE_HUMAN_MUMMY,
  JTP_TILE_ETTIN_MUMMY,
  JTP_TILE_GIANT_MUMMY,
  JTP_TILE_RED_NAGA_HATCHLING,
  JTP_TILE_BLACK_NAGA_HATCHLING,
  JTP_TILE_GOLDEN_NAGA_HATCHLING,
  JTP_TILE_GUARDIAN_NAGA_HATCHLING,
  JTP_TILE_RED_NAGA,
  JTP_TILE_BLACK_NAGA,
  JTP_TILE_GOLDEN_NAGA,
  JTP_TILE_GUARDIAN_NAGA,
  JTP_TILE_OGRE_LORD,
  JTP_TILE_OGRE_KING,
  JTP_TILE_GRAY_OOZE,
  JTP_TILE_BROWN_PUDDING,
  JTP_TILE_BLACK_PUDDING,
  JTP_TILE_RUST_MONSTER,
  JTP_TILE_DISENCHANTER,
  JTP_TILE_ICE_TROLL,
  JTP_TILE_ROCK_TROLL,
  JTP_TILE_WATER_TROLL,
  JTP_TILE_OLOG_HAI,
  JTP_TILE_VAMPIRE,
  JTP_TILE_VAMPIRE_LORD,
  JTP_TILE_BARROW_WIGHT,
  JTP_TILE_NAZGUL,
  JTP_TILE_XORN,
  JTP_TILE_MONKEY,
  JTP_TILE_APE,
  JTP_TILE_OWLBEAR,
  JTP_TILE_YETI,
  JTP_TILE_CARNIVOROUS_APE,
  JTP_TILE_SASQUATCH,
  JTP_TILE_KOBOLD_ZOMBIE,
  JTP_TILE_GNOME_ZOMBIE,
  JTP_TILE_DWARF_ZOMBIE,
  JTP_TILE_ORC_ZOMBIE,
  JTP_TILE_ELF_ZOMBIE,
  JTP_TILE_GIANT_ZOMBIE,
  JTP_TILE_ETTIN_ZOMBIE,
  JTP_TILE_HOMUNCULUS,
  JTP_TILE_LEMURE,
  JTP_TILE_QUASIT,
  JTP_TILE_TENGU,
  JTP_TILE_WUMPUS,
  JTP_TILE_ORACLE,
  JTP_TILE_LAWFUL_PRIEST,
  JTP_TILE_NEUTRAL_PRIEST,
  JTP_TILE_CHAOTIC_PRIEST,
  JTP_TILE_UNALIGNED_PRIEST,
  JTP_TILE_WATCHMAN,
  JTP_TILE_WATCH_CAPTAIN,
  JTP_TILE_SOLDIER,
  JTP_TILE_SERGEANT,
  JTP_TILE_LIEUTENANT,
  JTP_TILE_CAPTAIN,
  JTP_TILE_GRID_BUG,
  JTP_TILE_XAN,
  JTP_TILE_GARGOYLE,
  JTP_TILE_WINGED_GARGOYLE,
  JTP_TILE_DINGO,
  JTP_TILE_WOLF,
  JTP_TILE_WEREWOLF,
  JTP_TILE_WARG,
  JTP_TILE_WINTER_WOLF_CUB,
  JTP_TILE_WINTER_WOLF,
  JTP_TILE_HELL_HOUND_PUP,
  JTP_TILE_HELL_HOUND,
  JTP_TILE_JAGUAR,
  JTP_TILE_LYNX,
  JTP_TILE_PANTHER,
  JTP_TILE_TIGER,
  JTP_TILE_MIND_FLAYER,
  JTP_TILE_MASTER_MIND_FLAYER,
  JTP_TILE_SUCCUBUS,
  JTP_TILE_INCUBUS,
  JTP_TILE_GREMLIN,
  JTP_TILE_BABY_PURPLE_WORM,
  JTP_TILE_PURPLE_WORM,
  JTP_TILE_BABY_LONG_WORM,
  JTP_TILE_LONG_WORM,
  JTP_TILE_LONG_WORM_TAIL,
*************
#define JTP_TILE_KNIGHT 42
#define JTP_TILE_LITTLE_DOG 43
#define JTP_TILE_GREEN_SLIME 44
#define JTP_TILE_LIZARD 45
#define JTP_TILE_SPIDER 46
#define JTP_TILE_GOBLIN 47
#define JTP_TILE_EYE 48
#define JTP_TILE_IMP 49
#define JTP_TILE_FIRE_ELEMENTAL 50
#define JTP_TILE_OGRE 51
#define JTP_TILE_NAGA 52
#define JTP_TILE_KITTEN 53
#define JTP_TILE_WIZARD 54
#define JTP_TILE_VALKYRIE 55
#define JTP_TILE_RANGER 56
#define JTP_TILE_NYMPH 57
#define JTP_TILE_WATER_NYMPH 58
#define JTP_TILE_SKELETON 59
#define JTP_TILE_GHOST 60
#define JTP_TILE_WRAITH 61
#define JTP_TILE_HUMAN_ZOMBIE 63
#define JTP_TILE_STONE_GOLEM 64
#define JTP_TILE_RAT 65
#define JTP_TILE_TROLL 66
#define JTP_TILE_GIANT_BAT 67
#define JTP_TILE_MOUNTAIN_CENTAUR 68
#define JTP_TILE_GIANT_ANT 69
#define JTP_TILE_ARCHEOLOGIST 70
#define JTP_TILE_BEE 71
#define JTP_TILE_TOURIST 85
#define JTP_TILE_ROGUE 97
#define JTP_TILE_PRIEST 98
#define JTP_TILE_YELLOW_LIGHT 181
#define JTP_TILE_BLACK_LIGHT 182
#define JTP_TILE_YELLOW_MOLD 183
#define JTP_TILE_RED_MOLD 184
#define JTP_TILE_VIOLET_FUNGUS 185
#define JTP_TILE_BROWN_MOLD 186
#define JTP_TILE_SHRIEKER 187
#define JTP_TILE_COCKATRICE 188
#define JTP_TILE_KRAKEN 189
#define JTP_TILE_GIANT_EEL 190
#define JTP_TILE_SHARK 191
#define JTP_TILE_PYROLISK 219
#define JTP_TILE_CHICKATRICE 220
#define JTP_TILE_ACID_BLOB 221
#define JTP_TILE_QUIVERING_BLOB 222
#define JTP_TILE_GELATINOUS_CUBE 223
#define JTP_TILE_LICHEN 224
#define JTP_TILE_GREEN_MOLD 225
#define JTP_TILE_STALKER 226
#define JTP_TILE_AIR_ELEMENTAL 227
#define JTP_TILE_EARTH_ELEMENTAL 228
#define JTP_TILE_WATER_ELEMENTAL 229
#define JTP_TILE_SMALL_MIMIC 230
#define JTP_TILE_LARGE_MIMIC 231
#define JTP_TILE_GIANT_MIMIC 232
#define JTP_TILE_JACKAL 233
#define JTP_TILE_FOX 234
#define JTP_TILE_COYOTE 235
#define JTP_TILE_DOG 236
#define JTP_TILE_LARGE_DOG 237
#define JTP_TILE_ROCK_PIERCER 238
#define JTP_TILE_IRON_PIERCER 239
#define JTP_TILE_GLASS_PIERCER 240
#define JTP_TILE_WATER_DEMON 272
#define JTP_TILE_GECKO 273
#define JTP_TILE_NEWT 274
#define JTP_TILE_SHOPKEEPER 275
#define JTP_TILE_GAS_SPORE 276
#define JTP_TILE_HOUSECAT 277
#define JTP_TILE_LARGE_CAT 278
#define JTP_TILE_PONY 279
#define JTP_TILE_HORSE 280
#define JTP_TILE_WARHORSE 281
#define JTP_TILE_FREEZING_SPHERE 288
#define JTP_TILE_FLAMING_SPHERE 289
#define JTP_TILE_SHOCKING_SPHERE 290
#define JTP_TILE_ROTHE 291
#define JTP_TILE_GNOME 292
#define JTP_TILE_GREEN_ELF 293
#define JTP_TILE_DWARF 294
#define JTP_TILE_WATER_MOCCASIN 295
#define JTP_TILE_MANES 296
#define JTP_TILE_HOBBIT 297
#define JTP_TILE_BLACK_UNICORN 298
#define JTP_TILE_GRAY_UNICORN 299
#define JTP_TILE_WHITE_UNICORN 300
#define JTP_TILE_SOLDIER_ANT 301
#define JTP_TILE_FIRE_ANT 302
#define JTP_TILE_ELVENKING 303
#define JTP_TILE_ELF_LORD 304
#define JTP_TILE_GREY_ELF 305
#define JTP_TILE_WOODLAND_ELF 306
#define JTP_TILE_ELF 307
#define JTP_TILE_ROCK_MOLE 308
#define JTP_TILE_DWARF_LORD 309
#define JTP_TILE_DWARF_KING 310
#define JTP_TILE_GNOME_LORD 311
#define JTP_TILE_GNOME_KING 312
#define JTP_TILE_GNOMISH_WIZARD 313
#define JTP_TILE_ORC 314
#define JTP_TILE_HILL_ORC 315
#define JTP_TILE_MORDOR_ORC 316
#define JTP_TILE_URUK_HAI 317
#define JTP_TILE_HOBGOBLIN 318
#define JTP_TILE_BUGBEAR 319
#define JTP_TILE_KOBOLD 320
#define JTP_TILE_LARGE_KOBOLD 321
#define JTP_TILE_KOBOLD_LORD 322
#define JTP_TILE_KOBOLD_SHAMAN 323
#define JTP_TILE_ORC_CAPTAIN 324
#define JTP_TILE_ORC_SHAMAN 325
#define JTP_TILE_LEPRECHAUN 326
#define JTP_TILE_GARTER_SNAKE 327
#define JTP_TILE_SNAKE 328
#define JTP_TILE_PIT_VIPER 329
#define JTP_TILE_PYTHON 330
#define JTP_TILE_COBRA 331
#define JTP_TILE_GIANT 332
#define JTP_TILE_ETTIN 333
#define JTP_TILE_ROGUE_LEVEL_A 334
#define JTP_TILE_ROGUE_LEVEL_B 335
#define JTP_TILE_ROGUE_LEVEL_C 336
#define JTP_TILE_ROGUE_LEVEL_D 337
#define JTP_TILE_ROGUE_LEVEL_E 338
#define JTP_TILE_ROGUE_LEVEL_F 339
#define JTP_TILE_ROGUE_LEVEL_G 340
#define JTP_TILE_ROGUE_LEVEL_H 341
#define JTP_TILE_ROGUE_LEVEL_I 342
#define JTP_TILE_ROGUE_LEVEL_J 343
#define JTP_TILE_ROGUE_LEVEL_K 344
#define JTP_TILE_ROGUE_LEVEL_L 345
#define JTP_TILE_ROGUE_LEVEL_M 346
#define JTP_TILE_ROGUE_LEVEL_N 347
#define JTP_TILE_ROGUE_LEVEL_O 348
#define JTP_TILE_ROGUE_LEVEL_P 349
#define JTP_TILE_ROGUE_LEVEL_Q 350
#define JTP_TILE_ROGUE_LEVEL_R 351
#define JTP_TILE_ROGUE_LEVEL_S 352
#define JTP_TILE_ROGUE_LEVEL_T 353
#define JTP_TILE_ROGUE_LEVEL_U 354
#define JTP_TILE_ROGUE_LEVEL_V 355
#define JTP_TILE_ROGUE_LEVEL_W 356
#define JTP_TILE_ROGUE_LEVEL_X 357
#define JTP_TILE_ROGUE_LEVEL_Y 358
#define JTP_TILE_ROGUE_LEVEL_Z 359
#define JTP_TILE_COUATL 360
#define JTP_TILE_ALEAX 361
#define JTP_TILE_ANGEL 362
#define JTP_TILE_KI_RIN 363
#define JTP_TILE_ARCHON 364
#define JTP_TILE_VAMPIRE_BAT 365
#define JTP_TILE_RAVEN 366
#define JTP_TILE_FOREST_CENTAUR 367
#define JTP_TILE_PLAINS_CENTAUR 368
#define JTP_TILE_BAT 369
#define JTP_TILE_BABY_GRAY_DRAGON 370
#define JTP_TILE_BABY_SILVER_DRAGON 371
#define JTP_TILE_BABY_RED_DRAGON 372
#define JTP_TILE_BABY_WHITE_DRAGON 373
#define JTP_TILE_BABY_ORANGE_DRAGON 374
#define JTP_TILE_BABY_BLACK_DRAGON 375
#define JTP_TILE_BABY_BLUE_DRAGON 376
#define JTP_TILE_BABY_YELLOW_DRAGON 377
#define JTP_TILE_BABY_GREEN_DRAGON 62
#define JTP_TILE_GRAY_DRAGON 378
#define JTP_TILE_SILVER_DRAGON 379
#define JTP_TILE_RED_DRAGON 380
#define JTP_TILE_WHITE_DRAGON 381
#define JTP_TILE_ORANGE_DRAGON 382
#define JTP_TILE_BLACK_DRAGON 383
#define JTP_TILE_BLUE_DRAGON 384
#define JTP_TILE_YELLOW_DRAGON 385
#define JTP_TILE_GREEN_DRAGON 386
#define JTP_TILE_QUANTUM_MECHANIC 387
#define JTP_TILE_STONE_GIANT 388
#define JTP_TILE_HILL_GIANT 389
#define JTP_TILE_FIRE_GIANT 390
#define JTP_TILE_FROST_GIANT 391
#define JTP_TILE_STORM_GIANT 392
#define JTP_TILE_TITAN 393
#define JTP_TILE_MINOTAUR 394
#define JTP_TILE_JABBERWOCK 395
#define JTP_TILE_UMBER_HULK 396
#define JTP_TILE_KEYSTONE_KOP 397
#define JTP_TILE_KOP_SERGEANT 398
#define JTP_TILE_KOP_LIEUTENANT 399
#define JTP_TILE_KOP_KAPTAIN 400
#define JTP_TILE_LICH 401
#define JTP_TILE_DEMILICH 402
#define JTP_TILE_MASTER_LICH 403
#define JTP_TILE_ARCH_LICH 404
#define JTP_TILE_KOBOLD_MUMMY 405
#define JTP_TILE_GNOME_MUMMY 406
#define JTP_TILE_DWARF_MUMMY 407
#define JTP_TILE_ORC_MUMMY 408
#define JTP_TILE_ELF_MUMMY 409
#define JTP_TILE_HUMAN_MUMMY 410
#define JTP_TILE_ETTIN_MUMMY 411
#define JTP_TILE_GIANT_MUMMY 412
#define JTP_TILE_RED_NAGA_HATCHLING 413
#define JTP_TILE_BLACK_NAGA_HATCHLING 414
#define JTP_TILE_GOLDEN_NAGA_HATCHLING 415
#define JTP_TILE_GUARDIAN_NAGA_HATCHLING 416
#define JTP_TILE_RED_NAGA 417
#define JTP_TILE_BLACK_NAGA 418
#define JTP_TILE_GOLDEN_NAGA 419
#define JTP_TILE_GUARDIAN_NAGA 420
#define JTP_TILE_OGRE_LORD 421
#define JTP_TILE_OGRE_KING 422
#define JTP_TILE_GRAY_OOZE 423
#define JTP_TILE_BROWN_PUDDING 424
#define JTP_TILE_BLACK_PUDDING 425
#define JTP_TILE_RUST_MONSTER 426
#define JTP_TILE_DISENCHANTER 427
#define JTP_TILE_ICE_TROLL 428
#define JTP_TILE_ROCK_TROLL 429
#define JTP_TILE_WATER_TROLL 430
#define JTP_TILE_OLOG_HAI 431
#define JTP_TILE_VAMPIRE 433
#define JTP_TILE_VAMPIRE_LORD 434
#define JTP_TILE_BARROW_WIGHT 435
#define JTP_TILE_NAZGUL 436
#define JTP_TILE_XORN 437
#define JTP_TILE_MONKEY 438
#define JTP_TILE_APE 439
#define JTP_TILE_OWLBEAR 440
#define JTP_TILE_YETI 441
#define JTP_TILE_CARNIVOROUS_APE 442
#define JTP_TILE_SASQUATCH 443
#define JTP_TILE_KOBOLD_ZOMBIE 444
#define JTP_TILE_GNOME_ZOMBIE 445
#define JTP_TILE_DWARF_ZOMBIE 446
#define JTP_TILE_ORC_ZOMBIE 447
#define JTP_TILE_ELF_ZOMBIE 448
#define JTP_TILE_GIANT_ZOMBIE 449
#define JTP_TILE_ETTIN_ZOMBIE 450
#define JTP_TILE_HOMUNCULUS 454
#define JTP_TILE_LEMURE 455
#define JTP_TILE_QUASIT 456
#define JTP_TILE_TENGU 457
#define JTP_TILE_WUMPUS 458
#define JTP_TILE_ORACLE 459
#define JTP_TILE_LAWFUL_PRIEST 460
#define JTP_TILE_NEUTRAL_PRIEST 461
#define JTP_TILE_CHAOTIC_PRIEST 462
#define JTP_TILE_UNALIGNED_PRIEST 463
#define JTP_TILE_WATCHMAN 480
#define JTP_TILE_WATCH_CAPTAIN 481
#define JTP_TILE_SOLDIER 482
#define JTP_TILE_SERGEANT 483
#define JTP_TILE_LIEUTENANT 484
#define JTP_TILE_CAPTAIN 485
#define JTP_TILE_GRID_BUG 486
#define JTP_TILE_XAN 487
#define JTP_TILE_GARGOYLE 488
#define JTP_TILE_WINGED_GARGOYLE 489
#define JTP_TILE_DINGO 492
#define JTP_TILE_WOLF 493
#define JTP_TILE_WEREWOLF 494
#define JTP_TILE_WARG 495
#define JTP_TILE_WINTER_WOLF_CUB 496
#define JTP_TILE_WINTER_WOLF 497
#define JTP_TILE_HELL_HOUND_PUP 498
#define JTP_TILE_HELL_HOUND 499
#define JTP_TILE_JAGUAR 500
#define JTP_TILE_LYNX 501
#define JTP_TILE_PANTHER 502
#define JTP_TILE_TIGER 503
#define JTP_TILE_MIND_FLAYER 504
#define JTP_TILE_MASTER_MIND_FLAYER 505
#define JTP_TILE_SUCCUBUS 506
#define JTP_TILE_INCUBUS 507
#define JTP_TILE_GREMLIN 532
#define JTP_TILE_BABY_PURPLE_WORM 533
#define JTP_TILE_PURPLE_WORM 534
#define JTP_TILE_BABY_LONG_WORM 535
#define JTP_TILE_LONG_WORM 536
#define JTP_TILE_LONG_WORM_TAIL 537
#define JTP_TILE_MUMAK 538
#define JTP_TILE_LEOCROTTA 539
#define JTP_TILE_TITANOTHERE 540
#define JTP_TILE_BALUCHITHERIUM 541
#define JTP_TILE_MASTADON 542
#define JTP_TILE_ZRUTY 453
#define JTP_TILE_WIZARD_OF_YENDOR 544
^ ^ ^ ^ ^ ^ ^
^ ^ ^ ^ ^ ^ ^
^ ^ ^ ^ ^ ^ ^

/* Engulf tiles */
v v v v v v v
  JTP_TILE_ENGULF_OCHRE_JELLY,
  JTP_TILE_ENGULF_LURKER_ABOVE,
  JTP_TILE_ENGULF_TRAPPER,
  JTP_TILE_ENGULF_PURPLE_WORM,
  JTP_TILE_ENGULF_DUST_VORTEX,
  JTP_TILE_ENGULF_ICE_VORTEX,
  JTP_TILE_ENGULF_ENERGY_VORTEX,
  JTP_TILE_ENGULF_STEAM_VORTEX,
  JTP_TILE_ENGULF_FIRE_VORTEX,
  JTP_TILE_ENGULF_FOG_CLOUD,
  JTP_TILE_ENGULF_AIR_ELEMENTAL,
  JTP_TILE_ENGULF_YEENOGHU,
  
  JTP_MAX_TILES /* must always be last */
};
*************
v v v v v v v
^ ^ ^ ^ ^ ^ ^

v v v v v v v
*************
#define JTP_TILE_ENGULF_OCHRE_JELLY 468
#define JTP_TILE_ENGULF_LURKER_ABOVE 469
#define JTP_TILE_ENGULF_TRAPPER 470
#define JTP_TILE_ENGULF_PURPLE_WORM 471
#define JTP_TILE_ENGULF_DUST_VORTEX 472
#define JTP_TILE_ENGULF_ICE_VORTEX 473
#define JTP_TILE_ENGULF_ENERGY_VORTEX 474
#define JTP_TILE_ENGULF_STEAM_VORTEX 475
#define JTP_TILE_ENGULF_FIRE_VORTEX 476
#define JTP_TILE_ENGULF_FOG_CLOUD 477
#define JTP_TILE_ENGULF_AIR_ELEMENTAL 478
#define JTP_TILE_ENGULF_YEENOGHU 479

#define JTP_MAX_TILES 545
*************
  JTP_TILE_ENGULF_OCHRE_JELLY,
  JTP_TILE_ENGULF_LURKER_ABOVE,
  JTP_TILE_ENGULF_TRAPPER,
  JTP_TILE_ENGULF_PURPLE_WORM,
  JTP_TILE_ENGULF_DUST_VORTEX,
  JTP_TILE_ENGULF_ICE_VORTEX,
  JTP_TILE_ENGULF_ENERGY_VORTEX,
  JTP_TILE_ENGULF_STEAM_VORTEX,
  JTP_TILE_ENGULF_FIRE_VORTEX,
  JTP_TILE_ENGULF_FOG_CLOUD,
  JTP_TILE_ENGULF_AIR_ELEMENTAL,
  JTP_TILE_ENGULF_YEENOGHU,
  
  JTP_MAX_TILES /* must always be last */
};
^ ^ ^ ^ ^ ^ ^

^ ^ ^ ^ ^ ^ ^
/* Map symbols in the 'view map' display */
enum jtp_map_symbol {
  JTP_MAP_SYMBOL_WALL = 0,
  JTP_MAP_SYMBOL_FLOOR,
  JTP_MAP_SYMBOL_UP,
  JTP_MAP_SYMBOL_DOWN,
  JTP_MAP_SYMBOL_DOOR,
  JTP_MAP_SYMBOL_CMAP,
  JTP_MAP_SYMBOL_TRAP,
  JTP_MAP_SYMBOL_OBJECT,
  JTP_MAP_SYMBOL_MONSTER,
  JTP_MAX_MAP_SYMBOLS
};

#define JTP_MAX_SPELL_SYMBOLS 10

/* 
 * External files used by the GUI.
 * Note: The intro sequence may use other
 * external images, listed in the script file.
 * For DOS compatibility, use short filenames.
 */
#define JTP_MAX_FILENAME_LENGTH 1024

#define JTP_FILENAME_INTRO_SCRIPT  "jtp_intr.txt"
#define JTP_FILENAME_OPTIONS       "jtp_opts.txt"
#define JTP_FILENAME_SOUNDS_CONFIG "jtp_snds.txt"
#define JTP_FILENAME_KEYS_CONFIG   "jtp_keys.txt"
#define JTP_FILENAME_SHADING_TABLE "jtp_lit1.dat"

/*
 * graphics files, without ".pcx" extension
 */
#ifdef VULTURESEYE
#define JTP_FILENAME_NETHACK_LOGO         "jtp_nh_1"
#endif
#ifdef VULTURESCLAW
#define JTP_FILENAME_NETHACK_LOGO         "jtp_se_1"
#endif
#define JTP_FILENAME_CHARACTER_GENERATION "chargen2"
#define JTP_FILENAME_FONT_SMALL           "ttipchr1"
#define JTP_FILENAME_FONT_LARGE           "menuchr2"
#define JTP_FILENAME_WINDOW_STYLE         "jtp_win1"
#define JTP_FILENAME_STATUS_BAR           "jtp_st10"
#define JTP_FILENAME_MAP_PARCHMENT        "jtp_mwi4"
#define JTP_FILENAME_MAP_SYMBOLS          "micons2"
#define JTP_FILENAME_BACKPACK             "backpac5"
#define JTP_FILENAME_SPELLBOOK            "book1"
#define JTP_FILENAME_SPELL_SYMBOLS        "book2"
#define JTP_FILENAME_MOUSE_CURSORS        "jtp_mou5"

/*
 * Ending scenes. Eventually these could
 * be made configurable.
 */
#define JTP_FILENAME_ENDING_DIED          "cairn"
#define JTP_FILENAME_ENDING_ASCENDED      "night"
#define JTP_FILENAME_ENDING_QUIT          "quitgame"
#define JTP_FILENAME_ENDING_ESCAPED       "escaped"

typedef struct{
  char * str;
  int    action_id;
} jtp_dropdown_action;

/* Shortcut actions */
enum jtp_action {
  JTP_ACTION_NONE = 0,
  JTP_ACTION_CHAT,
  JTP_ACTION_CLOSE_DOOR,
  JTP_ACTION_ENGRAVE,
  JTP_ACTION_FORCE_LOCK,
  JTP_ACTION_GO_DOWN,
  JTP_ACTION_GO_UP,
  JTP_ACTION_KICK,
  JTP_ACTION_LOOT,
  JTP_ACTION_MONSTER_ABILITY,
  JTP_ACTION_MOVE_HERE,
  JTP_ACTION_OPEN_DOOR,
  JTP_ACTION_PAY_BILL,
  JTP_ACTION_PICK_UP,
  JTP_ACTION_PRAY,
  JTP_ACTION_PUSH_BOULDER,
  JTP_ACTION_REST,
  JTP_ACTION_RIDE,
  JTP_ACTION_SEARCH,
  JTP_ACTION_SIT,
  JTP_ACTION_TURN_UNDEAD,
  JTP_ACTION_UNTRAP,
  JTP_ACTION_WIPE_FACE,
  JTP_ACTION_DRINK,
  JTP_ACTION_LOOK_AROUND,
  JTP_ACTION_WHATS_THIS,
  JTP_ACTION_APPLY_ITEM,
  JTP_ACTION_DRINK_ITEM,
  JTP_ACTION_DROP_ITEM,
  JTP_ACTION_EAT_ITEM,
  JTP_ACTION_READ_ITEM,
  JTP_ACTION_REMOVE_ITEM,
  JTP_ACTION_WEAR_ITEM,
  JTP_ACTION_PUT_ON_ITEM,
  JTP_ACTION_WIELD_ITEM,
  JTP_ACTION_ZAP_ITEM,
  JTP_ACTION_ENTER_TRAP,
  JTP_ACTION_CAST_SPELL,
  JTP_ACTION_ATTACK,
};

/* Predefined background music names */
#define JTP_SONG_TITLE 0
#define JTP_SONG_INTRO 1
/*
define JTP_SONG_WATER_CAVES 27
define JTP_SONG_AIR_CAVES 28
define JTP_SONG_EARTH_CAVES 29
define JTP_SONG_FIRE_CAVES 30
define JTP_SONG_GNOMISH_MINES 31
define JTP_SONG_MINETOWN 32
define JTP_SONG_ORACLE 33
define JTP_SONG_LAMENT_1 34
define JTP_SONG_LAMENT_2 57
define JTP_SONG_AMBIENT_1 35
define JTP_SONG_AMBIENT_2 36
define JTP_SONG_BATTLE_1 37
define JTP_SONG_BATTLE_2 38
define JTP_SONG_SHOPPING 39
*/
#define JTP_SONG_ENDING_DIED 2
#define JTP_SONG_ENDING_ASCENDED 3
#define JTP_SONG_ENDING_QUIT 4
#define JTP_SONG_BACKGROUND 5

/* Predefined sound effect names */
#define JTP_SOUND_WALK 0
/*
define JTP_SOUND_CLOSE_DOOR 44
define JTP_SOUND_OPEN_DOOR 45
define JTP_SOUND_SWORD_HIT 46
define JTP_SOUND_SWORD_MISS 47
define JTP_SOUND_LEVEL_UP 48
define JTP_SOUND_CAT_MEOW 49
define JTP_SOUND_DOG_BARK 50
define JTP_SOUND_HORSE_WHINNY 51
define JTP_SOUND_FOUNTAIN 52
define JTP_SOUND_COUNTING 53
*/

/*---------------------------------------------------------
Local variables 
----------------------------------------------------------*/

/* Game directory (game files are expected to be under this) */
char *jtp_game_path;


/* Interface options */
int jtp_recenter_after_movement = 0;
int jtp_play_music = 0;
int jtp_play_effects = 0;
int jtp_one_command_per_click = 0;
/* Minimum scrolling delay (min time between scrolls, in seconds) */
double jtp_min_scroll_delay = 0.05;
double jtp_min_command_delay = 0.05;
char * jtp_external_midi_player_command = NULL;
char * jtp_external_mp3_player_command = NULL;

/* Event sounds */
jtp_event_sound ** jtp_event_sounds = NULL;
int jtp_n_event_sounds = 0;
int jtp_n_background_songs = 0;

/* Time of last scrolling event. Used to prevent overfast scrolling. */
double jtp_last_scroll_time = 0;

/* Window list */
jtp_list * jtp_windowlist = NULL; /* Linked list of all windows */
int jtp_max_window_id = -1;     /* Largest window id given */

/* Autopilot */
int jtp_movebuffer[JTP_MAX_MOVE_LENGTH]; /* Target squares for 'autopilot' */
int jtp_move_length = 0;       /* Length of autopilot sequence */
int jtp_autopilot_type;    /* Autopilot type (movement or whatis) */

/* Query response for shortcut-activated commands */
int jtp_is_shortcut_active = 0;
int jtp_shortcut_query_response;

/* Is the spellbook being viewed? */
int jtp_is_spellbook_being_viewed = 0;

/* Shortcut actions selected from the backpack or spellbook screen */
int jtp_is_backpack_shortcut_active = 0;
int jtp_backpack_shortcut_action;

/* Map window contents, as NetHack glyphs */
int ** jtp_mapglyph_cmap = NULL;  /* Topmost cmap glyphs */
int ** jtp_mapglyph_obj = NULL;   /* Topmost object glyphs */
int ** jtp_mapglyph_mon = NULL;   /* Topmost monster glyphs */
unsigned int ** jtp_mapglyph_special = NULL;   /* tile special attributes */

/* Translation tables: NetHack glyph to Vulture's tile */
int * jtp_montiles = NULL;        /* Monster glyph to monster tile */
int * jtp_objtiles = NULL;        /* Object glyph to object tile */
int * jtp_traptiles = NULL;       /* Trap glyph to trap tile */
int * jtp_cmaptiles = NULL;       /* Cmap glyph to cmap tile (walls and so on) */

/* Map window contents, as Vulture's tiles */
jtp_tilestats *** jtp_maptile_cmap = NULL; /* Cmap tiles (incl. floor, excluding walls) */
jtp_tilestats *** jtp_maptile_obj = NULL;  /* Object tiles */
jtp_tilestats *** jtp_maptile_mon = NULL;  /* Monster tiles */
jtp_wall_style ** jtp_maptile_wall = NULL; /* Custom (combination) wall style for each square */
jtp_floor_edge_style ** jtp_maptile_floor_edge = NULL; /* Custom floor edge style for each square */

int ** jtp_room_indices = NULL;            /* Room indices */
int ** jtp_map_light = NULL;               /* Light levels */

/* General map info */
int jtp_map_width, jtp_map_height; /* Map dimensions */
int jtp_map_x, jtp_map_y;  /* Center of displayed map area */
int jtp_map_tgtx, jtp_map_tgty; /* Selected square on map */

int jtp_map_changed;       /* Has the map changed since the last glyph->tile conversion? */
int jtp_game_palette_set;  /* Has the in-game palette been set already? */
int jtp_cur_dlevel;        /* Current dungeon level (used for initialization) */
int jtp_prev_dlevel;       /* Previous dungeon level */
int jtp_tile_conversion_initialized = 0; /* Have the conversion tables been set up? */

/* Light sources */
int jtp_nlights;           /* Number of light sources in use */
struct jtp_lights_struct {
  int x;
  int y;
  double radius;
} jtp_lights[JTP_MAX_LIGHTS]; /* Light source parameters (x,y,radius) */

/* Floor decorations */
int jtp_n_floor_decors = 0;    /* Number of floor decorations in use */
jtp_floor_decor * jtp_floor_decors = NULL;  /* Floor decorations table */

/* Status bar location */
int jtp_statusbar_x, jtp_statusbar_y;

/*
  Center coordinates of centermost displayed map tile.
  Used for quantizing target crosshairs location.
*/
int jtp_map_center_x, jtp_map_center_y;

/* Message window */
int jtp_messages_height;   /* height of messages shown on-screen */
int jtp_first_shown_message = 0; /* Index of newest shown message (>= 0), used by the "previous message" command */
unsigned char * jtp_messages_background = NULL; /* Messages overlap this part of map window */
static unsigned char jtp_message_colors[JTP_MAX_MESSAGE_COLORS]; /* Message age shading */
static unsigned char jtp_warn_colors[JTP_MAX_WARN];

/* Bitmap graphics */
jtp_window_graphics jtp_defwin; /* Basic window graphics */
jtp_tilestats ** jtp_tiles = NULL;     /* Isometric map tile set */
jtp_wall_style * jtp_walls = NULL;     /* Wall tiles for different wall styles (rough/brick/etc.) */
jtp_floor_style * jtp_floors = NULL;   /* Floor tiles for different floor styles (rough/stone/etc.) */
jtp_floor_edge_style * jtp_floor_edges = NULL; /* Floor edge tiles for different floor styles */
unsigned char * jtp_statusbar = NULL; /* Status bar graphic */

unsigned char * jtp_map_parchment_center = NULL; /* Map parchment graphic, center area */
unsigned char * jtp_map_parchment_top = NULL;    /* Map parchment graphic, top border */
unsigned char * jtp_map_parchment_bottom = NULL; /* Map parchment graphic, bottom border */
unsigned char * jtp_map_parchment_left = NULL;   /* Map parchment graphic, left border */
unsigned char * jtp_map_parchment_right = NULL;  /* Map parchment graphic, right border */
unsigned char * jtp_map_symbols[JTP_MAX_MAP_SYMBOLS]; /* Map parchment symbols */

unsigned char * jtp_backpack_center = NULL; /* Backpack graphic, center area */
unsigned char * jtp_backpack_top = NULL;    /* Backpack graphic, top border */
unsigned char * jtp_backpack_bottom = NULL; /* Backpack graphic, bottom border */
unsigned char * jtp_backpack_left = NULL;   /* Backpack graphic, left border */
unsigned char * jtp_backpack_right = NULL;  /* Backpack graphic, right border */

unsigned char * jtp_spellbook_center = NULL; /* Spellbook graphic, center area */
unsigned char * jtp_spellbook_top = NULL;    /* Spellbook graphic, top border */
unsigned char * jtp_spellbook_bottom = NULL; /* Spellbook graphic, bottom border */
unsigned char * jtp_spellbook_left = NULL;   /* Spellbook graphic, left border */
unsigned char * jtp_spellbook_right = NULL;  /* Spellbook graphic, right border */
unsigned char * jtp_spell_symbols[JTP_MAX_SPELL_SYMBOLS]; /* Spell symbols */

/* Lighting table (color conversion) */
unsigned char * jtp_shade = NULL;     /* Light shading table */

/* wall display style in use */
static int jtp_wall_display_style;

static struct {
	const char *str;
	int level;
} const jtp_condition_alerts[] = {
	/* encumberance */
	{ "Burdened", JTP_WARN_NORMAL },
	{ "Brd", JTP_WARN_NORMAL },
	{ "Stressed", JTP_WARN_MORE },
	{ "Ssd", JTP_WARN_NORMAL },
	{ "Strained", JTP_WARN_MORE },
	{ "Snd", JTP_WARN_NORMAL },
	{ "Overtaxed", JTP_WARN_ALERT },
	{ "Otd", JTP_WARN_ALERT },
	{ "Overloaded", JTP_WARN_CRITICAL },
	{ "Old", JTP_WARN_CRITICAL },
	/* hungry */
	{ "Satiated", JTP_WARN_NONE },
	{ "Sat", JTP_WARN_NONE },
	{ "Hungry", JTP_WARN_NORMAL },
	{ "Hun", JTP_WARN_NORMAL },
	{ "Weak", JTP_WARN_MORE },
	{ "Wea", JTP_WARN_MORE },
	{ "Fainting", JTP_WARN_CRITICAL },
	{ "Ftg", JTP_WARN_CRITICAL },
	{ "Fainted", JTP_WARN_ALERT },
	{ "Ftd", JTP_WARN_ALERT },
	{ "Starved", JTP_WARN_ALERT }, /* too late to warn about this ;) */
	{ "Sta", JTP_WARN_ALERT },
	/* Confusion */
	{ "Conf", JTP_WARN_MORE },
	{ "Cnf", JTP_WARN_MORE },
	/* Sick */
	{ "FoodPois", JTP_WARN_MORE },
	{ "FPs", JTP_WARN_MORE },
	{ "Ill", JTP_WARN_MORE },
	/* others */
	{ "Blind", JTP_WARN_MORE },
	{ "Bnd", JTP_WARN_MORE },
	{ "Stun", JTP_WARN_MORE },
	{ "Stn", JTP_WARN_MORE },
	{ "Hallu", JTP_WARN_MORE },
	{ "Hal", JTP_WARN_MORE },
	{ "Slime", JTP_WARN_MORE },
	{ "Slm", JTP_WARN_MORE },
	{ "Held", JTP_WARN_MORE },
};

/*----------------------------------------------------
  Function implementations 
-----------------------------------------------------*/

jtp_window *jtp_find_window(winid window)
{
  jtp_window * tempwindow;

  jtp_list_reset(jtp_windowlist);
  tempwindow = (jtp_window *)jtp_list_current(jtp_windowlist);
  while ((tempwindow) && (tempwindow->id != window))
  {
    jtp_list_advance(jtp_windowlist);
    tempwindow = (jtp_window *)jtp_list_current(jtp_windowlist);
  }
  return(tempwindow);
}


static void jtp_map_to_screen(int map_x, int map_y, int *screen_x, int *screen_y)
{
  map_x -= jtp_map_x;
  map_y -= jtp_map_y;
  *screen_x = jtp_map_center_x + JTP_MAP_XMOD*(map_x - map_y);
  *screen_y = jtp_map_center_y + JTP_MAP_YMOD*(map_x + map_y);
}


int jtp_find_menu_accelerator(const char *description, char *used_accelerators)
{
  char acc_found;
  int cur_accelerator;
  int j, k;

  /* Find an unused accelerator */

  /* Try a letter from the description */
  acc_found = 0;
  cur_accelerator = 0;
  for (k = 0; description[k] != '\0'; k++)
  {
    cur_accelerator = tolower(description[k]);
    acc_found = 1;
    for (j = 0; used_accelerators[j] != '\0'; j++)
      if (used_accelerators[j] == cur_accelerator) acc_found = 0;
    if (!acc_found)
    {
      cur_accelerator = toupper(description[k]);
      acc_found = 1;
      for (j = 0; used_accelerators[j] != '\0'; j++)
        if (used_accelerators[j] == cur_accelerator) acc_found = 0;
    }
    if (acc_found) break;
  }
  if (!acc_found)
  {
    /* Pick any available lowercase letter in the alphabet */
    for (cur_accelerator = 'a'; cur_accelerator <= 'z'; cur_accelerator++)
    {
      acc_found = 1;
      for (j = 0; used_accelerators[j] != '\0'; j++)
        if (used_accelerators[j] == cur_accelerator) acc_found = 0;
      if (acc_found) break;
    }
    /* Pick any available uppercase letter in the alphabet */
    if (!acc_found)
      for (cur_accelerator = 'A'; cur_accelerator <= 'Z'; cur_accelerator++)
      {
        acc_found = 1;
        for (j = 0; used_accelerators[j] != '\0'; j++)
          if (used_accelerators[j] == cur_accelerator) acc_found = 0;
        if (acc_found) break;
      }
  }

  if (acc_found)
  {
    /* Add found accelerator to string of used ones (assume there's enough room) */
    j = strlen(used_accelerators);
    used_accelerators[j] = cur_accelerator;
    used_accelerators[j+1] = '\0';
    return(cur_accelerator);
  }
  else return(-1);
}


void jtp_show_ending(jtp_window *tempwindow)
{
  int i, j, k, totallines;
  jtp_menuitem * tempmenuitem;
  char tempbuffer[1024];
  unsigned char *image;
  int image_width, image_height;
  
  /* 
   * Assume that the screen has been faded out by now.
   * Load the appropriate 'ending' image.
   */
  jtp_clear_screen();
  jtp_game_palette_set = 0;
  if (tempwindow->ending_type == QUIT)
  {
    image = jtp_load_graphic(NULL, JTP_FILENAME_ENDING_QUIT, TRUE);
    jtp_play_event_sound("nhfe_music_end_quit");
  }
  else if (tempwindow->ending_type == ASCENDED)
  {
    image = jtp_load_graphic(NULL, JTP_FILENAME_ENDING_ASCENDED, TRUE);
    jtp_play_event_sound("nhfe_music_end_ascended");
  }
  else if (tempwindow->ending_type == ESCAPED)
  {
    image = jtp_load_graphic(NULL, JTP_FILENAME_ENDING_ESCAPED, TRUE);
    jtp_play_event_sound("nhfe_music_end_ascended");
  }
  else if (tempwindow->ending_type < PANICKED)
  {
    image = jtp_load_graphic(NULL, JTP_FILENAME_ENDING_DIED, TRUE);
    jtp_play_event_sound("nhfe_music_end_died");
  }
  else
  {
    jtp_clear_screen();  /* No image associated with this ending */
    image = NULL;
  }
  if (image != NULL)
  {
    jtp_get_dimensions(image, &image_width, &image_height);
    jtp_put_img((jtp_screen.width - image_width) / 2, (jtp_screen.height - image_height) / 2, image);
    free(image);
  }
  
  jtp_refresh(&jtp_screen);
  jtp_fade_in(0.5);
  
  /* Count n. of rows to display */
  totallines = 0;
  if (tempwindow->menu)
  {
    jtp_list_reset(tempwindow->menu->items);
    while (jtp_list_current(tempwindow->menu->items))
    {
      totallines++;
      jtp_list_advance(tempwindow->menu->items);
    }
  }  
  /* Add prompt line */
  totallines++;

  /* Display the rows */
  if (totallines > 0)
  {
    k = jtp_screen.height - (totallines+1)*jtp_fonts[JTP_FONT_INTRO].lineheight;
    jtp_list_reset(tempwindow->menu->items);
    for (i = 0; i < totallines; i++)
    { 
      if (i == totallines-1) 
        strcpy(tempbuffer, "(press any key)");
      else 
      {
        tempmenuitem = (jtp_menuitem *)jtp_list_current(tempwindow->menu->items);
        strcpy(tempbuffer, tempmenuitem->text);
      }  
      j = (jtp_screen.width - jtp_text_length(tempbuffer, JTP_FONT_INTRO))/2;
      jtp_put_text(j, 
                   k + i*jtp_fonts[JTP_FONT_INTRO].lineheight + jtp_fonts[JTP_FONT_INTRO].baseline + 1,
                   JTP_FONT_INTRO, JTP_COLOR_BACKGROUND,
                   tempbuffer,
                   jtp_screen.vpage);
      jtp_put_text(j, 
                   k + i*jtp_fonts[JTP_FONT_INTRO].lineheight + jtp_fonts[JTP_FONT_INTRO].baseline,
                   JTP_FONT_INTRO, JTP_COLOR_INTRO_TEXT,
                   tempbuffer,
                   jtp_screen.vpage);
      jtp_list_advance(tempwindow->menu->items);             
    }               
  }
  
  jtp_refresh(&jtp_screen);
  while (jtp_getch() == 0 && jtp_readmouse() == JTP_MBUTTON_NONE)
    ;
  jtp_fade_out(0.5);  

  /* Restore the regular game palette */  
  memcpy(jtp_colors, jtp_game_colors, sizeof(jtp_colors));
  jtp_clear_screen();
  jtp_refresh(&jtp_screen);
  jtp_updatepal(0, 255);    
  jtp_game_palette_set = 1;
}


int 
jtp_is_onscreen(x, y)
int x, y;
{
  int i, j;
  jtp_map_to_screen(x, y, &i, &j);

  if ((i >= 50) && (i < jtp_screen.width-50) &&
      (j >= 50) && (j < jtp_screen.height-JTP_STATUSBAR_HEIGHT-50))
    return(1);
  return(0);  
}

/*
 * jtp_play_ambient_sound
 *
 * Play an ambient sound effect or background music.
 */
void jtp_play_ambient_sound(int force_play)
{
  int k;
  char tempbuffer[256];

  if ((!force_play) && (jtp_is_music_playing())) return;
  if (force_play) jtp_stop_music();

  k = (rand() >> 4)%jtp_n_background_songs;
  sprintf(tempbuffer, "nhfe_music_background%03d", k);
  jtp_play_event_sound(tempbuffer);
  /*
  switch(k)
  {
    case 0: jtp_play_midi_song(jtp_filenames[JTP_SONG_AIR_CAVES]); break;
    case 1: jtp_play_midi_song(jtp_filenames[JTP_SONG_WATER_CAVES]); break;
    case 2: jtp_play_midi_song(jtp_filenames[JTP_SONG_FIRE_CAVES]); break;
    case 3: jtp_play_midi_song(jtp_filenames[JTP_SONG_EARTH_CAVES]); break;
    case 4: jtp_play_midi_song(jtp_filenames[JTP_SONG_GNOMISH_MINES]); break;
    case 5: jtp_play_midi_song(jtp_filenames[JTP_SONG_MINETOWN]); break;
    case 6: jtp_play_midi_song(jtp_filenames[JTP_SONG_ORACLE]); break;
    case 7: jtp_play_midi_song(jtp_filenames[JTP_SONG_LAMENT_1]); break;
    case 8: jtp_play_midi_song(jtp_filenames[JTP_SONG_LAMENT_2]); break;
    case 9: jtp_play_midi_song(jtp_filenames[JTP_SONG_AMBIENT_1]); break;
    case 10: jtp_play_midi_song(jtp_filenames[JTP_SONG_AMBIENT_2]); break;
    case 11: jtp_play_midi_song(jtp_filenames[JTP_SONG_BATTLE_1]); break;
    case 12: jtp_play_midi_song(jtp_filenames[JTP_SONG_BATTLE_2]); break;
    default: break;
  }
  */
}

/*
 * jtp_play_event_sound
 *
 * Play a sound effect or song associated with a NetHack event.
 */
void jtp_play_event_sound(const char * str)
{
  int i;
  for (i = 0; i < jtp_n_event_sounds; i++)
    if (strstr(str, (jtp_event_sounds[i])->searchpattern))
    {
      if ((jtp_event_sounds[i])->soundtype == JTP_EVENT_SOUND_TYPE_SND)      
        jtp_play_sound((jtp_event_sounds[i])->filename);
      else if ((jtp_event_sounds[i])->soundtype == JTP_EVENT_SOUND_TYPE_MUS)
        jtp_play_song((jtp_event_sounds[i])->filename);
      else if ((jtp_event_sounds[i])->soundtype == JTP_EVENT_SOUND_TYPE_CD_AUDIO)
        jtp_play_cd_track((jtp_event_sounds[i])->filename);
      else if ((jtp_event_sounds[i])->soundtype == JTP_EVENT_SOUND_TYPE_RANDOM_SONG)
        jtp_play_ambient_sound(1);

      i = jtp_n_event_sounds;
    }
}

/*
 * jtp_play_command_sound
 *
 * Play a sound effect associated with a NetHack command.
 */
void jtp_play_command_sound(int cur_cmd)
{
  switch(cur_cmd)
  {
    case JTP_NHCMD_NORTH: case JTP_NHCMD_SOUTH: 
    case JTP_NHCMD_WEST: case JTP_NHCMD_EAST:
    case JTP_NHCMD_NORTHWEST: case JTP_NHCMD_NORTHEAST:
    case JTP_NHCMD_SOUTHWEST: case JTP_NHCMD_SOUTHEAST: 
      jtp_play_event_sound("nhfe_sound_walk"); 
      /* jtp_play_wave_sound(jtp_filenames[JTP_SOUND_WALK], 44100, 16, 1); */
      break;
    default: break;
  }
}


static int jtp_cmap_to_tile(int cur_glyph)
{
  if ((cur_glyph >= 0) && (cur_glyph < MAXPCHARS))
    return(jtp_cmaptiles[cur_glyph]);
  else if (cur_glyph == JTP_WINCONTENT_GLYPH_NOT_VISIBLE)
    return(JTP_TILE_FLOOR_NOT_VISIBLE);
  return(JTP_TILE_INVALID);
}


/*
 * jtp_flood_fill_room
 *
 * Assigns room index to all pixels within a room,
 * using a recursive Flood Fill algorithm.
 */
static void jtp_flood_fill_room(
  int row1, int col1,
  int roomindex,
  int ** roomindices
)
{
  /* Basic case: nothing to do */
  if ((roomindices[row1][col1] < 0) ||
      (roomindices[row1][col1] == roomindex))
    return;

  roomindices[row1][col1] = roomindex;
  if (col1 > 1) jtp_flood_fill_room(row1, col1-1, roomindex, roomindices);
  if (row1 > 0) jtp_flood_fill_room(row1-1, col1, roomindex, roomindices);
  if (col1 < JTP_MAP_WIDTH-1) jtp_flood_fill_room(row1, col1+1, roomindex, roomindices);
  if (row1 < JTP_MAP_HEIGHT-1) jtp_flood_fill_room(row1+1, col1, roomindex, roomindices);
}

/* 
 * jtp_find_room_indices
 *
 * Assign room indices to room squares.
 */
static void jtp_find_room_indices(
	 int **roomindices					/* Preallocated storage array for room indices) */
)
{
  int cur_glyph;
  int all_known;
  int roomindex;
  int i, j;

  /*
   * Create initial indices array
   */
  for (i = JTP_MAP_HEIGHT-1; i >= 0; i--)
    for (j = JTP_MAP_WIDTH-1; j >= 1; j--)
    {
      cur_glyph = levl[j][i].typ;
         
      /* 
       * If the square is not a room square,
       * we don't give it an index.
       */
      if ((cur_glyph == STONE) ||
          (cur_glyph == VWALL) ||
          (cur_glyph == HWALL) ||
          (cur_glyph == TLCORNER) ||
          (cur_glyph == TRCORNER) ||
          (cur_glyph == BLCORNER) ||
          (cur_glyph == BRCORNER) ||
          (cur_glyph == CROSSWALL) ||
          (cur_glyph == TUWALL) ||
          (cur_glyph == TDWALL) ||
          (cur_glyph == TRWALL) ||
          (cur_glyph == DBWALL) ||
          (cur_glyph == SDOOR) ||
          (cur_glyph == SCORR) ||
          (cur_glyph == MOAT) ||
          (cur_glyph == POOL) ||
          (cur_glyph == WATER) ||
          (cur_glyph == DRAWBRIDGE_UP) ||
          (cur_glyph == LAVAPOOL) ||
          (cur_glyph == IRONBARS) ||
          (cur_glyph == DOOR) ||
          (cur_glyph == CORR) ||
          (cur_glyph == DRAWBRIDGE_DOWN))
        roomindices[i][j] = -1; /* Square is not part of a room */
      else                                   
        roomindices[i][j] = 0;  /* Square is part of a room */
    }

  all_known = 0;
  roomindex = 1;
  while (!all_known)
  {
    /* Find a room square with zero (unknown) room index */
    all_known = 1;
    for (i = JTP_MAP_HEIGHT-1; i >= 0; i--)
      for (j = JTP_MAP_WIDTH-1; j >= 1; j--)
        if (roomindices[i][j] == 0)
        {
          jtp_flood_fill_room(i, j, roomindex, roomindices);
          roomindex++;
          all_known = 0;

          /* Exit loop */
          i = -1; j = -1; 
        }
  }
}



static void jtp_tooltip_location(
  int moux,
  int mouy, 
  jtp_mouse_cursor *m_cursor, 
  int *ttip_x, 
  int *ttip_y, 
  unsigned char *ttip
)
{
 if (!ttip)
 {
   *ttip_x = moux; *ttip_y = mouy; return;
 }

 if (moux + m_cursor->xmod + 256*(int)ttip[2] + ttip[3] > jtp_screen.width)
   *ttip_x = jtp_screen.width - 256*(int)ttip[2] - ttip[3];
 else if (moux + m_cursor->xmod < 0)
   *ttip_x = 0;
 else  
   *ttip_x = moux + m_cursor->xmod;

 if (mouy + m_cursor->ymod + m_cursor->graphic[1] + ttip[1] > jtp_screen.height)
   *ttip_y = mouy - ttip[1];
 else if (mouy + m_cursor->ymod + m_cursor->graphic[1] < 0)
   *ttip_y = 0;
 else  
   *ttip_y = mouy + m_cursor->ymod + m_cursor->graphic[1];
}


static unsigned char *jtp_make_tooltip(const char *tip_text)
{
 unsigned char *temp;
 int i,xsize,ysize;

 xsize = jtp_text_length(tip_text, JTP_FONT_TOOLTIP) + 6;
 ysize = jtp_text_height(tip_text, JTP_FONT_TOOLTIP) + 6;

 temp = (unsigned char *)malloc((xsize*ysize+4)*sizeof(unsigned char));
 if (!temp)
 {
   OOM(1);
 }
 jtp_put_dimensions(temp, xsize, ysize);
 memset(temp + 4, JTP_COLOR_TEXT, xsize * ysize);
 for (i = 0; i < xsize; i++)
 {
   temp[i+4] = JTP_COLOR_BACKGROUND;
   temp[(ysize-1)*xsize+i+4] = JTP_COLOR_BACKGROUND;
 }
 for (i = 0; i < ysize; i++)
 {
    temp[i*xsize+4] = JTP_COLOR_BACKGROUND;
    temp[i*xsize+xsize-1+4] = JTP_COLOR_BACKGROUND;
 }
 jtp_put_text(3, 3+jtp_fonts[JTP_FONT_TOOLTIP].baseline, JTP_FONT_TOOLTIP, JTP_COLOR_BACKGROUND, tip_text, temp);
 return(temp);
}

static int jtp_mouse_hotspot(void)
{
  int hotspot;
  
  if (jtp_mouse_area(0, 0, jtp_screen.width-1, 20)) 
    hotspot = JTP_HOTSPOT_SCROLL_UP;
  else if (jtp_mouse_area(0, jtp_statusbar_y-1-20, 
                          jtp_screen.width-1, jtp_statusbar_y-1)) 
    hotspot = JTP_HOTSPOT_SCROLL_DOWN;
  else if (jtp_mouse_area(0, 0, 20, jtp_statusbar_y-1))
    hotspot = JTP_HOTSPOT_SCROLL_LEFT;
  else if (jtp_mouse_area(jtp_screen.width-1-20, 0, 
                          jtp_screen.width-1, jtp_statusbar_y-1))
    hotspot = JTP_HOTSPOT_SCROLL_RIGHT;
  else if (jtp_mouse_area(jtp_statusbar_x + 625, jtp_statusbar_y + 3, 
                          jtp_statusbar_x + 675, jtp_statusbar_y + 46)) 
    hotspot = JTP_HOTSPOT_BUTTON_MAP;
  else if (jtp_mouse_area(jtp_statusbar_x + 680, jtp_statusbar_y + 0, 
                          jtp_statusbar_x + 731, jtp_statusbar_y + 47))
    hotspot = JTP_HOTSPOT_BUTTON_MESSAGES;
  else if (jtp_mouse_area(jtp_statusbar_x + 737, jtp_statusbar_y + 53, 
                          jtp_statusbar_x + 787, jtp_statusbar_y + 91))
    hotspot = JTP_HOTSPOT_BUTTON_HELP;
  else if (jtp_mouse_area(jtp_statusbar_x + 625, jtp_statusbar_y + 50, 
                          jtp_statusbar_x + 675, jtp_statusbar_y + 91))
    hotspot = JTP_HOTSPOT_BUTTON_SPELLBOOK;
  else if (jtp_mouse_area(jtp_statusbar_x + 681, jtp_statusbar_y + 47, 
                          jtp_statusbar_x + 731, jtp_statusbar_y + 91)) 
    hotspot = JTP_HOTSPOT_BUTTON_INVENTORY;
  else if (jtp_mouse_area(jtp_statusbar_x + 568, jtp_statusbar_y + 8, 
                          jtp_statusbar_x + 620, jtp_statusbar_y + 46)) 
    hotspot = JTP_HOTSPOT_BUTTON_LOOK;
  else if (jtp_mouse_area(jtp_statusbar_x + 568, jtp_statusbar_y + 48, 
                          jtp_statusbar_x + 619, jtp_statusbar_y + 91)) 
    hotspot = JTP_HOTSPOT_BUTTON_EXTENDED;
  else if (jtp_mouse_area(jtp_statusbar_x + 737, jtp_statusbar_y + 2, 
                          jtp_statusbar_x + 787, jtp_statusbar_y + 46)) 
    hotspot = JTP_HOTSPOT_BUTTON_OPTIONS;
  else if (jtp_mouse_area(jtp_statusbar_x + 4, jtp_statusbar_y + 4,
                          jtp_statusbar_x + 193, jtp_statusbar_y + 96))
    hotspot = JTP_HOTSPOT_MINI_MAP;
  else if (jtp_mouse_area(0, jtp_statusbar_y, 
                          jtp_screen.width-1, jtp_screen.height-1))
    hotspot = JTP_HOTSPOT_STATUSBAR;
  else hotspot = JTP_HOTSPOT_MAP;
  
  return(hotspot);
}

static char *jtp_map_square_description(
	 int tgt_x, int tgt_y,
	 int include_seen
)
{
  /*
   * Choose an explanatory tooltip for the target square.
   * This code is based on do_look (in pager.c).
   * It would be better to make it a separate function.
   */
  struct permonst *pm;
  char   *out_str, look_buf[BUFSZ];
  char   temp_buf[BUFSZ], coybuf[QBUFSZ];  
  char   monbuf[BUFSZ];
  register struct monst *mtmp = (struct monst *) 0;
  const char *firstmatch;

  if ((tgt_x < 1) || (tgt_x >= JTP_MAP_WIDTH) || (tgt_y < 0) || (tgt_y >= JTP_MAP_HEIGHT))
    return(NULL);
  
  /* 
   * Only objects and monsters get a tooltip.
   * Traps and some cmap objects should also (on the 'to do' list).
   */
  if ((jtp_mapglyph_mon[tgt_y][tgt_x] >= 0) ||
      (jtp_mapglyph_obj[tgt_y][tgt_x] >= 0))
  {
    out_str = (char *)malloc(BUFSZ);
    out_str[0] = '\0';
  
    look_buf[0] = '\0';
    monbuf[0] = '\0';
    pm = (struct permonst *)lookat(tgt_x, tgt_y, look_buf, monbuf);
    firstmatch = look_buf;
    if (*firstmatch) {
      mtmp = m_at(tgt_x,tgt_y);
      Sprintf(temp_buf, "%s",
  		(pm == &mons[PM_COYOTE]) ?
  		coyotename(mtmp,coybuf) : firstmatch);
      (void)strncat(out_str, temp_buf, BUFSZ-strlen(out_str)-1);
      /* found = 1;	we have something to look up */
    }
    if (include_seen)
    {
      if (monbuf[0]) {
        Sprintf(temp_buf, " [seen: %s]", monbuf);
        (void)strncat(out_str, temp_buf, BUFSZ-strlen(out_str)-1);
      }
    }
    return(out_str);
  }  
  switch (jtp_mapglyph_cmap[tgt_y][tgt_x])
  {
  	case S_vodoor: case S_vcdoor: case S_hodoor: case S_hcdoor:
  	case S_bars: case S_tree:
  	case S_upstair: case S_dnstair: case S_upladder: case S_dnladder:
  	case S_altar: case S_grave: case S_throne: case S_sink:
#ifdef S_toilet
  	case S_toilet:
#endif
  	case S_fountain:
  	case S_vodbridge: case S_vcdbridge: case S_hodbridge: case S_hcdbridge:
  	case S_arrow_trap: case S_dart_trap: case S_falling_rock_trap:
  	case S_squeaky_board: case S_bear_trap: case S_land_mine:
  	case S_rolling_boulder_trap: case S_sleeping_gas_trap: case S_rust_trap:
  	case S_fire_trap: case S_pit: case S_spiked_pit: case S_hole:
  	case S_trap_door: case S_teleportation_trap: case S_level_teleporter:
  	case S_magic_portal: case S_web: case S_statue_trap:
  	case S_magic_trap: case S_anti_magic_trap: case S_polymorph_trap:
  	  return jtp_strdup(defsyms[jtp_mapglyph_cmap[tgt_y][tgt_x]].explanation);
  }
  return(NULL);
}


static unsigned char *jtp_choose_target_tooltip(int tgt_x, int tgt_y)
{
  unsigned char * new_tip;
  char * out_str;

  out_str = jtp_map_square_description(tgt_x, tgt_y, 1);
  if (out_str)
  {
    new_tip = jtp_make_tooltip(out_str);
    free(out_str);
    return(new_tip);
  }
  return(NULL);
}


static unsigned char *jtp_choose_tooltip(int hotspot)
{
  unsigned char * new_tip;

  switch (hotspot)
  {
    case JTP_HOTSPOT_NONE:
      new_tip = NULL;
      break;
    case JTP_HOTSPOT_MAP:
      new_tip = NULL;
      break;
    case JTP_HOTSPOT_SCROLL_UP:
      new_tip = jtp_make_tooltip("Scroll Up");
      break;
    case JTP_HOTSPOT_SCROLL_DOWN:
      new_tip = jtp_make_tooltip("Scroll Down");
      break;
    case JTP_HOTSPOT_SCROLL_LEFT:
      new_tip = jtp_make_tooltip("Scroll Left");
      break;
    case JTP_HOTSPOT_SCROLL_RIGHT:
      new_tip = jtp_make_tooltip("Scroll Right");
      break;
    case JTP_HOTSPOT_BUTTON_MAP:
      new_tip = jtp_make_tooltip("View Map");
      break;
    case JTP_HOTSPOT_BUTTON_MESSAGES:
      new_tip = jtp_make_tooltip("Old Messages");
      break;
    case JTP_HOTSPOT_BUTTON_HELP:
      new_tip = jtp_make_tooltip("Help");
      break;
    case JTP_HOTSPOT_BUTTON_SPELLBOOK:
      new_tip = jtp_make_tooltip("View Spells");
      break;
    case JTP_HOTSPOT_BUTTON_INVENTORY:
      new_tip = jtp_make_tooltip("Inventory");
      break;
    case JTP_HOTSPOT_BUTTON_LOOK:
      new_tip = jtp_make_tooltip("Look");
      break;
    case JTP_HOTSPOT_BUTTON_EXTENDED:
      new_tip = jtp_make_tooltip("Extended Commands");
      break;
    case JTP_HOTSPOT_BUTTON_OPTIONS:
      new_tip = jtp_make_tooltip("Options");
      break;      
    default:
      new_tip = NULL;
      break;
  }
  return(new_tip);
}


static jtp_mouse_cursor *jtp_choose_target_cursor(int tgt_x, int tgt_y)
{
  int cur_tile;

  if ((tgt_x < 1) || (tgt_x >= JTP_MAP_WIDTH) || (tgt_y < 0) || (tgt_y >= JTP_MAP_HEIGHT))
    return(jtp_mcursor[JTP_CURSOR_TARGET_INVALID]);

  if (jtp_whatis_active)
    return(jtp_mcursor[JTP_CURSOR_TARGET_HELP]);
    
  if (jtp_mapglyph_mon[tgt_y][tgt_x] >= 0)
    if ((tgt_x != u.ux) || (tgt_y != u.uy))
      return(jtp_mcursor[JTP_CURSOR_TARGET_RED]);
  
  if (jtp_mapglyph_obj[tgt_y][tgt_x] >= 0)  
    return(jtp_mcursor[JTP_CURSOR_TARGET_RED]);
  
  if (jtp_mapglyph_cmap[tgt_y][tgt_x] >= 0 ||  /* valid visible location  */
      jtp_mapglyph_cmap[tgt_y][tgt_x] == JTP_WINCONTENT_GLYPH_NOT_VISIBLE) /* valid but dark */
  {
    /* Closed doors get an 'open door' cursor */
    if ((jtp_mapglyph_cmap[tgt_y][tgt_x] == S_vcdoor) ||
        (jtp_mapglyph_cmap[tgt_y][tgt_x] == S_hcdoor))
      return(jtp_mcursor[JTP_CURSOR_OPENDOOR]);

    /* Stairs and ladders get a 'stairs' cursor */
    if ((jtp_mapglyph_cmap[tgt_y][tgt_x] == S_upstair) ||
        (jtp_mapglyph_cmap[tgt_y][tgt_x] == S_dnstair) ||
        (jtp_mapglyph_cmap[tgt_y][tgt_x] == S_upladder) ||
        (jtp_mapglyph_cmap[tgt_y][tgt_x] == S_dnladder))
      return(jtp_mcursor[JTP_CURSOR_STAIRS]);

    /* Fountains get a 'goblet' cursor */
    if (jtp_mapglyph_cmap[tgt_y][tgt_x] == S_fountain)
      return(jtp_mcursor[JTP_CURSOR_GOBLET]);

    cur_tile = jtp_cmap_to_tile(jtp_mapglyph_cmap[tgt_y][tgt_x]);
    if (cur_tile != JTP_TILE_WALL_GENERIC)
      return(jtp_mcursor[JTP_CURSOR_TARGET_GREEN]);    
    return(jtp_mcursor[JTP_CURSOR_TARGET_INVALID]);  
  }  
  return(jtp_mcursor[JTP_CURSOR_TARGET_INVALID]);
}




static void jtp_get_mouse_input(jtp_mouse_cursor * m_cursor, int whenstop)
{
  int        target_x = -1, target_y = -1;
  int        target_old_x = -1, target_old_y = -1;

  int        hotspot = JTP_HOTSPOT_NONE;
  int        old_hotspot = JTP_HOTSPOT_NONE;

  unsigned char *m_bg = NULL;
  jtp_mouse_cursor *m_old_cursor = m_cursor;

  int        ttip_x = -1, ttip_y = -1;
  int        ttip_old_x = -1, ttip_old_y = -1;
  unsigned char *tooltip = NULL;
  unsigned char *ttip_bg = NULL;
  unsigned char *ttip_old_bg = NULL;


  int         i, j;
  char        forcedraw = 1;
  char        stopmouse = 0;

  jtp_readmouse();

  do
  {
    /* 
       At this point the pointer status is:
       tooltip:     not NULL, may change on mouse movement
       ttip_bg:     not NULL, changes on mouse movement
       ttip_old_bg: NULL
       m_bg:        NULL
    */
  
    if ((jtp_oldmx!=jtp_mousex) || (jtp_oldmy!=jtp_mousey) || forcedraw)
    {
      /* 
       * Find the map square under the mouse cursor.
       * The isometric mapping is a matrix operation, y = Ax+b, where the y are screen 
       * coordinates, the x are map square indices and A, b are constant. 
       * Here we use an inverse mapping to find map indices from pixel coordinates.
       */
      target_old_x = target_x; target_old_y = target_y;
      i = jtp_mousex - jtp_map_center_x + (jtp_map_x-jtp_map_y)*JTP_MAP_XMOD;
      j = jtp_mousey - jtp_map_center_y + (jtp_map_x+jtp_map_y)*JTP_MAP_YMOD;
      target_x = (JTP_MAP_YMOD*i + JTP_MAP_XMOD*j + JTP_MAP_XMOD*JTP_MAP_YMOD)/(2*JTP_MAP_XMOD*JTP_MAP_YMOD);
      target_y = (-JTP_MAP_YMOD*i + JTP_MAP_XMOD*j + JTP_MAP_XMOD*JTP_MAP_YMOD)/(2*JTP_MAP_XMOD*JTP_MAP_YMOD);

      /* Store map square indices */
      jtp_map_tgtx = target_x;
      jtp_map_tgty = target_y;
      
      /* Find the current hotspot */
      old_hotspot = hotspot;
      hotspot = jtp_mouse_hotspot();
      
      /* Choose a mouse cursor for current hotspot */
      m_old_cursor = m_cursor; /* Necessary to get correct refresh area */
      switch (hotspot)
      {
        case JTP_HOTSPOT_MAP:
          m_cursor = jtp_choose_target_cursor(target_x, target_y);
          break;
        case JTP_HOTSPOT_SCROLL_UP:
          m_cursor = jtp_mcursor[JTP_CURSOR_SCROLLUP];
          break;
        case JTP_HOTSPOT_SCROLL_DOWN:
          m_cursor = jtp_mcursor[JTP_CURSOR_SCROLLDOWN];
          break;
        case JTP_HOTSPOT_SCROLL_LEFT:
          m_cursor = jtp_mcursor[JTP_CURSOR_SCROLLLEFT];
          break;
        case JTP_HOTSPOT_SCROLL_RIGHT:
          m_cursor = jtp_mcursor[JTP_CURSOR_SCROLLRIGHT];
          break;
        default:
          m_cursor = jtp_mcursor[JTP_CURSOR_NORMAL];
          break;
      }

      /* DEBUG */ if (!m_cursor) m_cursor = jtp_mcursor[JTP_CURSOR_NORMAL]; /* DEBUG */

      /* Store the background of the new cursor */
      m_bg = jtp_get_img(jtp_mousex+m_cursor->xmod,jtp_mousey+m_cursor->ymod,
                         jtp_mousex+m_cursor->xmod+m_cursor->graphic[3],
                         jtp_mousey+m_cursor->ymod+m_cursor->graphic[1]);

      /* Choose a new tooltip for current hotspot, if changed */
      ttip_old_bg = ttip_bg;
      ttip_old_x = ttip_x;
      ttip_old_y = ttip_y;
      if (hotspot == JTP_HOTSPOT_MAP)
      {
        if ((old_hotspot != JTP_HOTSPOT_MAP) ||
            (target_x != target_old_x) || (target_y != target_old_y))
        {
          free(tooltip);
          tooltip = jtp_choose_target_tooltip(target_x, target_y);
          jtp_tooltip_location(jtp_mousex, jtp_mousey, m_cursor, &ttip_x, &ttip_y, tooltip);
        }
      }
      else if (hotspot != old_hotspot)
      {
        free(tooltip);
        tooltip = jtp_choose_tooltip(hotspot);
        jtp_tooltip_location(jtp_mousex, jtp_mousey, m_cursor, &ttip_x, &ttip_y, tooltip);
      }

      /* Store the background of the new tooltip */
      if (tooltip)
      {
        ttip_bg = jtp_get_img(ttip_x, ttip_y, 
                              ttip_x + tooltip[2]*256 + tooltip[3] - 1, 
                              ttip_y + tooltip[0]*256 + tooltip[1] - 1);
      }
      else ttip_bg = NULL;

      /* Draw mouse cursor and tooltip */
      jtp_put_img(ttip_x, ttip_y, tooltip);
      jtp_put_stencil(jtp_mousex+m_cursor->xmod, jtp_mousey+m_cursor->ymod, m_cursor->graphic);
 
      if (forcedraw)
      {
        /* Refresh the entire screen */
        jtp_refresh(&jtp_screen);
        forcedraw = 0;
      }
      else
      {
        /* Refresh old and new areas of mouse cursor */
        jtp_refresh_region(jtp_mousex + m_cursor->xmod, jtp_mousey + m_cursor->ymod,
                jtp_mousex + m_cursor->xmod + m_cursor->graphic[3] - 1, 
                jtp_mousey + m_cursor->ymod + m_cursor->graphic[1] - 1, &jtp_screen);
        jtp_refresh_region(jtp_oldmx + m_old_cursor->xmod, jtp_oldmy + m_old_cursor->ymod,
                jtp_oldmx + m_old_cursor->xmod + m_old_cursor->graphic[3] - 1, 
                jtp_oldmy + m_old_cursor->ymod + m_old_cursor->graphic[1] - 1, &jtp_screen);
 
        /* Refresh old and new areas of tooltip */
        if (ttip_bg)
          jtp_refresh_region(ttip_x, ttip_y,
                  ttip_x + ttip_bg[2]*256 + ttip_bg[3] - 1, 
                  ttip_y + ttip_bg[0]*256 + ttip_bg[1] - 1, &jtp_screen);
        if (ttip_old_bg)
          jtp_refresh_region(ttip_old_x, ttip_old_y,
                  ttip_old_x + ttip_old_bg[2]*256 + ttip_old_bg[3] - 1, 
                  ttip_old_y + ttip_old_bg[0]*256 + ttip_old_bg[1] - 1, &jtp_screen);
      }

      /* Restore mouse background */
      jtp_put_img(jtp_mousex + m_cursor->xmod, jtp_mousey + m_cursor->ymod, m_bg);
 
      /* Restore tooltip background */
      if (ttip_bg) jtp_put_img(ttip_x, ttip_y, ttip_bg);

      /* Now that we've used them in a screen refresh, the old backgrounds can be freed */
      free(ttip_old_bg); ttip_old_bg = NULL;
      free(m_bg); m_bg = NULL;
    }
    jtp_get_event();
    jtp_readmouse();
    if ((whenstop >= 0) && (jtp_mouseb == whenstop)) stopmouse = 1;
    else if (jtp_mouseb > 0) stopmouse = 1;
  }
  while ((!stopmouse) && (!jtp_kbhit()));

  /* Erase leftover tooltip from screen (keep mouse cursor to avoid flicker) */
  if (ttip_bg)
    jtp_refresh_region(ttip_x, ttip_y,
                       ttip_x + ttip_bg[2]*256 + ttip_bg[3],
                       ttip_y + ttip_bg[0]*256 + ttip_bg[1], &jtp_screen);
  free(ttip_bg);
  free(tooltip);
}


static void jtp_get_mouse_appearance(
  jtp_mouse_cursor ** m_cursor,
  unsigned char ** tooltip,
  int * hotspot,
  jtp_hotspot ** hotspots,
  int n_hotspots
)
{
  int i;

  for (i = 0; i < n_hotspots; i++)
  {
    if ((jtp_mousex >= (hotspots[i])->x1) && (jtp_mousex <= (hotspots[i])->x2) &&
        (jtp_mousey >= (hotspots[i])->y1) && (jtp_mousey <= (hotspots[i])->y2))
    {
      *hotspot = i;
      *m_cursor = (hotspots[i])->mcursor;
      *tooltip = (hotspots[i])->tooltip;
      return;
    }
  }
  *m_cursor = jtp_mcursor[JTP_CURSOR_NORMAL];
  *tooltip = NULL;
  *hotspot = -1;
}


static int jtp_get_mouse_inventory_input(
  jtp_mouse_cursor * m_cursor,
  jtp_hotspot ** hotspots,
  int n_hotspots,
  int whenstop
)
{
  int        hotspot = -1;
  int        old_hotspot = -1;

  unsigned char *m_bg = NULL;
  jtp_mouse_cursor *m_old_cursor = m_cursor;

  int        ttip_x = -1, ttip_y = -1;
  int        ttip_old_x = -1, ttip_old_y = -1;
  unsigned char *tooltip = NULL;
  unsigned char *ttip_bg = NULL;
  unsigned char *ttip_old_bg = NULL;


  char        forcedraw = 1;
  char        stopmouse = 0;

  jtp_readmouse();

  do
  {
    /* 
       At this point the pointer status is:
       tooptip:     not NULL, may change on mouse movement
       ttip_bg:     not NULL, changes on mouse movement
       ttip_old_bg: NULL
       m_bg:        NULL
    */
  
    if ((jtp_oldmx!=jtp_mousex) || (jtp_oldmy!=jtp_mousey) || forcedraw)
    {
      /* Find a mouse cursor and tooltip for the current location */
      m_old_cursor = m_cursor; /* Necessary to get correct refresh area */
      ttip_old_bg = ttip_bg;
      ttip_old_x = ttip_x;
      ttip_old_y = ttip_y;

      old_hotspot = hotspot;
      jtp_get_mouse_appearance(&m_cursor, &tooltip, &hotspot, hotspots, n_hotspots);
      /* DEBUG */ if (!m_cursor) m_cursor = jtp_mcursor[JTP_CURSOR_NORMAL]; /* DEBUG */

      /* Store the background of the new cursor */
      m_bg = jtp_get_img(jtp_mousex+m_cursor->xmod,jtp_mousey+m_cursor->ymod,
                         jtp_mousex+m_cursor->xmod+m_cursor->graphic[3],
                         jtp_mousey+m_cursor->ymod+m_cursor->graphic[1]);

      /* Store the background of the new tooltip */
      if (hotspot != old_hotspot)
        jtp_tooltip_location(jtp_mousex, jtp_mousey, m_cursor, &ttip_x, &ttip_y, tooltip);
      if (tooltip)
      {
        ttip_bg = jtp_get_img(ttip_x, ttip_y, 
                              ttip_x + tooltip[2]*256 + tooltip[3] - 1, 
                              ttip_y + tooltip[0]*256 + tooltip[1] - 1);
      }
      else ttip_bg = NULL;

      /* Draw mouse cursor and tooltip */
      jtp_put_img(ttip_x, ttip_y, tooltip);
      jtp_put_stencil(jtp_mousex+m_cursor->xmod, jtp_mousey+m_cursor->ymod, m_cursor->graphic);
 
      if (forcedraw)
      {
        /* Refresh the entire screen */
        jtp_refresh(&jtp_screen);
        forcedraw = 0;
      }
      else
      {
        /* Refresh old and new areas of mouse cursor */
        jtp_refresh_region(jtp_mousex + m_cursor->xmod, jtp_mousey + m_cursor->ymod,
                jtp_mousex + m_cursor->xmod + m_cursor->graphic[3] - 1, 
                jtp_mousey + m_cursor->ymod + m_cursor->graphic[1] - 1, &jtp_screen);
        jtp_refresh_region(jtp_oldmx + m_old_cursor->xmod, jtp_oldmy + m_old_cursor->ymod,
                jtp_oldmx + m_old_cursor->xmod + m_old_cursor->graphic[3] - 1, 
                jtp_oldmy + m_old_cursor->ymod + m_old_cursor->graphic[1] - 1, &jtp_screen);
 
        /* Refresh old and new areas of tooltip */
        if (ttip_bg)
          jtp_refresh_region(ttip_x, ttip_y,
                  ttip_x + ttip_bg[2]*256 + ttip_bg[3] - 1, 
                  ttip_y + ttip_bg[0]*256 + ttip_bg[1] - 1, &jtp_screen);
        if (ttip_old_bg)
          jtp_refresh_region(ttip_old_x, ttip_old_y,
                  ttip_old_x + ttip_old_bg[2]*256 + ttip_old_bg[3] - 1, 
                  ttip_old_y + ttip_old_bg[0]*256 + ttip_old_bg[1] - 1, &jtp_screen);
      }

      /* Restore mouse background */
      jtp_put_img(jtp_mousex + m_cursor->xmod, jtp_mousey + m_cursor->ymod, m_bg);
 
      /* Restore tooltip background */
      if (ttip_bg) jtp_put_img(ttip_x, ttip_y, ttip_bg);

      /* Now that we've used them in a screen refresh, the old backgrounds can be freed */
      free(ttip_old_bg); ttip_old_bg = NULL;
      free(m_bg); m_bg = NULL;
    }
    jtp_get_event();
    jtp_readmouse();
    if ((whenstop >= 0) && (jtp_mouseb == whenstop)) stopmouse = 1;
    else if (jtp_mouseb > 0) stopmouse = 1;
  }
  while ((!stopmouse) && (!jtp_kbhit()));

  /* Erase leftover tooltip from screen (keep mouse cursor to avoid flicker) */
  if (ttip_bg)
    jtp_refresh_region(ttip_x, ttip_y,
                       ttip_x + ttip_bg[2]*256 + ttip_bg[3],
                       ttip_y + ttip_bg[0]*256 + ttip_bg[1], &jtp_screen);
  free(ttip_bg);
  return(hotspot);
}




void jtp_get_map_input(void)
{
  /* 
   * Remove any key presses in the key buffer (this is a design choice:
   * since the response isn't instantaneous, buffered keys usually result
   * in unwanted movement. This could be made into an option.
   */
  jtp_sdl_keybuf_reset();

  jtp_get_mouse_input(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_LEFT);
}

static void jtp_init_monster_tile_table(void)
{
  int i, k;
  int * monclasstiles;

  jtp_montiles = (int *)malloc(NUMMONS*sizeof(int));
  monclasstiles = (int *)malloc(MAXMCLASSES*sizeof(int));
  if ((!jtp_montiles) || (!monclasstiles))
  {
    OOM(1);
  }

  /* Initialize class default tiles */
  for (i = 0; i < MAXMCLASSES; i++)
    monclasstiles[i] = JTP_TILE_KNIGHT;
  monclasstiles[S_DOG] = JTP_TILE_WOLF;
  monclasstiles[S_FELINE] = JTP_TILE_LARGE_CAT;
  monclasstiles[S_BLOB] = JTP_TILE_GREEN_SLIME;
  monclasstiles[S_JELLY] = JTP_TILE_GREEN_SLIME;
  monclasstiles[S_PUDDING] = JTP_TILE_GREEN_SLIME;
  monclasstiles[S_FUNGUS] = JTP_TILE_YELLOW_MOLD;
  monclasstiles[S_SNAKE] = JTP_TILE_WATER_MOCCASIN;
  monclasstiles[S_LIZARD] = JTP_TILE_LIZARD;
  monclasstiles[S_SPIDER] = JTP_TILE_SPIDER;
  monclasstiles[S_XAN] = JTP_TILE_XAN;
  monclasstiles[S_RUSTMONST] = JTP_TILE_RUST_MONSTER;
  monclasstiles[S_KOBOLD] = JTP_TILE_KOBOLD;
  monclasstiles[S_GREMLIN] = JTP_TILE_GREMLIN;
  monclasstiles[S_HUMANOID] = JTP_TILE_GOBLIN;
  monclasstiles[S_EYE] = JTP_TILE_EYE;
  monclasstiles[S_COCKATRICE] = JTP_TILE_EYE;
  monclasstiles[S_JABBERWOCK] = JTP_TILE_EYE;
  monclasstiles[S_GNOME] = JTP_TILE_GNOME;
  monclasstiles[S_LEPRECHAUN] = JTP_TILE_GNOME;
  monclasstiles[S_ELEMENTAL] = JTP_TILE_FIRE_ELEMENTAL;
  monclasstiles[S_OGRE] = JTP_TILE_OGRE;
  monclasstiles[S_GIANT] = JTP_TILE_GIANT;
  monclasstiles[S_NAGA] = JTP_TILE_GUARDIAN_NAGA;
  monclasstiles[S_DRAGON] = JTP_TILE_BLACK_DRAGON;
  monclasstiles[S_WRAITH] = JTP_TILE_WRAITH;
  monclasstiles[S_GHOST] = JTP_TILE_GHOST;
  monclasstiles[S_ZOMBIE] = JTP_TILE_HUMAN_ZOMBIE;
  monclasstiles[S_GOLEM] = JTP_TILE_STONE_GOLEM;
  monclasstiles[S_RODENT] = JTP_TILE_RAT;
  monclasstiles[S_TROLL] = JTP_TILE_TROLL;
  monclasstiles[S_BAT] = JTP_TILE_GIANT_BAT;
  monclasstiles[S_QUADRUPED] = JTP_TILE_ROTHE;
  monclasstiles[S_UNICORN] = JTP_TILE_GRAY_UNICORN;
  monclasstiles[S_CENTAUR] = JTP_TILE_MOUNTAIN_CENTAUR;
  monclasstiles[S_ANT] = JTP_TILE_SOLDIER_ANT;
  monclasstiles[S_MIMIC] = JTP_TILE_LARGE_MIMIC;

  /* Assign class based monster tiles first */
  for (i = 0; i < NUMMONS; i++)
  {
    /* If the class is recognizable, use that */
    k = (int)mons[i].mlet;
    if ((k >= 0) && (k < MAXMCLASSES))
      jtp_montiles[i] = monclasstiles[k];
    else jtp_montiles[i] = JTP_TILE_KNIGHT;
  }

  /* Adjust for individual monster types and exceptions */
  jtp_montiles[PM_HOBBIT] = JTP_TILE_HOBBIT;
  jtp_montiles[PM_DWARF] = JTP_TILE_DWARF;
  jtp_montiles[PM_DWARF_LORD] = JTP_TILE_DWARF_LORD;
  jtp_montiles[PM_DWARF_KING] = JTP_TILE_DWARF_KING;
  jtp_montiles[PM_GNOME] = JTP_TILE_GNOME;
  jtp_montiles[PM_GNOME_LORD] = JTP_TILE_GNOME_LORD;
  jtp_montiles[PM_GNOME_KING] = JTP_TILE_GNOME_KING;
  jtp_montiles[PM_GNOMISH_WIZARD] = JTP_TILE_GNOMISH_WIZARD;
  jtp_montiles[PM_ELF] = JTP_TILE_ELF;
  jtp_montiles[PM_WOODLAND_ELF] = JTP_TILE_WOODLAND_ELF;
  jtp_montiles[PM_GREEN_ELF] = JTP_TILE_GREEN_ELF;
  jtp_montiles[PM_GREY_ELF] = JTP_TILE_GREY_ELF;
  jtp_montiles[PM_ELF_LORD] = JTP_TILE_ELF_LORD;
  jtp_montiles[PM_ELVENKING] = JTP_TILE_ELVENKING;
  jtp_montiles[PM_BUGBEAR] = JTP_TILE_BUGBEAR;
  jtp_montiles[PM_GOBLIN] = JTP_TILE_GOBLIN;
  jtp_montiles[PM_HOBGOBLIN] = JTP_TILE_HOBGOBLIN;
  jtp_montiles[PM_ORC] = JTP_TILE_ORC;
  jtp_montiles[PM_HILL_ORC] = JTP_TILE_HILL_ORC;
  jtp_montiles[PM_MORDOR_ORC] = JTP_TILE_MORDOR_ORC;
  jtp_montiles[PM_URUK_HAI] = JTP_TILE_URUK_HAI;
  jtp_montiles[PM_ORC_SHAMAN] = JTP_TILE_URUK_HAI;
  jtp_montiles[PM_ORC_CAPTAIN] = JTP_TILE_URUK_HAI;
  jtp_montiles[PM_KNIGHT] = JTP_TILE_KNIGHT;
  jtp_montiles[PM_SAMURAI] = JTP_TILE_KNIGHT;
  jtp_montiles[PM_MONK] = JTP_TILE_WIZARD;
  jtp_montiles[PM_HEALER] = JTP_TILE_PRIEST;
  jtp_montiles[PM_PRIEST] = JTP_TILE_PRIEST;
  jtp_montiles[PM_PRIESTESS] = JTP_TILE_PRIEST;
  jtp_montiles[PM_WIZARD] = JTP_TILE_WIZARD;
  jtp_montiles[PM_VALKYRIE] = JTP_TILE_VALKYRIE;
  jtp_montiles[PM_RANGER] = JTP_TILE_RANGER;
  jtp_montiles[PM_ROGUE] = JTP_TILE_ROGUE;
  jtp_montiles[PM_ARCHEOLOGIST] = JTP_TILE_ARCHEOLOGIST;
  jtp_montiles[PM_WOOD_NYMPH] = JTP_TILE_NYMPH;
  jtp_montiles[PM_WATER_NYMPH] = JTP_TILE_WATER_NYMPH;
  jtp_montiles[PM_MOUNTAIN_NYMPH] = JTP_TILE_NYMPH;
  jtp_montiles[PM_SUCCUBUS] = JTP_TILE_SUCCUBUS;
  jtp_montiles[PM_SKELETON] = JTP_TILE_SKELETON;
  jtp_montiles[PM_KILLER_BEE] = JTP_TILE_BEE;
  jtp_montiles[PM_QUEEN_BEE] = JTP_TILE_BEE;
  jtp_montiles[PM_TOURIST] = JTP_TILE_TOURIST;
  jtp_montiles[PM_YELLOW_LIGHT] = JTP_TILE_YELLOW_LIGHT;
  jtp_montiles[PM_BLACK_LIGHT] = JTP_TILE_BLACK_LIGHT;
  jtp_montiles[PM_YELLOW_MOLD] = JTP_TILE_YELLOW_MOLD;
  jtp_montiles[PM_RED_MOLD] = JTP_TILE_RED_MOLD;
  jtp_montiles[PM_VIOLET_FUNGUS] = JTP_TILE_VIOLET_FUNGUS;
  jtp_montiles[PM_BROWN_MOLD] = JTP_TILE_BROWN_MOLD;
  jtp_montiles[PM_SHRIEKER] = JTP_TILE_SHRIEKER;
  jtp_montiles[PM_COCKATRICE] = JTP_TILE_COCKATRICE;
  jtp_montiles[PM_KRAKEN] = JTP_TILE_KRAKEN;
  jtp_montiles[PM_GIANT_EEL] = JTP_TILE_GIANT_EEL;
  jtp_montiles[PM_SHARK] = JTP_TILE_SHARK;
  jtp_montiles[PM_ACID_BLOB] = JTP_TILE_ACID_BLOB;
  jtp_montiles[PM_QUIVERING_BLOB] = JTP_TILE_QUIVERING_BLOB;
  jtp_montiles[PM_GELATINOUS_CUBE] = JTP_TILE_GELATINOUS_CUBE;
  jtp_montiles[PM_LICHEN] = JTP_TILE_LICHEN;
  jtp_montiles[PM_GREEN_MOLD] = JTP_TILE_GREEN_MOLD;
  jtp_montiles[PM_STALKER] = JTP_TILE_STALKER;
  jtp_montiles[PM_AIR_ELEMENTAL] = JTP_TILE_AIR_ELEMENTAL;
  jtp_montiles[PM_EARTH_ELEMENTAL] = JTP_TILE_EARTH_ELEMENTAL;
  jtp_montiles[PM_WATER_ELEMENTAL] = JTP_TILE_WATER_ELEMENTAL;
  jtp_montiles[PM_CHICKATRICE] = JTP_TILE_CHICKATRICE;
  jtp_montiles[PM_PYROLISK] = JTP_TILE_PYROLISK;
  jtp_montiles[PM_SMALL_MIMIC] = JTP_TILE_SMALL_MIMIC;
  jtp_montiles[PM_LARGE_MIMIC] = JTP_TILE_LARGE_MIMIC;
  jtp_montiles[PM_GIANT_MIMIC] = JTP_TILE_GIANT_MIMIC;
  jtp_montiles[PM_FOX] = JTP_TILE_FOX;
  jtp_montiles[PM_COYOTE] = JTP_TILE_COYOTE;
  jtp_montiles[PM_JACKAL] = JTP_TILE_JACKAL;
  jtp_montiles[PM_LITTLE_DOG] = JTP_TILE_LITTLE_DOG;
  jtp_montiles[PM_DOG] = JTP_TILE_DOG;
  jtp_montiles[PM_LARGE_DOG] = JTP_TILE_LARGE_DOG;
  jtp_montiles[PM_ROCK_PIERCER] = JTP_TILE_ROCK_PIERCER;
  jtp_montiles[PM_IRON_PIERCER] = JTP_TILE_IRON_PIERCER;
  jtp_montiles[PM_GLASS_PIERCER] = JTP_TILE_GLASS_PIERCER;
  jtp_montiles[PM_KITTEN] = JTP_TILE_KITTEN;
  jtp_montiles[PM_WATER_DEMON] = JTP_TILE_WATER_DEMON;
  jtp_montiles[PM_GECKO] = JTP_TILE_GECKO;
  jtp_montiles[PM_NEWT] = JTP_TILE_NEWT;
  jtp_montiles[PM_SHOPKEEPER] = JTP_TILE_SHOPKEEPER;
  jtp_montiles[PM_GAS_SPORE] = JTP_TILE_GAS_SPORE;
  jtp_montiles[PM_HOUSECAT] = JTP_TILE_HOUSECAT;
  jtp_montiles[PM_LARGE_CAT] = JTP_TILE_LARGE_CAT;
  jtp_montiles[PM_FREEZING_SPHERE] = JTP_TILE_FREEZING_SPHERE;
  jtp_montiles[PM_FLAMING_SPHERE] = JTP_TILE_FLAMING_SPHERE;
  jtp_montiles[PM_SHOCKING_SPHERE] = JTP_TILE_SHOCKING_SPHERE;
  jtp_montiles[PM_PONY] = JTP_TILE_PONY;
  jtp_montiles[PM_HORSE] = JTP_TILE_HORSE;
  jtp_montiles[PM_WARHORSE] = JTP_TILE_WARHORSE;
  jtp_montiles[PM_ROTHE] = JTP_TILE_ROTHE;
  jtp_montiles[PM_WATER_MOCCASIN] = JTP_TILE_WATER_MOCCASIN;
  jtp_montiles[PM_MANES] = JTP_TILE_MANES;
  jtp_montiles[PM_BLACK_UNICORN] = JTP_TILE_BLACK_UNICORN;
  jtp_montiles[PM_GRAY_UNICORN] = JTP_TILE_GRAY_UNICORN;
  jtp_montiles[PM_WHITE_UNICORN] = JTP_TILE_WHITE_UNICORN;
  jtp_montiles[PM_GIANT_ANT] = JTP_TILE_GIANT_ANT;
  jtp_montiles[PM_SOLDIER_ANT] = JTP_TILE_SOLDIER_ANT;
  jtp_montiles[PM_FIRE_ANT] = JTP_TILE_FIRE_ANT;
  jtp_montiles[PM_ROCK_MOLE] = JTP_TILE_ROCK_MOLE;
  jtp_montiles[PM_KOBOLD] = JTP_TILE_KOBOLD;
  jtp_montiles[PM_LARGE_KOBOLD] = JTP_TILE_LARGE_KOBOLD;
  jtp_montiles[PM_KOBOLD_LORD] = JTP_TILE_KOBOLD_LORD;
  jtp_montiles[PM_KOBOLD_SHAMAN] = JTP_TILE_KOBOLD_SHAMAN;
  jtp_montiles[PM_ORC_CAPTAIN] = JTP_TILE_ORC_CAPTAIN;
  jtp_montiles[PM_ORC_SHAMAN] = JTP_TILE_ORC_SHAMAN;
  jtp_montiles[PM_LEPRECHAUN] = JTP_TILE_LEPRECHAUN;
  jtp_montiles[PM_GARTER_SNAKE] = JTP_TILE_GARTER_SNAKE;
  jtp_montiles[PM_SNAKE] = JTP_TILE_SNAKE;
  jtp_montiles[PM_PIT_VIPER] = JTP_TILE_PIT_VIPER;
  jtp_montiles[PM_PYTHON] = JTP_TILE_PYTHON;
  jtp_montiles[PM_COBRA] = JTP_TILE_COBRA;
  jtp_montiles[PM_GIANT] = JTP_TILE_GIANT;
  jtp_montiles[PM_ETTIN] = JTP_TILE_ETTIN;
  jtp_montiles[PM_KOBOLD_ZOMBIE] = JTP_TILE_KOBOLD_ZOMBIE;
  jtp_montiles[PM_GNOME_ZOMBIE] = JTP_TILE_GNOME_ZOMBIE;
  jtp_montiles[PM_DWARF_ZOMBIE] = JTP_TILE_DWARF_ZOMBIE;
  jtp_montiles[PM_ORC_ZOMBIE] = JTP_TILE_ORC_ZOMBIE;
  jtp_montiles[PM_ELF_ZOMBIE] = JTP_TILE_ELF_ZOMBIE;
  jtp_montiles[PM_GIANT_ZOMBIE] = JTP_TILE_GIANT_ZOMBIE;
  jtp_montiles[PM_ETTIN_ZOMBIE] = JTP_TILE_ETTIN_ZOMBIE;
  jtp_montiles[PM_KOBOLD_MUMMY] = JTP_TILE_KOBOLD_MUMMY;
  jtp_montiles[PM_GNOME_MUMMY] = JTP_TILE_GNOME_MUMMY;
  jtp_montiles[PM_DWARF_MUMMY] = JTP_TILE_DWARF_MUMMY;
  jtp_montiles[PM_ORC_MUMMY] = JTP_TILE_ORC_MUMMY;
  jtp_montiles[PM_HUMAN_MUMMY] = JTP_TILE_HUMAN_MUMMY;
  jtp_montiles[PM_ELF_MUMMY] = JTP_TILE_ELF_MUMMY;
  jtp_montiles[PM_GIANT_MUMMY] = JTP_TILE_GIANT_MUMMY;
  jtp_montiles[PM_ETTIN_MUMMY] = JTP_TILE_ETTIN_MUMMY;
  jtp_montiles[PM_HOMUNCULUS] = JTP_TILE_HOMUNCULUS;
  jtp_montiles[PM_IMP] = JTP_TILE_IMP;
  jtp_montiles[PM_LEMURE] = JTP_TILE_LEMURE;
  jtp_montiles[PM_QUASIT] = JTP_TILE_QUASIT;
  jtp_montiles[PM_TENGU] = JTP_TILE_TENGU;
  jtp_montiles[PM_WUMPUS] = JTP_TILE_WUMPUS;
  jtp_montiles[PM_ORACLE] = JTP_TILE_ORACLE;
  jtp_montiles[PM_ALIGNED_PRIEST] = JTP_TILE_NEUTRAL_PRIEST;
  jtp_montiles[PM_WATCHMAN] = JTP_TILE_WATCHMAN;
  jtp_montiles[PM_WATCH_CAPTAIN] = JTP_TILE_WATCH_CAPTAIN;
  jtp_montiles[PM_SOLDIER] = JTP_TILE_SOLDIER;
  jtp_montiles[PM_SERGEANT] = JTP_TILE_SERGEANT;
  jtp_montiles[PM_LIEUTENANT] = JTP_TILE_LIEUTENANT;
  jtp_montiles[PM_CAPTAIN] = JTP_TILE_CAPTAIN;
  jtp_montiles[PM_GRID_BUG] = JTP_TILE_GRID_BUG;
  jtp_montiles[PM_XAN] = JTP_TILE_XAN;
  jtp_montiles[PM_GARGOYLE] = JTP_TILE_GARGOYLE;
  jtp_montiles[PM_WINGED_GARGOYLE] = JTP_TILE_WINGED_GARGOYLE;
  jtp_montiles[PM_DINGO] = JTP_TILE_DINGO;
  jtp_montiles[PM_WOLF] = JTP_TILE_WOLF;
  jtp_montiles[PM_WEREWOLF] = JTP_TILE_WEREWOLF;
  jtp_montiles[PM_WARG] = JTP_TILE_WARG;
  jtp_montiles[PM_WINTER_WOLF_CUB] = JTP_TILE_WINTER_WOLF_CUB;
  jtp_montiles[PM_WINTER_WOLF] = JTP_TILE_WINTER_WOLF;
  jtp_montiles[PM_HELL_HOUND_PUP] = JTP_TILE_HELL_HOUND_PUP;
  jtp_montiles[PM_HELL_HOUND] = JTP_TILE_HELL_HOUND;
  jtp_montiles[PM_JAGUAR] = JTP_TILE_JAGUAR;
  jtp_montiles[PM_LYNX] = JTP_TILE_LYNX;
  jtp_montiles[PM_PANTHER] = JTP_TILE_PANTHER;
  jtp_montiles[PM_TIGER] = JTP_TILE_TIGER;
  jtp_montiles[PM_MIND_FLAYER] = JTP_TILE_MIND_FLAYER;
  jtp_montiles[PM_MASTER_MIND_FLAYER] = JTP_TILE_MASTER_MIND_FLAYER;
  jtp_montiles[PM_LICH] = JTP_TILE_LICH;
  jtp_montiles[PM_DEMILICH] = JTP_TILE_DEMILICH;
  jtp_montiles[PM_MASTER_LICH] = JTP_TILE_MASTER_LICH;
  jtp_montiles[PM_ARCH_LICH] = JTP_TILE_ARCH_LICH;
  jtp_montiles[PM_SUCCUBUS] = JTP_TILE_SUCCUBUS;
  jtp_montiles[PM_INCUBUS] = JTP_TILE_INCUBUS;
  jtp_montiles[PM_GUARDIAN_NAGA] = JTP_TILE_GUARDIAN_NAGA;
  jtp_montiles[PM_GUARDIAN_NAGA_HATCHLING] = JTP_TILE_GUARDIAN_NAGA_HATCHLING;
  jtp_montiles[PM_GOLDEN_NAGA] = JTP_TILE_GOLDEN_NAGA;
  jtp_montiles[PM_GOLDEN_NAGA_HATCHLING] = JTP_TILE_GOLDEN_NAGA_HATCHLING;
  jtp_montiles[PM_RED_NAGA] = JTP_TILE_RED_NAGA;
  jtp_montiles[PM_RED_NAGA_HATCHLING] = JTP_TILE_RED_NAGA_HATCHLING;
  jtp_montiles[PM_BLACK_NAGA] = JTP_TILE_BLACK_NAGA;
  jtp_montiles[PM_BLACK_NAGA_HATCHLING] = JTP_TILE_BLACK_NAGA_HATCHLING;
  jtp_montiles[PM_STONE_GIANT] = JTP_TILE_STONE_GIANT;
  jtp_montiles[PM_HILL_GIANT] = JTP_TILE_HILL_GIANT;
  jtp_montiles[PM_FROST_GIANT] = JTP_TILE_FROST_GIANT;
  jtp_montiles[PM_FIRE_GIANT] = JTP_TILE_FIRE_GIANT;
  jtp_montiles[PM_STORM_GIANT] = JTP_TILE_STORM_GIANT;
  jtp_montiles[PM_TITAN] = JTP_TILE_TITAN;
  jtp_montiles[PM_MINOTAUR] = JTP_TILE_MINOTAUR;
  jtp_montiles[PM_OGRE] = JTP_TILE_OGRE;
  jtp_montiles[PM_OGRE_LORD] = JTP_TILE_OGRE_LORD;
  jtp_montiles[PM_OGRE_KING] = JTP_TILE_OGRE_KING;
  jtp_montiles[PM_RED_DRAGON] = JTP_TILE_RED_DRAGON;
  jtp_montiles[PM_BABY_RED_DRAGON] = JTP_TILE_BABY_RED_DRAGON;
  jtp_montiles[PM_GREEN_DRAGON] = JTP_TILE_GREEN_DRAGON;
  jtp_montiles[PM_BABY_GREEN_DRAGON] = JTP_TILE_BABY_GREEN_DRAGON;
  jtp_montiles[PM_ORANGE_DRAGON] = JTP_TILE_ORANGE_DRAGON;
  jtp_montiles[PM_BABY_ORANGE_DRAGON] = JTP_TILE_BABY_ORANGE_DRAGON;
  jtp_montiles[PM_YELLOW_DRAGON] = JTP_TILE_YELLOW_DRAGON;
  jtp_montiles[PM_BABY_YELLOW_DRAGON] = JTP_TILE_BABY_YELLOW_DRAGON;
  jtp_montiles[PM_BLUE_DRAGON] = JTP_TILE_BLUE_DRAGON;
  jtp_montiles[PM_BABY_BLUE_DRAGON] = JTP_TILE_BABY_BLUE_DRAGON;
  jtp_montiles[PM_GRAY_DRAGON] = JTP_TILE_GRAY_DRAGON;
  jtp_montiles[PM_BABY_GRAY_DRAGON] = JTP_TILE_BABY_GRAY_DRAGON;
  jtp_montiles[PM_SILVER_DRAGON] = JTP_TILE_SILVER_DRAGON;
  jtp_montiles[PM_BABY_SILVER_DRAGON] = JTP_TILE_BABY_SILVER_DRAGON;
  jtp_montiles[PM_BLACK_DRAGON] = JTP_TILE_BLACK_DRAGON;
  jtp_montiles[PM_BABY_BLACK_DRAGON] = JTP_TILE_BABY_BLACK_DRAGON;
  jtp_montiles[PM_WHITE_DRAGON] = JTP_TILE_WHITE_DRAGON;
  jtp_montiles[PM_BABY_WHITE_DRAGON] = JTP_TILE_BABY_WHITE_DRAGON;
  jtp_montiles[PM_GREMLIN] = JTP_TILE_GREMLIN;
  jtp_montiles[PM_RUST_MONSTER] = JTP_TILE_RUST_MONSTER;
  jtp_montiles[PM_DISENCHANTER] = JTP_TILE_DISENCHANTER;
  jtp_montiles[PM_BABY_PURPLE_WORM] = JTP_TILE_BABY_PURPLE_WORM;
  jtp_montiles[PM_PURPLE_WORM] = JTP_TILE_PURPLE_WORM;
  jtp_montiles[PM_BABY_LONG_WORM] = JTP_TILE_BABY_LONG_WORM;
  jtp_montiles[PM_LONG_WORM] = JTP_TILE_LONG_WORM;
  jtp_montiles[PM_LONG_WORM_TAIL] = JTP_TILE_LONG_WORM_TAIL;
  jtp_montiles[PM_MONKEY] = JTP_TILE_MONKEY;
  jtp_montiles[PM_APE] = JTP_TILE_APE;
  jtp_montiles[PM_OWLBEAR] = JTP_TILE_OWLBEAR;
  jtp_montiles[PM_YETI] = JTP_TILE_YETI;
  jtp_montiles[PM_CARNIVOROUS_APE] = JTP_TILE_CARNIVOROUS_APE;
  jtp_montiles[PM_SASQUATCH] = JTP_TILE_SASQUATCH;
  jtp_montiles[PM_MUMAK] = JTP_TILE_MUMAK;
  jtp_montiles[PM_LEOCROTTA] = JTP_TILE_LEOCROTTA;
  jtp_montiles[PM_TITANOTHERE] = JTP_TILE_TITANOTHERE;
  jtp_montiles[PM_BALUCHITHERIUM] = JTP_TILE_BALUCHITHERIUM;
  jtp_montiles[PM_MASTODON] = JTP_TILE_MASTADON;
  jtp_montiles[PM_ZRUTY] = JTP_TILE_ZRUTY;
  jtp_montiles[PM_WIZARD_OF_YENDOR] = JTP_TILE_WIZARD_OF_YENDOR;
  jtp_montiles[PM_XORN] = JTP_TILE_XORN;
  jtp_montiles[PM_STRAW_GOLEM] = JTP_TILE_STRAW_GOLEM;
  jtp_montiles[PM_PAPER_GOLEM] = JTP_TILE_PAPER_GOLEM;
  jtp_montiles[PM_ROPE_GOLEM] = JTP_TILE_ROPE_GOLEM;
  jtp_montiles[PM_GOLD_GOLEM] = JTP_TILE_GOLD_GOLEM;
  jtp_montiles[PM_LEATHER_GOLEM] = JTP_TILE_LEATHER_GOLEM;
  jtp_montiles[PM_WOOD_GOLEM] = JTP_TILE_WOOD_GOLEM;
  jtp_montiles[PM_FLESH_GOLEM] = JTP_TILE_FLESH_GOLEM;
  jtp_montiles[PM_CLAY_GOLEM] = JTP_TILE_CLAY_GOLEM;
  jtp_montiles[PM_STONE_GOLEM] = JTP_TILE_STONE_GOLEM;
  jtp_montiles[PM_GLASS_GOLEM] = JTP_TILE_GLASS_GOLEM;
  jtp_montiles[PM_IRON_GOLEM] = JTP_TILE_IRON_GOLEM;

  /* Clean up */
  free(monclasstiles);
}


static void jtp_init_object_tile_table(void)
{
  int i, k;
  int * objclasstiles;
  const char * temp_descr;

  jtp_objtiles = (int *)malloc(NUM_OBJECTS*sizeof(int));
  objclasstiles = (int *)malloc(MAXOCLASSES*sizeof(int));
  if ((!jtp_objtiles) || (!objclasstiles))
  {
    OOM(1);
  }

  /* Initialize class default tiles */
#ifdef SANITY_CHECKS
  for (i = 0; i < MAXOCLASSES; i++)
    objclasstiles[i] = JTP_TILE_INVALID;
#else
  for (i = 0; i < MAXOCLASSES; i++)
    objclasstiles[i] = JTP_TILE_DEFAULT_OBJECT;
#endif
  objclasstiles[ROCK_CLASS] = JTP_TILE_BOULDER;
  objclasstiles[COIN_CLASS] = JTP_TILE_COINS;
  objclasstiles[SPBOOK_CLASS] = JTP_TILE_BOOK;
  objclasstiles[SCROLL_CLASS] = JTP_TILE_SCROLL;
  objclasstiles[POTION_CLASS] = JTP_TILE_WATER;
  objclasstiles[WEAPON_CLASS] = JTP_TILE_SPEAR;
  objclasstiles[ARMOR_CLASS] = JTP_TILE_HELMET;
  objclasstiles[WAND_CLASS] = JTP_TILE_WAND;
  objclasstiles[GEM_CLASS] = JTP_TILE_BLUE_GLASS;
  objclasstiles[RING_CLASS] = JTP_TILE_RING;
  objclasstiles[AMULET_CLASS] = JTP_TILE_AMULET;
  objclasstiles[FOOD_CLASS] = JTP_TILE_FOOD_RATION;

#ifdef SANITY_CHECKS
  /* start with 1, because 0 is random class */
  for (i = 1; i < MAXOCLASSES; i++)
  {
    if (objclasstiles[i] == JTP_TILE_INVALID)
    {
      objclasstiles[i] = JTP_TILE_DEFAULT_OBJECT;
      fprintf(stderr, "object class %d (%c) has no tile assigned\n",
        i,
        def_oc_syms[i]);
    }
  }
  /*
   * current reports:
   * 1 (ILLOBJS_CLASS)
   * 6 (TOOL_CLASS)
   * 15 (BALL_CLASS)
   * 16 (CHAIN_CLASS)
   * 17 (VENOM_CLASS)
   */
#endif

  /* Assign class based object tiles first */
  for (i = 0; i < NUM_OBJECTS; i++)
  {
    /* If the object class is recognizable, use that */
    k = objects[i].oc_class;
    if (k >= 0 && k < MAXOCLASSES)
      jtp_objtiles[i] = objclasstiles[k];
    else
#ifdef SANITY_CHECKS
      jtp_objtiles[i] = JTP_TILE_INVALID;
#else
      jtp_objtiles[i] = JTP_TILE_DEFAULT_OBJECT;
#endif
  }

  /* Assign gems by color */
  for (i = 0; i < NUM_OBJECTS; i++)
  {
    if (objects[i].oc_class == GEM_CLASS)
    {
      temp_descr = OBJ_NAME(objects[i]);
      if (temp_descr)
      {
        if (strstr(temp_descr, "red")) jtp_objtiles[i] = JTP_TILE_RED_GLASS;
        else if (strstr(temp_descr, "orange")) jtp_objtiles[i] = JTP_TILE_ORANGE_GLASS;
        else if (strstr(temp_descr, "yellowish brown")) jtp_objtiles[i] = JTP_TILE_BROWN_GLASS;
        else if (strstr(temp_descr, "yellow")) jtp_objtiles[i] = JTP_TILE_YELLOW_GLASS;
        else if (strstr(temp_descr, "green")) jtp_objtiles[i] = JTP_TILE_GREEN_GLASS;
        else if (strstr(temp_descr, "blue")) jtp_objtiles[i] = JTP_TILE_BLUE_GLASS;
        else if (strstr(temp_descr, "black")) jtp_objtiles[i] = JTP_TILE_BLACK_GLASS;
        else if (strstr(temp_descr, "white")) jtp_objtiles[i] = JTP_TILE_WHITE_GLASS;
        else if (strstr(temp_descr, "violet")) jtp_objtiles[i] = JTP_TILE_VIOLET_GLASS;
      }
    }
  }

  /* Assign potions by color */
  for (i = 0; i < NUM_OBJECTS; i++)
    if (objects[i].oc_class == POTION_CLASS)
    {
      temp_descr = OBJ_DESCR(objects[i]);
      if (temp_descr)
      {
        if (strstr(temp_descr, "ruby")) jtp_objtiles[i] = JTP_TILE_RUBY_POTION;
        else if (strstr(temp_descr, "pink")) jtp_objtiles[i] = JTP_TILE_PINK_POTION;
        else if (strstr(temp_descr, "orange")) jtp_objtiles[i] = JTP_TILE_ORANGE_POTION;
        else if (strstr(temp_descr, "yellow")) jtp_objtiles[i] = JTP_TILE_YELLOW_POTION;
        else if (strstr(temp_descr, "emerald")) jtp_objtiles[i] = JTP_TILE_EMERALD_POTION;
        else if (strstr(temp_descr, "dark green")) jtp_objtiles[i] = JTP_TILE_DARK_GREEN_POTION;
        else if (strstr(temp_descr, "cyan")) jtp_objtiles[i] = JTP_TILE_CYAN_POTION;
        else if (strstr(temp_descr, "sky blue")) jtp_objtiles[i] = JTP_TILE_SKY_BLUE_POTION;
        else if (strstr(temp_descr, "brilliant blue")) jtp_objtiles[i] = JTP_TILE_BRILLIANT_BLUE_POTION;
        else if (strstr(temp_descr, "magenta")) jtp_objtiles[i] = JTP_TILE_MAGENTA_POTION;
        else if (strstr(temp_descr, "purple-red")) jtp_objtiles[i] = JTP_TILE_PURPLE_RED_POTION;
        else if (strstr(temp_descr, "puce")) jtp_objtiles[i] = JTP_TILE_PUCE_POTION;
        else if (strstr(temp_descr, "milky")) jtp_objtiles[i] = JTP_TILE_MILKY_POTION;
        else if (strstr(temp_descr, "swirly")) jtp_objtiles[i] = JTP_TILE_SWIRLY_POTION;
        else if (strstr(temp_descr, "bubbly")) jtp_objtiles[i] = JTP_TILE_BUBBLY_POTION;
        else if (strstr(temp_descr, "smoky")) jtp_objtiles[i] = JTP_TILE_SMOKY_POTION;
        else if (strstr(temp_descr, "cloudy")) jtp_objtiles[i] = JTP_TILE_CLOUDY_POTION;
        else if (strstr(temp_descr, "effervescent")) jtp_objtiles[i] = JTP_TILE_EFFERVESCENT_POTION;
        else if (strstr(temp_descr, "black")) jtp_objtiles[i] = JTP_TILE_BLACK_POTION;
        else if (strstr(temp_descr, "golden")) jtp_objtiles[i] = JTP_TILE_GOLDEN_POTION;
        else if (strstr(temp_descr, "brown")) jtp_objtiles[i] = JTP_TILE_BROWN_POTION;
        else if (strstr(temp_descr, "fizzy")) jtp_objtiles[i] = JTP_TILE_FIZZY_POTION;
        else if (strstr(temp_descr, "dark")) jtp_objtiles[i] = JTP_TILE_DARK_POTION;
        else if (strstr(temp_descr, "white")) jtp_objtiles[i] = JTP_TILE_WHITE_POTION;
        else if (strstr(temp_descr, "murky")) jtp_objtiles[i] = JTP_TILE_MURKY_POTION;
        else if (strstr(temp_descr, "water")) jtp_objtiles[i] = JTP_TILE_WATER;
        else if (strstr(temp_descr, "clear potion")) jtp_objtiles[i] = JTP_TILE_WATER;
        else if (strstr(temp_descr, "holy water")) jtp_objtiles[i] = JTP_TILE_HOLY_WATER;
        else if (strstr(temp_descr, "unholy water")) jtp_objtiles[i] = JTP_TILE_UNHOLY_WATER;
      }
    }

  /* Adjust for individual object types and exceptions */
  jtp_objtiles[STATUE] = JTP_TILE_STATUE;
  jtp_objtiles[LARGE_BOX] = JTP_TILE_LARGE_BOX;
  jtp_objtiles[ICE_BOX] = JTP_TILE_ICE_BOX;
  jtp_objtiles[CHEST] = JTP_TILE_CHEST;

  jtp_objtiles[SMALL_SHIELD] = JTP_TILE_SHIELD;
  jtp_objtiles[ELVEN_SHIELD] = JTP_TILE_SHIELD;
  jtp_objtiles[URUK_HAI_SHIELD] = JTP_TILE_SHIELD;
  jtp_objtiles[ORCISH_SHIELD] = JTP_TILE_SHIELD;
  jtp_objtiles[LARGE_SHIELD] = JTP_TILE_SHIELD;
  jtp_objtiles[DWARVISH_ROUNDSHIELD] = JTP_TILE_SHIELD;
  jtp_objtiles[SHIELD_OF_REFLECTION] = JTP_TILE_SHIELD;

  jtp_objtiles[ELVEN_LEATHER_HELM] = JTP_TILE_HELMET;
  jtp_objtiles[ORCISH_HELM] = JTP_TILE_HELMET;
  jtp_objtiles[DWARVISH_IRON_HELM] = JTP_TILE_HELMET;
  jtp_objtiles[DENTED_POT] = JTP_TILE_HELMET;
  jtp_objtiles[HELMET] = JTP_TILE_HELMET;
  jtp_objtiles[HELM_OF_BRILLIANCE] = JTP_TILE_HELMET;
  jtp_objtiles[HELM_OF_OPPOSITE_ALIGNMENT] = JTP_TILE_HELMET;
  jtp_objtiles[HELM_OF_TELEPATHY] = JTP_TILE_HELMET;

  jtp_objtiles[SHORT_SWORD] = JTP_TILE_SWORD;
  jtp_objtiles[ELVEN_SHORT_SWORD] = JTP_TILE_SWORD;
  jtp_objtiles[ORCISH_SHORT_SWORD] = JTP_TILE_SWORD;
  jtp_objtiles[DWARVISH_SHORT_SWORD] = JTP_TILE_SWORD;
  jtp_objtiles[SCIMITAR] = JTP_TILE_SWORD;
  jtp_objtiles[SILVER_SABER] = JTP_TILE_SWORD;
  jtp_objtiles[BROADSWORD] = JTP_TILE_SWORD;
  jtp_objtiles[ELVEN_BROADSWORD] = JTP_TILE_SWORD;
  jtp_objtiles[LONG_SWORD] = JTP_TILE_SWORD;
  jtp_objtiles[TWO_HANDED_SWORD] = JTP_TILE_SWORD;
  jtp_objtiles[KATANA] = JTP_TILE_SWORD;
  jtp_objtiles[TSURUGI] = JTP_TILE_SWORD;
  jtp_objtiles[RUNESWORD] = JTP_TILE_SWORD;

  jtp_objtiles[SPEAR] = JTP_TILE_SPEAR;
  jtp_objtiles[ELVEN_SPEAR] = JTP_TILE_SPEAR;
  jtp_objtiles[ORCISH_SPEAR] = JTP_TILE_SPEAR;
  jtp_objtiles[DWARVISH_SPEAR] = JTP_TILE_SPEAR;
  jtp_objtiles[SILVER_SPEAR] = JTP_TILE_SPEAR;
  jtp_objtiles[JAVELIN] = JTP_TILE_SPEAR;
  jtp_objtiles[TRIDENT] = JTP_TILE_SPEAR;

  jtp_objtiles[QUARTERSTAFF] = JTP_TILE_STAFF;
  jtp_objtiles[SHURIKEN] = JTP_TILE_SHURIKEN;
  jtp_objtiles[BOOMERANG] = JTP_TILE_SHURIKEN;

  jtp_objtiles[LOW_BOOTS] = JTP_TILE_BOOTS;
  jtp_objtiles[IRON_SHOES] = JTP_TILE_BOOTS;
  jtp_objtiles[HIGH_BOOTS] = JTP_TILE_BOOTS;
  jtp_objtiles[SPEED_BOOTS] = JTP_TILE_BOOTS;
  jtp_objtiles[WATER_WALKING_BOOTS] = JTP_TILE_BOOTS;
  jtp_objtiles[JUMPING_BOOTS] = JTP_TILE_BOOTS;
  jtp_objtiles[ELVEN_BOOTS] = JTP_TILE_BOOTS;
  jtp_objtiles[KICKING_BOOTS] = JTP_TILE_BOOTS;
  jtp_objtiles[FUMBLE_BOOTS] = JTP_TILE_BOOTS;
  jtp_objtiles[LEVITATION_BOOTS] = JTP_TILE_BOOTS;

  jtp_objtiles[AXE] = JTP_TILE_AXE;
  jtp_objtiles[BATTLE_AXE] = JTP_TILE_AXE;

  jtp_objtiles[LUCERN_HAMMER] = JTP_TILE_HAMMER;
  jtp_objtiles[WAR_HAMMER] = JTP_TILE_HAMMER;

  jtp_objtiles[MACE] = JTP_TILE_MACE;
  jtp_objtiles[MORNING_STAR] = JTP_TILE_MACE;
  jtp_objtiles[FLAIL] = JTP_TILE_MACE;

  jtp_objtiles[BULLWHIP] = JTP_TILE_WHIP;

  jtp_objtiles[STUDDED_LEATHER_ARMOR] = JTP_TILE_LEATHER_ARMOR;
  jtp_objtiles[LEATHER_ARMOR] = JTP_TILE_LEATHER_ARMOR;
  jtp_objtiles[LEATHER_JACKET] = JTP_TILE_LEATHER_ARMOR;

  jtp_objtiles[GRAY_DRAGON_SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[SILVER_DRAGON_SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[RED_DRAGON_SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[WHITE_DRAGON_SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[ORANGE_DRAGON_SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[BLACK_DRAGON_SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[BLUE_DRAGON_SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[GREEN_DRAGON_SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[YELLOW_DRAGON_SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[PLATE_MAIL] = JTP_TILE_PLATE_MAIL;
  jtp_objtiles[CRYSTAL_PLATE_MAIL] = JTP_TILE_PLATE_MAIL;
  jtp_objtiles[BRONZE_PLATE_MAIL] = JTP_TILE_PLATE_MAIL;
  jtp_objtiles[SPLINT_MAIL] = JTP_TILE_PLATE_MAIL;
  jtp_objtiles[BANDED_MAIL] = JTP_TILE_PLATE_MAIL;
  jtp_objtiles[DWARVISH_MITHRIL_COAT] = JTP_TILE_CHAIN_MAIL;
#ifdef DARK_ELVEN_MITHRIL_COAT
  jtp_objtiles[DARK_ELVEN_MITHRIL_COAT] = JTP_TILE_CHAIN_MAIL;
#endif
  jtp_objtiles[ELVEN_MITHRIL_COAT] = JTP_TILE_CHAIN_MAIL;
  jtp_objtiles[CHAIN_MAIL] = JTP_TILE_CHAIN_MAIL;
  jtp_objtiles[ORCISH_CHAIN_MAIL] = JTP_TILE_CHAIN_MAIL;
  jtp_objtiles[SCALE_MAIL] = JTP_TILE_SCALE_MAIL;
  jtp_objtiles[RING_MAIL] = JTP_TILE_RING_MAIL;
  jtp_objtiles[ORCISH_RING_MAIL] = JTP_TILE_RING_MAIL;

  jtp_objtiles[LEATHER_GLOVES] = JTP_TILE_GLOVES;
  jtp_objtiles[GAUNTLETS_OF_FUMBLING] = JTP_TILE_GLOVES;
  jtp_objtiles[GAUNTLETS_OF_POWER] = JTP_TILE_GLOVES;
#ifdef GAUNTLETS_OF_SWIMMING
  jtp_objtiles[GAUNTLETS_OF_SWIMMING] = JTP_TILE_GLOVES;
#endif
  jtp_objtiles[GAUNTLETS_OF_DEXTERITY] = JTP_TILE_GLOVES;

  jtp_objtiles[BRASS_LANTERN] = JTP_TILE_LANTERN;
  jtp_objtiles[OIL_LAMP] = JTP_TILE_LANTERN;
  jtp_objtiles[MAGIC_LAMP] = JTP_TILE_LANTERN;
  jtp_objtiles[TALLOW_CANDLE] = JTP_TILE_CANDLE;
  jtp_objtiles[WAX_CANDLE] = JTP_TILE_CANDLE;

  jtp_objtiles[ARROW] = JTP_TILE_ARROW;
  jtp_objtiles[ELVEN_ARROW] = JTP_TILE_ARROW;
  jtp_objtiles[ORCISH_ARROW] = JTP_TILE_ARROW;
  jtp_objtiles[SILVER_ARROW] = JTP_TILE_ARROW;
  jtp_objtiles[YA] = JTP_TILE_ARROW;
  jtp_objtiles[CROSSBOW_BOLT] = JTP_TILE_ARROW;
  jtp_objtiles[DART] = JTP_TILE_ARROW;

  jtp_objtiles[DAGGER] = JTP_TILE_DAGGER;
  jtp_objtiles[ELVEN_DAGGER] = JTP_TILE_DAGGER;
  jtp_objtiles[ORCISH_DAGGER] = JTP_TILE_DAGGER;
  jtp_objtiles[SILVER_DAGGER] = JTP_TILE_DAGGER;
  jtp_objtiles[ATHAME] = JTP_TILE_DAGGER;
  jtp_objtiles[SCALPEL] = JTP_TILE_DAGGER;
  jtp_objtiles[KNIFE] = JTP_TILE_DAGGER;
  jtp_objtiles[STILETTO] = JTP_TILE_DAGGER;
  jtp_objtiles[WORM_TOOTH] = JTP_TILE_DAGGER;
  jtp_objtiles[CRYSKNIFE] = JTP_TILE_DAGGER;

  jtp_objtiles[TRIDENT] = JTP_TILE_TRIDENT;
  jtp_objtiles[FEDORA] = JTP_TILE_FEDORA;

  jtp_objtiles[BOW] = JTP_TILE_BOW;
  jtp_objtiles[ELVEN_BOW] = JTP_TILE_BOW;
  jtp_objtiles[ORCISH_BOW] = JTP_TILE_BOW;
  jtp_objtiles[YUMI] = JTP_TILE_BOW;
  jtp_objtiles[SLING] = JTP_TILE_BOW;
  jtp_objtiles[CROSSBOW] = JTP_TILE_CROSSBOW;

  jtp_objtiles[MUMMY_WRAPPING] = JTP_TILE_CLOAK;
  jtp_objtiles[ELVEN_CLOAK] = JTP_TILE_CLOAK;
  jtp_objtiles[ORCISH_CLOAK] = JTP_TILE_CLOAK;
  jtp_objtiles[DWARVISH_CLOAK] = JTP_TILE_CLOAK;
  jtp_objtiles[OILSKIN_CLOAK] = JTP_TILE_CLOAK;
  jtp_objtiles[ROBE] = JTP_TILE_CLOAK;
#ifdef ALCHEMY_SMOCK
  jtp_objtiles[ALCHEMY_SMOCK] = JTP_TILE_CLOAK;  /* not in Slash'EM */
#endif
  jtp_objtiles[LEATHER_CLOAK] = JTP_TILE_CLOAK;
  jtp_objtiles[CLOAK_OF_PROTECTION] = JTP_TILE_CLOAK;
  jtp_objtiles[CLOAK_OF_INVISIBILITY] = JTP_TILE_CLOAK;
  jtp_objtiles[CLOAK_OF_MAGIC_RESISTANCE] = JTP_TILE_CLOAK;
  jtp_objtiles[CLOAK_OF_DISPLACEMENT] = JTP_TILE_CLOAK;
#ifdef POISONOUS_CLOAK
  jtp_objtiles[POISONOUS_CLOAK] = JTP_TILE_CLOAK;
#endif

  jtp_objtiles[HAWAIIAN_SHIRT] = JTP_TILE_HAWAIIAN_SHIRT;
  jtp_objtiles[T_SHIRT] = JTP_TILE_HAWAIIAN_SHIRT;

  jtp_objtiles[CORNUTHAUM] = JTP_TILE_CONICAL_HAT;
  jtp_objtiles[DUNCE_CAP] = JTP_TILE_CONICAL_HAT;

  jtp_objtiles[SKELETON_KEY] = JTP_TILE_KEY;
  jtp_objtiles[LOCK_PICK] = JTP_TILE_KEY;

  jtp_objtiles[CLUB] = JTP_TILE_CLUB;
  jtp_objtiles[PICK_AXE] = JTP_TILE_PICKAXE;
  jtp_objtiles[GRAPPLING_HOOK] = JTP_TILE_PICKAXE;

  jtp_objtiles[KELP_FROND] = JTP_TILE_KELP_FROND;
  jtp_objtiles[EUCALYPTUS_LEAF] = JTP_TILE_EUCALYPTUS_LEAF;
  jtp_objtiles[APPLE] = JTP_TILE_APPLE;
  jtp_objtiles[ORANGE] = JTP_TILE_ORANGE;
  jtp_objtiles[PEAR] = JTP_TILE_PEAR;
  jtp_objtiles[MELON] = JTP_TILE_MELON;
  jtp_objtiles[BANANA] = JTP_TILE_BANANA;
  jtp_objtiles[CARROT] = JTP_TILE_CARROT;
  jtp_objtiles[SPRIG_OF_WOLFSBANE] = JTP_TILE_SPRIG_OF_WOLFSBANE;
  jtp_objtiles[CLOVE_OF_GARLIC] = JTP_TILE_CLOVE_OF_GARLIC;
  jtp_objtiles[SLIME_MOLD] = JTP_TILE_SLIME_MOLD;
  jtp_objtiles[LUMP_OF_ROYAL_JELLY] = JTP_TILE_LUMP_OF_ROYAL_JELLY;
  jtp_objtiles[EGG] = JTP_TILE_EGG;

  jtp_objtiles[FOOD_RATION] = JTP_TILE_FOOD_RATION;
  jtp_objtiles[CRAM_RATION] = JTP_TILE_CRAM_RATION;
  jtp_objtiles[TRIPE_RATION] = JTP_TILE_TRIPE_RATION;
  jtp_objtiles[K_RATION] = JTP_TILE_K_RATION;
  jtp_objtiles[C_RATION] = JTP_TILE_C_RATION;
  jtp_objtiles[MEATBALL] = JTP_TILE_MEATBALL;
  jtp_objtiles[MEAT_STICK] = JTP_TILE_MEAT_STICK;
  jtp_objtiles[HUGE_CHUNK_OF_MEAT] = JTP_TILE_HUGE_CHUNK_OF_MEAT;
  jtp_objtiles[MEAT_RING] = JTP_TILE_MEAT_RING;
  jtp_objtiles[CREAM_PIE] = JTP_TILE_CREAM_PIE;
  jtp_objtiles[CANDY_BAR] = JTP_TILE_CANDY_BAR;
  jtp_objtiles[FORTUNE_COOKIE] = JTP_TILE_FORTUNE_COOKIE;
  jtp_objtiles[PANCAKE] = JTP_TILE_PANCAKE;
  jtp_objtiles[LEMBAS_WAFER] = JTP_TILE_LEMBAS_WAFER;
  jtp_objtiles[TIN] = JTP_TILE_TIN;
  jtp_objtiles[TINNING_KIT] = JTP_TILE_TINNING_KIT;
  jtp_objtiles[TIN_OPENER] = JTP_TILE_KEY;
  jtp_objtiles[CAN_OF_GREASE] = JTP_TILE_TIN;

  jtp_objtiles[EXPENSIVE_CAMERA] = JTP_TILE_CAMERA;
  jtp_objtiles[MIRROR] = JTP_TILE_MIRROR;
  jtp_objtiles[CRYSTAL_BALL] = JTP_TILE_CRYSTAL_BALL;
  jtp_objtiles[LENSES] = JTP_TILE_CAMERA;
  jtp_objtiles[MAGIC_MARKER] = JTP_TILE_MAGIC_MARKER;
  jtp_objtiles[CREDIT_CARD] = JTP_TILE_CREDIT_CARD;

  jtp_objtiles[BELL] = JTP_TILE_BELL;
  jtp_objtiles[BELL_OF_OPENING] = JTP_TILE_BELL;
  jtp_objtiles[TOOLED_HORN] = JTP_TILE_TOOLED_HORN;
  jtp_objtiles[HORN_OF_PLENTY] = JTP_TILE_FROST_HORN;
  jtp_objtiles[BUGLE] = JTP_TILE_FROST_HORN;
  jtp_objtiles[FROST_HORN] = JTP_TILE_FROST_HORN;
  jtp_objtiles[FIRE_HORN] = JTP_TILE_FIRE_HORN;
  jtp_objtiles[UNICORN_HORN] = JTP_TILE_UNICORN_HORN;

  jtp_objtiles[DILITHIUM_CRYSTAL] = JTP_TILE_DILITHIUM_CRYSTAL;
  jtp_objtiles[DIAMOND] = JTP_TILE_DIAMOND;
  jtp_objtiles[RUBY] = JTP_TILE_RUBY;
  jtp_objtiles[JACINTH] = JTP_TILE_JACINTH;
  jtp_objtiles[SAPPHIRE] = JTP_TILE_SAPPHIRE;
  jtp_objtiles[BLACK_OPAL] = JTP_TILE_BLACK_OPAL;
  jtp_objtiles[EMERALD] = JTP_TILE_EMERALD;
  jtp_objtiles[TURQUOISE] = JTP_TILE_TURQUOISE;
  jtp_objtiles[CITRINE] = JTP_TILE_CITRINE;
  jtp_objtiles[AQUAMARINE] = JTP_TILE_AQUAMARINE;
  jtp_objtiles[AMBER] = JTP_TILE_AMBER;
  jtp_objtiles[TOPAZ] = JTP_TILE_TOPAZ;
  jtp_objtiles[JET] = JTP_TILE_JET;
  jtp_objtiles[OPAL] = JTP_TILE_OPAL;
  jtp_objtiles[CHRYSOBERYL] = JTP_TILE_CHRYSOBERYL;
  jtp_objtiles[GARNET] = JTP_TILE_GARNET;
  jtp_objtiles[AMETHYST] = JTP_TILE_AMETHYST;
  jtp_objtiles[JASPER] = JTP_TILE_JASPER;
  jtp_objtiles[FLUORITE] = JTP_TILE_FLUORITE;
  jtp_objtiles[OBSIDIAN] = JTP_TILE_OBSIDIAN;
  jtp_objtiles[AGATE] = JTP_TILE_AGATE;
  jtp_objtiles[JADE] = JTP_TILE_JADE;

  jtp_objtiles[LUCKSTONE] = JTP_TILE_LUCKSTONE;
  jtp_objtiles[LOADSTONE] = JTP_TILE_LOADSTONE;
  jtp_objtiles[FLINT] = JTP_TILE_FLINT;
  jtp_objtiles[ROCK] = JTP_TILE_ROCKS;
  jtp_objtiles[TOUCHSTONE] = JTP_TILE_TOUCHSTONE;
#ifdef HEALTHSTONE /* only in SlashEM */
  jtp_objtiles[HEALTHSTONE] = JTP_TILE_HEALTHSTONE;
#endif
#ifdef WHETSTONE /* only in SlashEM */
  jtp_objtiles[WHETSTONE] = JTP_TILE_WHETSTONE;
#endif

  jtp_objtiles[SACK] = JTP_TILE_SACK;
  jtp_objtiles[BAG_OF_HOLDING] = JTP_TILE_BAG_OF_HOLDING;
  jtp_objtiles[OILSKIN_SACK] = JTP_TILE_OILSKIN_SACK;
  jtp_objtiles[BAG_OF_TRICKS] = JTP_TILE_BAG_OF_TRICKS;

#ifdef SANITY_CHECKS
  for (i = 0; i < NUM_OBJECTS; i++)
  {
    if (jtp_objtiles[i] == JTP_TILE_INVALID)
    {
      jtp_objtiles[i] = JTP_TILE_DEFAULT_OBJECT;
      temp_descr = OBJ_NAME(objects[i]);
      fprintf(stderr, "object %d (%s) has no tile assigned\n",
        i,
        temp_descr ? temp_descr : "(nil)");
    }
  }
  /*
   * current reports:
   * none
   */
#endif

  /* Clean up */
  free(objclasstiles);
}

void jtp_init_glyph_tiles(void)
{
  int i;
  jtp_traptiles = (int *)malloc(MAXPCHARS*sizeof(int));
  jtp_cmaptiles = (int *)malloc(MAXPCHARS*sizeof(int));
  if ((!jtp_traptiles) || (!jtp_cmaptiles))
  {
    OOM(1);
  }

  jtp_init_monster_tile_table();
  jtp_init_object_tile_table();

  for (i = 0; i < MAXPCHARS; i++)
    jtp_traptiles[i] = JTP_TILE_FLOOR_COBBLESTONE;
  
  for (i = 0; i < MAXPCHARS; i++)
    jtp_cmaptiles[i] = JTP_TILE_VDOOR_WOOD_CLOSED;
  jtp_cmaptiles[S_stone] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_vwall] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_hwall] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_tlcorn] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_trcorn] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_blcorn] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_brcorn] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_crwall] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_tuwall] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_tdwall] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_tlwall] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_trwall] = JTP_TILE_WALL_GENERIC;
  jtp_cmaptiles[S_ndoor] = JTP_TILE_DOOR_WOOD_BROKEN;
  jtp_cmaptiles[S_vodoor] = JTP_TILE_VDOOR_WOOD_OPEN;
  jtp_cmaptiles[S_hodoor] = JTP_TILE_HDOOR_WOOD_OPEN;
  jtp_cmaptiles[S_vcdoor] = JTP_TILE_VDOOR_WOOD_CLOSED;
  jtp_cmaptiles[S_hcdoor] = JTP_TILE_HDOOR_WOOD_CLOSED;
  jtp_cmaptiles[S_room] = JTP_TILE_FLOOR_COBBLESTONE;
  jtp_cmaptiles[S_corr] = JTP_TILE_FLOOR_ROUGH;
  jtp_cmaptiles[S_upstair] = JTP_TILE_STAIRS_UP;
  jtp_cmaptiles[S_dnstair] = JTP_TILE_STAIRS_DOWN;
  jtp_cmaptiles[S_fountain] = JTP_TILE_FOUNTAIN;
  jtp_cmaptiles[S_altar] = JTP_TILE_ALTAR;
  jtp_cmaptiles[S_teleportation_trap] = JTP_TILE_TRAP_TELEPORTER;
  jtp_cmaptiles[S_tree] = JTP_TILE_TREE;
  jtp_cmaptiles[S_cloud] = JTP_TILE_CLOUD;
  jtp_cmaptiles[S_air] = JTP_TILE_FLOOR_AIR;
  jtp_cmaptiles[S_grave] = JTP_TILE_GRAVE;
  jtp_cmaptiles[S_sink] = JTP_TILE_SINK;
  jtp_cmaptiles[S_bear_trap] = JTP_TILE_TRAP_BEAR;
  jtp_cmaptiles[S_rust_trap] = JTP_TILE_TRAP_WATER;
  jtp_cmaptiles[S_pit] = JTP_TILE_TRAP_PIT;
  jtp_cmaptiles[S_hole] = JTP_TILE_TRAP_PIT;
  jtp_cmaptiles[S_trap_door] = JTP_TILE_TRAP_DOOR;
  jtp_cmaptiles[S_water] = JTP_TILE_FLOOR_WATER;
  jtp_cmaptiles[S_pool] = JTP_TILE_FLOOR_WATER;
  jtp_cmaptiles[S_ice] = JTP_TILE_FLOOR_ICE;
  jtp_cmaptiles[S_lava] = JTP_TILE_FLOOR_LAVA;
  jtp_cmaptiles[S_throne] = JTP_TILE_THRONE;
  jtp_cmaptiles[S_bars] = JTP_TILE_BARS;
  jtp_cmaptiles[S_upladder] = JTP_TILE_LADDER_UP;
  jtp_cmaptiles[S_dnladder] = JTP_TILE_LADDER_DOWN;
  jtp_cmaptiles[S_arrow_trap] = JTP_TILE_TRAP_ARROW;
  jtp_cmaptiles[S_rolling_boulder_trap] = JTP_TILE_ROLLING_BOULDER_TRAP;
  jtp_cmaptiles[S_sleeping_gas_trap] = JTP_TILE_GAS_TRAP;
  jtp_cmaptiles[S_fire_trap] = JTP_TILE_TRAP_FIRE;
  jtp_cmaptiles[S_web] = JTP_TILE_WEB_TRAP;
  jtp_cmaptiles[S_statue_trap] = JTP_TILE_STATUE;
  jtp_cmaptiles[S_anti_magic_trap] = JTP_TILE_TRAP_ANTI_MAGIC;
  jtp_cmaptiles[S_polymorph_trap] = JTP_TILE_TRAP_POLYMORPH;
  jtp_cmaptiles[S_vbeam] = JTP_TILE_ZAP_VERTICAL;
  jtp_cmaptiles[S_hbeam] = JTP_TILE_ZAP_HORIZONTAL;
  jtp_cmaptiles[S_lslant] = JTP_TILE_ZAP_SLANT_LEFT;
  jtp_cmaptiles[S_rslant] = JTP_TILE_ZAP_SLANT_RIGHT;
  jtp_cmaptiles[S_explode1] = JTP_TILE_EXPLOSION_NORTHWEST;
  jtp_cmaptiles[S_explode2] = JTP_TILE_EXPLOSION_NORTH;
  jtp_cmaptiles[S_explode3] = JTP_TILE_EXPLOSION_NORTHEAST;
  jtp_cmaptiles[S_explode4] = JTP_TILE_EXPLOSION_WEST;
  jtp_cmaptiles[S_explode5] = JTP_TILE_EXPLOSION_CENTER;
  jtp_cmaptiles[S_explode6] = JTP_TILE_EXPLOSION_EAST;
  jtp_cmaptiles[S_explode7] = JTP_TILE_EXPLOSION_SOUTHWEST;
  jtp_cmaptiles[S_explode8] = JTP_TILE_EXPLOSION_SOUTH;
  jtp_cmaptiles[S_explode9] = JTP_TILE_EXPLOSION_SOUTHEAST;
  jtp_cmaptiles[S_litcorr] = JTP_TILE_FLOOR_ROUGH_LIT;
  jtp_cmaptiles[S_ss1] = JTP_TILE_RESIST_SPELL_1;
  jtp_cmaptiles[S_ss2] = JTP_TILE_RESIST_SPELL_2;
  jtp_cmaptiles[S_ss3] = JTP_TILE_RESIST_SPELL_3;
  jtp_cmaptiles[S_ss4] = JTP_TILE_RESIST_SPELL_4;
  jtp_cmaptiles[S_dart_trap] = JTP_TILE_DART_TRAP;
  jtp_cmaptiles[S_falling_rock_trap] = JTP_TILE_FALLING_ROCK_TRAP;
  jtp_cmaptiles[S_squeaky_board] = JTP_TILE_SQUEAKY_BOARD;
  jtp_cmaptiles[S_land_mine] = JTP_TILE_LAND_MINE;
  jtp_cmaptiles[S_magic_portal] = JTP_TILE_MAGIC_PORTAL;
  jtp_cmaptiles[S_spiked_pit] = JTP_TILE_TILE_SPIKED_PIT;
  jtp_cmaptiles[S_hole] = JTP_TILE_HOLE;
  jtp_cmaptiles[S_level_teleporter] = JTP_TILE_LEVEL_TELEPORTER;
  jtp_cmaptiles[S_magic_trap] = JTP_TILE_MAGIC_TRAP;
  jtp_cmaptiles[S_digbeam] = JTP_TILE_DIGBEAM;
  jtp_cmaptiles[S_flashbeam] = JTP_TILE_FLASHBEAM;
  jtp_cmaptiles[S_boomleft] = JTP_TILE_BOOMLEFT;
  jtp_cmaptiles[S_boomright] = JTP_TILE_BOOMRIGHT;
  jtp_cmaptiles[S_hcdbridge] = JTP_TILE_HCDBRIDGE;
  jtp_cmaptiles[S_vcdbridge] = JTP_TILE_VCDBRIDGE;
  jtp_cmaptiles[S_hodbridge] = JTP_TILE_HODBRIDGE;
  jtp_cmaptiles[S_vodbridge] = JTP_TILE_VODBRIDGE;

  jtp_tile_conversion_initialized = 1;
    
/*    
#define S_stone		0
#define S_vwall		1
#define S_hwall		2
#define S_tlcorn	3
#define S_trcorn	4
#define S_blcorn	5
#define S_brcorn	6
#define S_crwall	7
#define S_tuwall	8
#define S_tdwall	9
#define S_tlwall	10
#define S_trwall	11
#define S_ndoor		12
#define S_vodoor	13
#define S_hodoor	14
#define S_vcdoor	15	// closed door, vertical wall
#define S_hcdoor	16	// closed door, horizontal wall
#define S_bars		17	// KMH -- iron bars 
#define S_tree		18	// KMH 
#define S_room		19
#define S_corr		20
#define S_litcorr	21
#define S_upstair	22
#define S_dnstair	23
#define S_upladder	24
#define S_dnladder	25
#define S_altar		26
#define S_grave		27
#define S_throne	28
#define S_sink		29
#define S_fountain	30
#define S_pool		31
#define S_ice		32
#define S_lava		33
#define S_vodbridge	34
#define S_hodbridge	35
#define S_vcdbridge	36	// closed drawbridge, vertical wall
#define S_hcdbridge	37	// closed drawbridge, horizontal wall
#define S_air		38
#define S_cloud		39
#define S_water		40
*/
}

#ifdef SANITY_CHECKS
static char *lastpcx;
#define setlastpcx(filename) if (lastpcx) free(lastpcx); lastpcx = jtp_strdup(filename)
#else
#define setlastpcx(filename)
#endif


char *jtp_make_filename(const char *subdir1, const char *subdir2, const char *name)
{
	char *filename;
	
	filename = (char *)malloc(strlen(jtp_game_path) + 1 +
		(subdir1 ? strlen(subdir1) + 2 : 0) +
		(subdir2 ? strlen(subdir2) + 2 : 0) +
		strlen(name) + 1);
	if (filename == NULL)
		OOM(1);
		
	/*
	 * may need to be fixed on OSses like VMS
	 */
	strcpy(filename, jtp_game_path);
	append_slash(filename);
	if (subdir1)
	{
		strcat(filename, subdir1);
		append_slash(filename);
	}
	if (subdir2)
	{
		strcat(filename, subdir2);
		append_slash(filename);
	}
	strcat(filename, name);
	return filename;
}


#ifndef R_OK
#  define R_OK 4
#endif

/*
 * Load a PCX file from the graphics directory.
 * Returns the buffer from jtp_load_PCX_buf
 * (width & height encoded in first 4 bytes)
 */
unsigned char *jtp_load_graphic(const char *subdir, const char *name, int load_palette)
{
	unsigned char *image;
	char *filename;
	char namebuf[128];
	
	strcat(strcpy(namebuf, name), ".pcx");
	filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, subdir, namebuf);
	if (filename == NULL)
		OOM(1);
	if (access(filename, R_OK) != 0)
	{
		/*
		 * try main directory if not found in sub-directory
		 */
		if (subdir != NULL)
		{
			free(filename);
			filename = 	jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, namebuf);
		}
	}
	if (jtp_load_PCX_buf(0, 0, filename, &image, load_palette) == JTP_PCX_FAILURE)
	{
		image = NULL;
	}
	setlastpcx(filename);
	free(filename);
	return image;
}


static jtp_tilestats *jtp_get_tile_src(
  int x1, int y1,
  int x2, int y2,
  unsigned char *image
)
{
  jtp_tilestats * temp1;
  int i, j, tx1 = 0, ty1 = 0, tx2 = -1, ty2 = -1;
  int image_width, image_height;
 
  temp1 =(jtp_tilestats *)malloc(sizeof(jtp_tilestats));
  if (!temp1)
  {
    OOM(1);
  }
  jtp_get_dimensions(image, &image_width, &image_height);
  image += 4;
 
  for (i = y1; i <= y2; i++)
    for (j = x1; j <= x2; j++)
      if (image[i * image_width + j] != JTP_COLOR_BACKGROUND)
      {
        ty1 = i;
        i = y2 + 1;
        j = x2 + 1;
      }
 
  for (i = y2; i >= y1; i--)
    for (j = x1; j <= x2; j++)
      if (image[i * image_width + j] != JTP_COLOR_BACKGROUND)
      {
        ty2 = i;
        i = y1 - 1;
        j = x2 + 1;
      }
 
  for (j = x1; j <= x2; j++)
    for (i = ty1; i <= ty2; i++)
      if (image[i * image_width + j] != JTP_COLOR_BACKGROUND)
      {
        tx1 = j;
        i = ty2 + 1;
        j = x2 + 1;
      }

  for (j = x2; j >= x1; j--)
    for (i = ty1; i <= ty2; i++)
      if (image[i * image_width + j] != JTP_COLOR_BACKGROUND)
      {
        tx2 = j;
        i = ty2 + 1;
        j = x1 - 1;
      }
 
  temp1->xmod = 9999;
  for (i = x1; i <= x2; i++)
  {
    if (image[(y1 - 1) * image_width + i] == JTP_COLOR_HOTSPOT)
      temp1->xmod = tx1 - i;
  }
  
  temp1->ymod = 9999;
  for (i = y1; i <= y2; i++)
  {
    if (image[i * image_width + x1 - 1] == JTP_COLOR_HOTSPOT)
      temp1->ymod = ty1 - i;
  }
  
  temp1->graphic = jtp_get_img_src(tx1, ty1, tx2, ty2, image - 4);

#ifdef SANITY_CHECKS
  if (temp1->xmod == 9999 || temp1->ymod == 9999)
  {
    fprintf(stderr, "no hotspot found in file %s\n", lastpcx);
  }
  for (i = x1 - 1; i <= x2 + 1; i++)
  {
    if ((image[(y1 - 1) * image_width + i] != JTP_COLOR_HOTSPOT || i == (x1 - 1) || i == (x2 + 1)) &&
      image[(y1 - 1) * image_width + i] != JTP_COLOR_BORDER)
      fprintf(stderr, "warning: pixel at %d,%d in file %s is neither border nor hotspot, wrong dimensions?\n",
        i, y1 - 1, lastpcx);
    if ((image[(y2 + 1) * image_width + i] != JTP_COLOR_HOTSPOT || i == (x1 - 1) || i == (x2 + 1)) &&
      image[(y2 + 1) * image_width + i] != JTP_COLOR_BORDER)
      fprintf(stderr, "warning: pixel at %d,%d in file %s is neither border nor hotspot, wrong dimensions?\n",
        i, y2 + 1, lastpcx);
  }

  for (i = y1 - 1; i <= y2 + 1; i++)
  {
    if ((image[i * image_width + x1 - 1] != JTP_COLOR_HOTSPOT || i == (y1 - 1) || i == (y2 + 1)) &&
      image[i * image_width + x1 - 1] != JTP_COLOR_BORDER)
      fprintf(stderr, "warning: pixel at %d,%d in file %s is neither border nor hotspot, wrong dimensions?\n",
        x1 - 1, i, lastpcx);
    if ((image[i * image_width + x2 + 1] != JTP_COLOR_HOTSPOT || i == (y1 - 1) || i == (y2 + 1)) &&
      image[i * image_width + x2 + 1] != JTP_COLOR_BORDER)
      fprintf(stderr, "warning: pixel at %d,%d in file %s is neither border nor hotspot, wrong dimensions?\n",
        x2 + 1, i, lastpcx);
  }

  if (temp1->graphic == NULL)
  {
    fprintf(stderr, "error loading a tile of size %dx%d, from %d.%d-%d.%d in file %s of size %dx%d\n",
      tx2 - tx1 + 1,
      ty2 - ty1 + 1,
      x1, y1, x2, y2,
      lastpcx,
      image_width, image_height);
  }
#endif

  if (temp1->xmod == 9999)
    temp1->xmod = 0;
  if (temp1->ymod == 9999)
    temp1->ymod = 0;

  return temp1;
}


static jtp_tilestats *jtp_get_tile(int x1, int y1, int x2, int y2)
{
  return jtp_get_tile_src(x1, y1, x2, y2, jtp_screen.vpage - 4);
}


static void jtp_put_tile
(
  int x, int y,
  int shade,
  unsigned char *a
)
{
  int srcXsize,srcYsize,j,yalku,yloppu,xalku,xloppu;
  int dplus;
  unsigned char *destin, *a_end, *shades;

  if ((!a) || (x>jtp_screen.drx2) || (y>jtp_screen.dry2)) return;

  jtp_get_dimensions(a, &srcXsize, &srcYsize);

  if ((x+srcXsize<=jtp_screen.drx1) || (y+srcYsize<=jtp_screen.dry1)) return;
  if (y<jtp_screen.dry1) yalku=jtp_screen.dry1-y; else yalku=0;
  if (y+srcYsize-1>jtp_screen.dry2) yloppu=jtp_screen.dry2-y; else yloppu=srcYsize-1;
  if (x<jtp_screen.drx1) xalku=jtp_screen.drx1-x; else xalku=0; 
  if (x+srcXsize-1>jtp_screen.drx2) xloppu=jtp_screen.drx2-x; else xloppu=srcXsize-1;

  a+=yalku*srcXsize+4;
  a_end = a + (yloppu-yalku+1)*srcXsize;
  destin=jtp_screen.vpage+(yalku+y)*jtp_screen.width+x;
  dplus = jtp_screen.width;

  a += xalku;
  a_end += xalku;
  destin += xalku;
  xloppu -= xalku;
  xalku = jtp_screen.width;
  shades = jtp_shade + 256*shade;

  while (a < a_end)
  {
     for (j = xloppu; j >= 0; j--)
     {
       if (a[j] != JTP_COLOR_BACKGROUND)
        destin[j] = shades[a[j]];
     }
     a += srcXsize;  
     destin += dplus;
  }
}


static unsigned char *jtp_init_shades(char *fname)
{
 int i, j;
 FILE * f;
 unsigned char *temp1;

 f = fopen(fname, "rb");
 if (!f) return(NULL);
 
 temp1 = (unsigned char *)malloc(JTP_MAX_SHADES*256*sizeof(unsigned char));
 if (!temp1) 
 {
   OOM(1);
 }  
 
 fread(temp1,1,JTP_MAX_SHADES*256,f);
 fclose(f);
 
 /* 
  * Make sure that the background color is not used as a shade.
  * Replace any occurences with color 47 (which is currently black)
  */
 for (i = 1; i < JTP_MAX_SHADES; i++)
   for (j = 0; j < 256; j++)
     if (temp1[i*256+j] == JTP_COLOR_BACKGROUND)
       temp1[i*256+j] = 47;
 
 return(temp1);
}

static void jtp_init_lights(int how_many)
{
  int i;

  jtp_nlights = how_many;

  for (i = 0; i < jtp_nlights; i++)
  {
    jtp_lights[i].x = rand()%(JTP_MAP_WIDTH - 1) + 1;  /* X location */
    jtp_lights[i].y = rand()%JTP_MAP_HEIGHT;           /* Y location */
    jtp_lights[i].radius = (rand()%20 + 1) / 10.0;         /* radius */
  }
}

static void jtp_init_floor_decors(int how_many)
{
  int i, j, k, l, m, n;
  int pos_found = 0;
  int cur_style, x = 0, y = 0;
  int **temp_mask;
  
  /* Initialize floor decorations */
  jtp_n_floor_decors = 0;  
  if (jtp_floor_decors) free(jtp_floor_decors);
  jtp_floor_decors = NULL;

  /*
    Create a temporary conversion of the actual dungeon level. 
    This is to ensure that decorations are in rooms (eg. not partly inside walls).
    I do this by making a mask with undesirable locations zeroed out.
  */
  temp_mask = (int **)malloc(JTP_MAP_HEIGHT*sizeof(int *));
  for (i = 0; i < JTP_MAP_HEIGHT; i++)
  {
    temp_mask[i] = (int *)malloc(JTP_MAP_WIDTH*sizeof(int));
    for (j = 1; j < JTP_MAP_WIDTH; j++)
    {
      k = back_to_glyph(j, i) - GLYPH_CMAP_OFF;
      switch(k)
      {
        case S_stone: case S_vwall: case S_hwall:
        case S_tlcorn: case S_trcorn: case S_blcorn: case S_brcorn:
        case S_crwall: case S_tuwall: case S_tdwall: case S_tlwall: case S_trwall:
          temp_mask[i][j] = 0;
          break;
        default:
          /* 
            Technically, we should also worry about moats etc., but this will do
            for a start.
          */
          temp_mask[i][j] = 1;
          break;
      }
    }
  }
  
  /* This rather messy piece of code places the decorations onto the map */
  for (i = 0; i < how_many; i++)
  {
    switch(rand()%3)
    {
      case 0: cur_style = JTP_FLOOR_STYLE_CARPET; break;
      case 1: cur_style = JTP_FLOOR_STYLE_MURAL; break;
      case 2: cur_style = JTP_FLOOR_STYLE_MURAL_2; break;
      default: cur_style = JTP_FLOOR_STYLE_CARPET; break;
    }

    j = jtp_n_floor_decors;
    j += jtp_floors[cur_style].xspan*jtp_floors[cur_style].yspan;
    jtp_floor_decors = (jtp_floor_decor *)realloc(jtp_floor_decors, j*sizeof(jtp_floor_decor));
    
    /* Find location for decoration */
    for (k = 0; k <= JTP_MAP_HEIGHT-jtp_floors[cur_style].yspan; k++)
      for (l = 1; l <= JTP_MAP_WIDTH-jtp_floors[cur_style].xspan; l++)
      {
        pos_found = 1;
        for (m = jtp_floors[cur_style].yspan-1; m >= 0; m--)
          for (n = jtp_floors[cur_style].xspan-1; n >= 0; n--)
          {
            if (!temp_mask[k+m][l+n])
            {
              pos_found = 0; m = -1; n = -1;
            }
          }
        if (pos_found)
        {
          y = k; x = l;
          k = JTP_MAP_HEIGHT-jtp_floors[cur_style].yspan+1;
          l = JTP_MAP_WIDTH-jtp_floors[cur_style].xspan+1;
        }
      }
    if (!pos_found)
    {
      x = rand()%(JTP_MAP_WIDTH-jtp_floors[cur_style].xspan) + 1;
      y = rand()%(JTP_MAP_HEIGHT-jtp_floors[cur_style].yspan+1);
    }
    
    /* Remove chosen area from mask */
    for (k = 0; k < jtp_floors[cur_style].yspan; k++)
      for (l = 0; l < jtp_floors[cur_style].xspan; l++)
        temp_mask[y+k][x+l] = 0;

    /* Place floor decor on the map */
    for (k = 0; k < jtp_floors[cur_style].yspan; k++)
      for (l = 0; l < jtp_floors[cur_style].xspan; l++)
      {
        m = k*jtp_floors[cur_style].xspan + l;
        jtp_floor_decors[jtp_n_floor_decors+m].x = x + l;
        jtp_floor_decors[jtp_n_floor_decors+m].y = y + k;
        jtp_floor_decors[jtp_n_floor_decors+m].style = cur_style;
        jtp_floor_decors[jtp_n_floor_decors+m].pos = m;
      }
    jtp_n_floor_decors = j;
  }
  
  /* Clean up */
  for (i = 0; i < JTP_MAP_HEIGHT; i++)
    free(temp_mask[i]);
  free(temp_mask);
}

static void jtp_get_floor_style
(
  int style_index,
  int xspan, int yspan,
  int x1, int y1
)
{
  int i, j;

  jtp_floors[style_index].xspan = xspan;
  jtp_floors[style_index].yspan = yspan;
  jtp_floors[style_index].pattern = (jtp_tilestats **)malloc(xspan*yspan*sizeof(jtp_tilestats *));

#define FS_DX 116
#define FS_DY 53
#define FS_EX 112
#define FS_EY 49
  for (i = 0; i < yspan; i++)
    for (j = 0; j < xspan; j++)
      jtp_floors[style_index].pattern[i*xspan+j] = jtp_get_tile(x1 + FS_DX*j, y1 + FS_DY*i, x1 + FS_DX*j + FS_EX, y1 + FS_DY*i + FS_EY);
}

static void jtp_get_floor_edge_style
(
  int style_index,
  int x1, int y1
)
{
#define FE_DX 116
#define FE_DY 53
#define FE_EX 112
#define FE_EY 49
  jtp_floor_edges[style_index].west = jtp_get_tile(x1, y1, x1 + FE_EX, y1 + FE_EY);
  jtp_floor_edges[style_index].north = jtp_get_tile(x1 + FE_DX, y1, x1 + FE_EX + FE_DX, y1 + FE_EY);
  jtp_floor_edges[style_index].south = jtp_get_tile(x1, y1 + FE_DY, x1 + FE_EX, y1 + FE_EY + FE_DY);
  jtp_floor_edges[style_index].east = jtp_get_tile(x1 + FE_DX, y1 + FE_DY, x1 + FE_EX + FE_DX, y1 + FE_EY + FE_DY);
  jtp_floor_edges[style_index].southwest = jtp_get_tile(x1 + 2*FE_DX, y1, x1 + FE_EX + 2*FE_DX, y1 + FE_EY);
  jtp_floor_edges[style_index].northwest = jtp_get_tile(x1 + 3*FE_DX, y1, x1 + FE_EX + 3*FE_DX, y1 + FE_EY);
  jtp_floor_edges[style_index].southeast = jtp_get_tile(x1 + 2*FE_DX, y1 + FE_DY, x1 + FE_EX + 2*FE_DX, y1 + FE_EY + FE_DY);
  jtp_floor_edges[style_index].northeast = jtp_get_tile(x1 + 3*FE_DX, y1 + FE_DY, x1 + FE_EX + 3*FE_DX, y1 + FE_EY + FE_DY);
  jtp_floor_edges[style_index].southwest_bank = jtp_get_tile(x1 + 4*FE_DX, y1, x1 + FE_EX + 4*FE_DX, y1 + FE_EY);
  jtp_floor_edges[style_index].northwest_bank = jtp_get_tile(x1 + 5*FE_DX, y1, x1 + FE_EX + 5*FE_DX, y1 + FE_EY);
  jtp_floor_edges[style_index].southeast_bank = jtp_get_tile(x1 + 4*FE_DX, y1 + FE_DY, x1 + FE_EX + 4*FE_DX, y1 + FE_EY + FE_DY);
  jtp_floor_edges[style_index].northeast_bank = jtp_get_tile(x1 + 5*FE_DX, y1 + FE_DY, x1 + FE_EX + 5*FE_DX, y1 + FE_EY + FE_DY);
}

static void jtp_get_wall_style
(
  int style_index,
  int x1, int y1
)
{
#define WS_DX 60
#define WS_EX 56
#define WS_EY 122
  jtp_walls[style_index].west = jtp_get_tile(x1, y1, x1 + WS_EX, y1 + WS_EY);
  jtp_walls[style_index].north = jtp_get_tile(x1 + WS_DX, y1, x1 + WS_DX + WS_EX, y1 + WS_EY);
  jtp_walls[style_index].south = jtp_get_tile(x1 + 2*WS_DX, y1, x1 + 2*WS_DX + WS_EX, y1 + WS_EY);
  jtp_walls[style_index].east = jtp_get_tile(x1 + 3*WS_DX, y1, x1 + 3*WS_DX + WS_EX, y1 + WS_EY);
}


static void jtp_get_tile_group
(
  int group_rows, 
  int group_cols,
  int x,
  int y,
  int tile_dx,
  int tile_dy,
  int ** indices
)
{
  int i, j;

  for (i = 0; i < group_rows; i++)
    for (j = 0; j < group_cols; j++)
      {
        if (indices[i][j] >= 0)
	  {
            jtp_tiles[indices[i][j]] =
	      jtp_get_tile(x + j*tile_dx, y + i*tile_dy, 
                           x + (j+1)*tile_dx - 4, y + (i+1)*tile_dy - 4);
	  }
      }
}


static int jtp_init_tilegraphics(void)
{
  int i, j;
  int **tileloc;
  int all_ok = TRUE;
  char *filename;

  filename = jtp_make_filename(JTP_CONFIG_DIRECTORY, NULL, JTP_FILENAME_SHADING_TABLE);
  jtp_shade = jtp_init_shades(filename);
  free(filename);
  all_ok &= jtp_shade != NULL;
  
  tileloc = (int **)malloc(20*sizeof(int *));
  for (i = 0; i < 20; i++) 
    tileloc[i] = (int *)malloc(20*sizeof(int));

  jtp_tiles = (jtp_tilestats **)calloc(JTP_MAX_TILES, sizeof(jtp_tilestats *));
  jtp_walls = (jtp_wall_style *)calloc(JTP_MAX_WALL_STYLES, sizeof(jtp_wall_style));
  jtp_floors = (jtp_floor_style *)calloc(JTP_MAX_FLOOR_STYLES, sizeof(jtp_floor_style));
  jtp_floor_edges = (jtp_floor_edge_style *)calloc(JTP_MAX_FLOOR_EDGE_STYLES, sizeof(jtp_floor_edge_style));
  if (jtp_tiles == NULL || jtp_walls == NULL || jtp_floors == NULL || jtp_floor_edges == NULL)
    OOM(1);
  
  /* Load wall tiles */
  if (jtp_wall_display_style == JTP_WALL_DISPLAY_STYLE_FULL)
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls02a.pcx");
  else if (jtp_wall_display_style == JTP_WALL_DISPLAY_STYLE_HALF_HEIGHT)
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls02c.pcx");
  else if (jtp_wall_display_style == JTP_WALL_DISPLAY_STYLE_TRANSPARENT)
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls02b.pcx");
  else
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls02a.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  
  jtp_get_wall_style(JTP_WALL_STYLE_BRICK, 1, 1);
  jtp_get_wall_style(JTP_WALL_STYLE_BRICK_BANNER, 241, 1);
  jtp_get_wall_style(JTP_WALL_STYLE_BRICK_PAINTING, 1, 127);
  jtp_get_wall_style(JTP_WALL_STYLE_BRICK_POCKET, 481, 1);
  jtp_get_wall_style(JTP_WALL_STYLE_BRICK_PILLAR, 241, 127);
  jtp_get_wall_style(JTP_WALL_STYLE_MARBLE, 1, 253);

  /* Load more wall tiles */
  if (jtp_wall_display_style == JTP_WALL_DISPLAY_STYLE_FULL)
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls03a.pcx");
  else if (jtp_wall_display_style == JTP_WALL_DISPLAY_STYLE_HALF_HEIGHT)
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls03c.pcx");
  else if (jtp_wall_display_style == JTP_WALL_DISPLAY_STYLE_TRANSPARENT)
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls03b.pcx");
  else
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls03a.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);

  jtp_get_wall_style(JTP_WALL_STYLE_VINE_COVERED, 1, 1);
  jtp_get_wall_style(JTP_WALL_STYLE_STUCCO, 1, 127);
  jtp_get_wall_style(JTP_WALL_STYLE_ROUGH, 1, 253);

  /* Load even more wall tiles */
  if (jtp_wall_display_style == JTP_WALL_DISPLAY_STYLE_FULL)
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls04a.pcx");
  else if (jtp_wall_display_style == JTP_WALL_DISPLAY_STYLE_HALF_HEIGHT)
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls04c.pcx");
  else if (jtp_wall_display_style == JTP_WALL_DISPLAY_STYLE_TRANSPARENT)
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls04b.pcx");
  else
    filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "walls04a.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);

  jtp_get_wall_style(JTP_WALL_STYLE_DARK, 1, 1);
  jtp_get_wall_style(JTP_WALL_STYLE_LIGHT, 1, 127);

  /* Load floor pattern tiles */
  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_cm12.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  /* Cobblestone floor tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_COBBLESTONE, 3, 3, 1, 1);
  /* Rough floor tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_ROUGH, 3, 3, 1, 160);
  /* Ceramic floor tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_CERAMIC, 3, 3, 1, 319);
  /* Lava floor tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_LAVA, 3, 3, 349, 1);
  /* Water floor tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_WATER, 3, 3, 349, 160);
  /* Ice floor tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_ICE, 3, 3, 349, 319);
  /* Cobblestone floor edges (12 orientations) */
  jtp_get_floor_edge_style(JTP_FLOOR_EDGE_STYLE_COBBLESTONE, 1, 478);

  /* Load more floor pattern tiles */

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_cm13.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  /* Mural tiles (3x2 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_MURAL, 3, 2, 1, 1);
  /* Mural 2 tiles (3x2 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_MURAL_2, 3, 2, 349, 1);
  /* Carpet tiles (3x2 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_CARPET, 3, 2, 1, 107);
  /* Moss-covered floor tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_MOSS_COVERED, 3, 3, 1, 213);
  /* Marble floor tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_MARBLE, 3, 3, 349, 213);
  /* Lit rough floor tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_ROUGH_LIT, 3, 3, 1, 372);
  /* Air tiles (3x3 pattern) */
  jtp_get_floor_style(JTP_FLOOR_STYLE_AIR, 3, 3, 349, 372);
  /* Rogue tile (1x1 pattern) */
/*  jtp_get_floor_style(JTP_FLOOR_STYLE_DARK, 1, 1, 349, 372); */
  jtp_get_floor_style(JTP_FLOOR_STYLE_DARK, 1, 1, 1, 531);

#define JTP_CMAP_TILE_DX 116
#define JTP_CMAP_TILE_DY 126

  /* Load miscellaneous cmap tiles */

  tileloc[0][0] = JTP_TILE_DOOR_WOOD_BROKEN; tileloc[0][1] = JTP_TILE_HDOOR_WOOD_CLOSED;
  tileloc[0][2] = JTP_TILE_VDOOR_WOOD_CLOSED; tileloc[0][3] = JTP_TILE_VDOOR_WOOD_OPEN;
  tileloc[0][4] = JTP_TILE_HDOOR_WOOD_OPEN; tileloc[0][5] = JTP_TILE_TRAP_BEAR;
  tileloc[1][0] = JTP_TILE_GRAVE; tileloc[1][1] = JTP_TILE_ALTAR;
  tileloc[1][2] = JTP_TILE_FOUNTAIN; tileloc[1][3] = JTP_TILE_STAIRS_UP;
  tileloc[1][4] = JTP_TILE_STAIRS_DOWN; tileloc[1][5] = JTP_TILE_SINK;
  tileloc[2][0] = JTP_TILE_GAS_TRAP; tileloc[2][1] = JTP_TILE_TRAP_PIT;
  tileloc[2][2] = JTP_TILE_TRAP_POLYMORPH; tileloc[2][3] = JTP_TILE_TREE;
  tileloc[2][4] = -1; tileloc[2][5] = JTP_TILE_TRAP_MAGIC;
  tileloc[3][0] = JTP_TILE_TRAP_DOOR; tileloc[3][1] = JTP_TILE_TRAP_WATER;
  tileloc[3][2] = JTP_TILE_TRAP_TELEPORTER; tileloc[3][3] = JTP_TILE_FLOOR_NOT_VISIBLE;
  tileloc[3][4] = -1; tileloc[3][5] =  JTP_TILE_HILITE_PET;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_cm07.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_CMAP_TILE_DX, JTP_CMAP_TILE_DY, tileloc);

  /* Load more miscellaneous cmap tiles */

  tileloc[0][0] = JTP_TILE_BARS; tileloc[0][1] = JTP_TILE_THRONE;
  tileloc[0][2] = -1; tileloc[0][3] = JTP_TILE_EXPLOSION_NORTHWEST;
  tileloc[0][4] = JTP_TILE_EXPLOSION_NORTH; tileloc[0][5] = JTP_TILE_EXPLOSION_NORTHEAST;
  tileloc[1][0] = JTP_TILE_TRAP_ANTI_MAGIC; tileloc[1][1] = JTP_TILE_TRAP_ARROW;
  tileloc[1][2] = -1; tileloc[1][3] = JTP_TILE_EXPLOSION_WEST;
  tileloc[1][4] = JTP_TILE_EXPLOSION_CENTER; tileloc[1][5] = JTP_TILE_EXPLOSION_EAST;
  tileloc[2][0] = JTP_TILE_TRAP_FIRE; tileloc[2][1] = JTP_TILE_ROLLING_BOULDER_TRAP;
  tileloc[2][2] = JTP_TILE_TRAP_SLEEPGAS; tileloc[2][3] = JTP_TILE_EXPLOSION_SOUTHWEST;
  tileloc[2][4] = JTP_TILE_EXPLOSION_SOUTH; tileloc[2][5] = JTP_TILE_EXPLOSION_SOUTHEAST;
  tileloc[3][0] = JTP_TILE_ZAP_SLANT_RIGHT; tileloc[3][1] = JTP_TILE_ZAP_SLANT_LEFT;
  tileloc[3][2] = JTP_TILE_ZAP_HORIZONTAL; tileloc[3][3] = JTP_TILE_ZAP_VERTICAL;
  tileloc[3][4] = JTP_TILE_LADDER_UP; tileloc[3][5] = JTP_TILE_LADDER_DOWN;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_cmc7.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_CMAP_TILE_DX, JTP_CMAP_TILE_DY, tileloc);

  /* Load some special effect cmap tiles */

  tileloc[0][0] = JTP_TILE_RESIST_SPELL_1; tileloc[0][1] = JTP_TILE_RESIST_SPELL_2;
  tileloc[0][2] = JTP_TILE_RESIST_SPELL_3; tileloc[0][3] = JTP_TILE_RESIST_SPELL_4;
  tileloc[0][4] = JTP_TILE_WEB_TRAP; tileloc[0][5] = JTP_TILE_DART_TRAP;
  tileloc[1][0] = JTP_TILE_FALLING_ROCK_TRAP; tileloc[1][1] = JTP_TILE_SQUEAKY_BOARD;
  tileloc[1][2] = JTP_TILE_LAND_MINE; tileloc[1][3] = JTP_TILE_MAGIC_PORTAL;
  tileloc[1][4] = JTP_TILE_TILE_SPIKED_PIT; tileloc[1][5] = JTP_TILE_HOLE;
  tileloc[2][0] = JTP_TILE_LEVEL_TELEPORTER; tileloc[2][1] = JTP_TILE_MAGIC_TRAP;
  tileloc[2][2] = JTP_TILE_DIGBEAM; tileloc[2][3] = JTP_TILE_FLASHBEAM;
  tileloc[2][4] = JTP_TILE_BOOMLEFT; tileloc[2][5] = JTP_TILE_BOOMRIGHT;
  tileloc[3][0] = JTP_TILE_HCDBRIDGE; tileloc[3][1] = JTP_TILE_VCDBRIDGE;
  tileloc[3][2] = JTP_TILE_VODBRIDGE; tileloc[3][3] = JTP_TILE_HODBRIDGE;
  tileloc[3][4] = JTP_TILE_CLOUD; tileloc[3][5] = -1;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_cmc1.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_CMAP_TILE_DX, JTP_CMAP_TILE_DY, tileloc);

#define JTP_OBJ_TILE_DX 96
#define JTP_OBJ_TILE_DY 102

  /* Load object tiles */

  tileloc[0][0] = JTP_TILE_MISC; tileloc[0][1] = JTP_TILE_BOULDER;
  tileloc[0][2] = JTP_TILE_BONES; tileloc[0][3] = -1;
  tileloc[0][4] = -1; tileloc[0][5] = -1;
  tileloc[0][6] = JTP_TILE_BOW; tileloc[0][7] = JTP_TILE_KEY;
  tileloc[1][0] = JTP_TILE_STATUE; tileloc[1][1] = JTP_TILE_CHEST;
  tileloc[1][2] = JTP_TILE_COINS; tileloc[1][3] = JTP_TILE_BOOK;
  tileloc[1][4] = JTP_TILE_HELMET; tileloc[1][5] = JTP_TILE_SHIELD;
  tileloc[1][6] = JTP_TILE_AMULET; tileloc[1][7] = JTP_TILE_DAGGER;
  tileloc[2][0] = JTP_TILE_BOOTS; tileloc[2][1] = JTP_TILE_SPEAR;
  tileloc[2][2] = -1; tileloc[2][3] = JTP_TILE_SCROLL;
  tileloc[2][4] = JTP_TILE_WAND; tileloc[2][5] = JTP_TILE_SWORD;
  tileloc[2][6] = JTP_TILE_RING; tileloc[2][7] = JTP_TILE_APPLE;
  tileloc[3][0] = JTP_TILE_BLUE_GLASS; tileloc[3][1] = JTP_TILE_RING_MAIL;
  tileloc[3][2] = JTP_TILE_LEATHER_ARMOR; tileloc[3][3] = JTP_TILE_PLATE_MAIL;
  tileloc[3][4] = JTP_TILE_HAMMER; tileloc[3][5] = JTP_TILE_AXE;
  tileloc[3][6] = JTP_TILE_LANTERN; tileloc[3][7] = JTP_TILE_PEAR;
  tileloc[4][0] = JTP_TILE_SCALE_MAIL; tileloc[4][1] = JTP_TILE_CHAIN_MAIL;
  tileloc[4][2] = JTP_TILE_CLOAK; tileloc[4][3] = JTP_TILE_TRIDENT;
  tileloc[4][4] = JTP_TILE_CAMERA; tileloc[4][5] = JTP_TILE_FEDORA;
  tileloc[4][6] = JTP_TILE_CLUB; tileloc[4][7] = JTP_TILE_ARROW;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_obj1.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(5, 8, 1, 1, JTP_OBJ_TILE_DX, JTP_OBJ_TILE_DY, tileloc);

  /* Load more object tiles */

  tileloc[0][0] = JTP_TILE_EGG; tileloc[0][1] = JTP_TILE_GLOVES;
  tileloc[0][2] = JTP_TILE_BELL; tileloc[0][3] = JTP_TILE_RED_GLASS;
  tileloc[0][4] = JTP_TILE_GREEN_GLASS; tileloc[0][5] = JTP_TILE_CANDLE;
  tileloc[0][6] = JTP_TILE_CANDY_BAR; tileloc[0][7] = JTP_TILE_CARROT;
  tileloc[1][0] = JTP_TILE_YELLOW_GLASS; tileloc[1][1] = JTP_TILE_WHITE_GLASS;
  tileloc[1][2] = JTP_TILE_BLACK_GLASS; tileloc[1][3] = JTP_TILE_WHIP;
  tileloc[1][4] = JTP_TILE_MACE; tileloc[1][5] = JTP_TILE_TOOLED_HORN;
  tileloc[1][6] = JTP_TILE_FORTUNE_COOKIE; tileloc[1][7] = JTP_TILE_BANANA;
  tileloc[2][0] = JTP_TILE_CRYSTAL_BALL; tileloc[2][1] = JTP_TILE_FROST_HORN;
  tileloc[2][2] = JTP_TILE_UNICORN_HORN; tileloc[2][3] = JTP_TILE_HAWAIIAN_SHIRT;
  tileloc[2][4] = JTP_TILE_CREDIT_CARD; tileloc[2][5] = JTP_TILE_MIRROR;
  tileloc[2][6] = JTP_TILE_CREAM_PIE; tileloc[2][7] = JTP_TILE_ORANGE;
  tileloc[3][0] = JTP_TILE_CROSSBOW; tileloc[3][1] = JTP_TILE_CONICAL_HAT;
  tileloc[3][2] = JTP_TILE_MAGIC_MARKER; tileloc[3][3] = JTP_TILE_STAFF;
  tileloc[3][4] = JTP_TILE_FOOD_RATION; tileloc[3][5] = JTP_TILE_PANCAKE;
  tileloc[3][6] = JTP_TILE_LEMBAS_WAFER; tileloc[3][7] = JTP_TILE_KELP_FROND;
  tileloc[4][0] = JTP_TILE_TRIPE_RATION; tileloc[4][1] = JTP_TILE_MEAT_STICK;
  tileloc[4][2] = JTP_TILE_SHURIKEN; tileloc[4][3] = JTP_TILE_STONE;
  tileloc[4][4] = JTP_TILE_PICKAXE; tileloc[4][5] = JTP_TILE_TIN;
  tileloc[4][6] = JTP_TILE_CLOVE_OF_GARLIC; tileloc[4][7] = JTP_TILE_EUCALYPTUS_LEAF;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_obj2.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(5, 8, 1, 1, JTP_OBJ_TILE_DX, JTP_OBJ_TILE_DY, tileloc);

  /* Load even more object tiles */

  tileloc[0][0] = JTP_TILE_MELON; tileloc[0][1] = JTP_TILE_SLIME_MOLD;
  tileloc[0][2] = JTP_TILE_SPRIG_OF_WOLFSBANE; tileloc[0][3] = JTP_TILE_CRAM_RATION;
  tileloc[0][4] = JTP_TILE_HUGE_CHUNK_OF_MEAT; tileloc[0][5] = JTP_TILE_MEATBALL;
  tileloc[0][6] = JTP_TILE_K_RATION; tileloc[0][7] = JTP_TILE_C_RATION;
  tileloc[1][0] = JTP_TILE_BOOMERANG; tileloc[1][1] = JTP_TILE_LUMP_OF_ROYAL_JELLY;
  tileloc[1][2] = JTP_TILE_MEAT_RING; tileloc[1][3] = JTP_TILE_DILITHIUM_CRYSTAL;
  tileloc[1][4] = JTP_TILE_DIAMOND; tileloc[1][5] = JTP_TILE_RUBY;
  tileloc[1][6] = JTP_TILE_JACINTH; tileloc[1][7] = JTP_TILE_SAPPHIRE;
  tileloc[2][0] = JTP_TILE_EMERALD; tileloc[2][1] = JTP_TILE_BLACK_OPAL;
  tileloc[2][2] = JTP_TILE_TURQUOISE; tileloc[2][3] = JTP_TILE_CITRINE;
  tileloc[2][4] = JTP_TILE_AQUAMARINE; tileloc[2][5] = JTP_TILE_AMBER;
  tileloc[2][6] = JTP_TILE_TOPAZ; tileloc[2][7] = JTP_TILE_JET;
  tileloc[3][0] = JTP_TILE_OPAL; tileloc[3][1] = JTP_TILE_CHRYSOBERYL;
  tileloc[3][2] = JTP_TILE_GARNET; tileloc[3][3] = JTP_TILE_AMETHYST;
  tileloc[3][4] = JTP_TILE_JASPER; tileloc[3][5] = JTP_TILE_FLUORITE;
  tileloc[3][6] = JTP_TILE_OBSIDIAN; tileloc[3][7] = JTP_TILE_AGATE;
  tileloc[4][0] = JTP_TILE_JADE; tileloc[4][1] = JTP_TILE_LUCKSTONE;
  tileloc[4][2] = JTP_TILE_LOADSTONE; tileloc[4][3] = JTP_TILE_FLINT;
  tileloc[4][4] = JTP_TILE_VIOLET_GLASS; tileloc[4][5] = JTP_TILE_ORANGE_GLASS;
  tileloc[4][6] = JTP_TILE_TINNING_KIT; tileloc[4][7] = JTP_TILE_FIRE_HORN;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_obj3.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(5, 8, 1, 1, JTP_OBJ_TILE_DX, JTP_OBJ_TILE_DY, tileloc);

  /* Load potion/misc object tiles */

  tileloc[0][0] = JTP_TILE_RUBY_POTION; tileloc[0][1] = JTP_TILE_PINK_POTION;
  tileloc[0][2] = JTP_TILE_ORANGE_POTION; tileloc[0][3] = JTP_TILE_YELLOW_POTION;
  tileloc[0][4] = JTP_TILE_EMERALD_POTION; tileloc[0][5] = JTP_TILE_DARK_GREEN_POTION;
  tileloc[0][6] = JTP_TILE_CYAN_POTION; tileloc[0][7] = JTP_TILE_SKY_BLUE_POTION;
  tileloc[1][0] = JTP_TILE_BRILLIANT_BLUE_POTION; tileloc[1][1] = JTP_TILE_MAGENTA_POTION;
  tileloc[1][2] = JTP_TILE_PURPLE_RED_POTION; tileloc[1][3] = JTP_TILE_PUCE_POTION;
  tileloc[1][4] = JTP_TILE_MILKY_POTION; tileloc[1][5] = JTP_TILE_SWIRLY_POTION;
  tileloc[1][6] = JTP_TILE_BUBBLY_POTION; tileloc[1][7] = JTP_TILE_SMOKY_POTION;
  tileloc[2][0] = JTP_TILE_CLOUDY_POTION; tileloc[2][1] = JTP_TILE_EFFERVESCENT_POTION;
  tileloc[2][2] = JTP_TILE_BLACK_POTION; tileloc[2][3] = JTP_TILE_GOLDEN_POTION;
  tileloc[2][4] = JTP_TILE_BROWN_POTION; tileloc[2][5] = JTP_TILE_FIZZY_POTION;
  tileloc[2][6] = JTP_TILE_DARK_POTION; tileloc[2][7] = JTP_TILE_WHITE_POTION;
  tileloc[3][0] = JTP_TILE_MURKY_POTION; tileloc[3][1] = JTP_TILE_WATER;
  tileloc[3][2] = JTP_TILE_HOLY_WATER; tileloc[3][3] = JTP_TILE_UNHOLY_WATER;
  tileloc[3][4] = JTP_TILE_SACK; tileloc[3][5] = JTP_TILE_BAG_OF_HOLDING;
  tileloc[3][6] = JTP_TILE_OILSKIN_SACK; tileloc[3][7] = JTP_TILE_BAG_OF_TRICKS;
  tileloc[4][0] = JTP_TILE_ICE_BOX; tileloc[4][1] = JTP_TILE_LARGE_BOX;
  tileloc[4][2] = JTP_TILE_UNIDENTIFIED_BAG; tileloc[4][3] = JTP_TILE_TOUCHSTONE;
  tileloc[4][4] = JTP_TILE_ROCKS; tileloc[4][5] = JTP_TILE_BROWN_GLASS;
  tileloc[4][6] = JTP_TILE_HEALTHSTONE; tileloc[4][7] = JTP_TILE_WHETSTONE;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_obj4.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(5, 8, 1, 1, JTP_OBJ_TILE_DX, JTP_OBJ_TILE_DY, tileloc);

#define JTP_MON_TILE_DX 116
#define JTP_MON_TILE_DY 126
#define JTP_MON_LARGE_TILE_DX 154
#define JTP_MON_LARGE_TILE_DY 165
#define JTP_MON_HUGE_TILE_DX 232
#define JTP_MON_HUGE_TILE_DY 252

  /* Load monster tiles */

  tileloc[0][0] = JTP_TILE_KNIGHT; tileloc[0][1] = JTP_TILE_GOBLIN;
  tileloc[0][2] = JTP_TILE_GNOME; tileloc[0][3] = JTP_TILE_FIRE_ELEMENTAL;
  tileloc[0][4] = JTP_TILE_GREEN_SLIME; tileloc[0][5] = JTP_TILE_SKELETON;
  tileloc[1][0] = JTP_TILE_EYE; tileloc[1][1] = JTP_TILE_SPIDER;
  tileloc[1][2] = JTP_TILE_HOUSECAT; tileloc[1][3] = JTP_TILE_LIZARD;
  tileloc[1][4] = JTP_TILE_LITTLE_DOG; tileloc[1][5] = JTP_TILE_TROLL;
  tileloc[2][0] = -1; tileloc[2][1] = JTP_TILE_NYMPH;
  tileloc[2][2] = JTP_TILE_WIZARD; tileloc[2][3] = JTP_TILE_VALKYRIE;
  tileloc[2][4] = JTP_TILE_RANGER; tileloc[2][5] = JTP_TILE_WATER_NYMPH;
  tileloc[3][0] = JTP_TILE_GHOST; tileloc[3][1] = JTP_TILE_WRAITH;
  tileloc[3][2] = -1; tileloc[3][3] = JTP_TILE_HUMAN_ZOMBIE;
  tileloc[3][4] = JTP_TILE_STONE_GOLEM; tileloc[3][5] = JTP_TILE_RAT;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon6.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);

  /* Load more monster tiles */

  tileloc[0][0] = JTP_TILE_ARCHEOLOGIST; tileloc[0][1] = JTP_TILE_TOURIST;
  tileloc[0][2] = JTP_TILE_ROGUE; tileloc[0][3] = JTP_TILE_PRIEST;
  tileloc[0][4] = JTP_TILE_COYOTE; tileloc[0][5] = JTP_TILE_JACKAL;
  tileloc[1][0] = JTP_TILE_GIANT_BAT; tileloc[1][1] = JTP_TILE_MOUNTAIN_CENTAUR;
  tileloc[1][2] = JTP_TILE_SOLDIER_ANT; tileloc[1][3] = JTP_TILE_BEE;
  tileloc[1][4] = JTP_TILE_YELLOW_LIGHT; tileloc[1][5] = JTP_TILE_FOX;
  tileloc[2][0] = JTP_TILE_COCKATRICE; tileloc[2][1] = JTP_TILE_KRAKEN;
  tileloc[2][2] = JTP_TILE_GIANT_EEL; tileloc[2][3] = JTP_TILE_PYROLISK;
  tileloc[2][4] = JTP_TILE_YELLOW_MOLD; tileloc[2][5] = JTP_TILE_SHARK;
  tileloc[3][0] = JTP_TILE_CHICKATRICE; tileloc[3][1] = JTP_TILE_SMALL_MIMIC;
  tileloc[3][2] = JTP_TILE_LARGE_MIMIC; tileloc[3][3] = JTP_TILE_GIANT_MIMIC;
  tileloc[3][4] = JTP_TILE_RED_MOLD; tileloc[3][5] = JTP_TILE_VIOLET_FUNGUS;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon7.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);

  /* Load even more monster tiles */

  tileloc[0][0] = JTP_TILE_ACID_BLOB; tileloc[0][1] = JTP_TILE_QUIVERING_BLOB;
  tileloc[0][2] = JTP_TILE_GELATINOUS_CUBE; tileloc[0][3] = JTP_TILE_BROWN_MOLD;
  tileloc[0][4] = JTP_TILE_LICHEN; tileloc[0][5] = JTP_TILE_GREEN_MOLD;
  tileloc[1][0] = JTP_TILE_SHRIEKER; tileloc[1][1] = JTP_TILE_STALKER;
  tileloc[1][2] = JTP_TILE_AIR_ELEMENTAL; tileloc[1][3] = JTP_TILE_EARTH_ELEMENTAL;
  tileloc[1][4] = JTP_TILE_WATER_ELEMENTAL; tileloc[1][5] = JTP_TILE_BLACK_LIGHT;
  tileloc[2][0] = JTP_TILE_ROCK_PIERCER; tileloc[2][1] = JTP_TILE_IRON_PIERCER;
  tileloc[2][2] = JTP_TILE_GLASS_PIERCER; tileloc[2][3] = JTP_TILE_DOG;
  tileloc[2][4] = JTP_TILE_LARGE_DOG; tileloc[2][5] = JTP_TILE_WATER_DEMON;
  tileloc[3][0] = JTP_TILE_GECKO; tileloc[3][1] = JTP_TILE_NEWT;
  tileloc[3][2] = JTP_TILE_SHOPKEEPER; tileloc[3][3] = JTP_TILE_GAS_SPORE;
  tileloc[3][4] = JTP_TILE_KITTEN; tileloc[3][5] = JTP_TILE_LARGE_CAT;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon8.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);

  /* Load yet more monster tiles */

  tileloc[0][0] = JTP_TILE_FREEZING_SPHERE; tileloc[0][1] = JTP_TILE_FLAMING_SPHERE;
  tileloc[0][2] = JTP_TILE_SHOCKING_SPHERE; tileloc[0][3] = JTP_TILE_PONY;
  tileloc[0][4] = JTP_TILE_HORSE; tileloc[0][5] = JTP_TILE_WARHORSE;
  tileloc[1][0] = JTP_TILE_ROTHE; tileloc[1][1] = JTP_TILE_GNOME;
  tileloc[1][2] = JTP_TILE_GREEN_ELF; tileloc[1][3] = JTP_TILE_DWARF;
  tileloc[1][4] = JTP_TILE_WATER_MOCCASIN; tileloc[1][5] = JTP_TILE_MANES;
  tileloc[2][0] = JTP_TILE_HOBBIT; tileloc[2][1] = JTP_TILE_BLACK_UNICORN;
  tileloc[2][2] = JTP_TILE_GRAY_UNICORN; tileloc[2][3] = JTP_TILE_WHITE_UNICORN;
  tileloc[2][4] = JTP_TILE_GIANT_ANT; tileloc[2][5] = JTP_TILE_FIRE_ANT;
  tileloc[3][0] = JTP_TILE_ELVENKING; tileloc[3][1] = JTP_TILE_ELF_LORD;
  tileloc[3][2] = JTP_TILE_GREY_ELF; tileloc[3][3] = JTP_TILE_WOODLAND_ELF;
  tileloc[3][4] = JTP_TILE_ELF; tileloc[3][5] = JTP_TILE_ROCK_MOLE;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon9.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);

  /* Load still more monster tiles */

  tileloc[0][0] = JTP_TILE_DWARF_LORD; tileloc[0][1] = JTP_TILE_DWARF_KING;
  tileloc[0][2] = JTP_TILE_GNOME_LORD; tileloc[0][3] = JTP_TILE_GNOME_KING;
  tileloc[0][4] = JTP_TILE_GNOMISH_WIZARD; tileloc[0][5] = JTP_TILE_ORC;
  tileloc[1][0] = JTP_TILE_HILL_ORC; tileloc[1][1] = JTP_TILE_MORDOR_ORC;
  tileloc[1][2] = JTP_TILE_URUK_HAI; tileloc[1][3] = JTP_TILE_HOBGOBLIN;
  tileloc[1][4] = JTP_TILE_BUGBEAR; tileloc[1][5] = JTP_TILE_KOBOLD;
  tileloc[2][0] = JTP_TILE_LARGE_KOBOLD; tileloc[2][1] = JTP_TILE_KOBOLD_SHAMAN;
  tileloc[2][2] = JTP_TILE_KOBOLD_LORD; tileloc[2][3] = JTP_TILE_ORC_CAPTAIN;
  tileloc[2][4] = JTP_TILE_ORC_SHAMAN; tileloc[2][5] = JTP_TILE_LEPRECHAUN;
  tileloc[3][0] = JTP_TILE_GARTER_SNAKE; tileloc[3][1] = JTP_TILE_SNAKE;
  tileloc[3][2] = JTP_TILE_PIT_VIPER; tileloc[3][3] = JTP_TILE_PYTHON;
  tileloc[3][4] = JTP_TILE_COBRA; tileloc[3][5] = JTP_TILE_WUMPUS;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon0.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);

  /* Still loading more monster tiles */

  tileloc[0][0] = JTP_TILE_KOBOLD_ZOMBIE; tileloc[0][1] = JTP_TILE_GNOME_ZOMBIE;
  tileloc[0][2] = JTP_TILE_DWARF_ZOMBIE; tileloc[0][3] = JTP_TILE_ORC_ZOMBIE;
  tileloc[0][4] = JTP_TILE_ELF_ZOMBIE; tileloc[0][5] = JTP_TILE_KOBOLD_MUMMY;
  tileloc[1][0] = JTP_TILE_GNOME_MUMMY; tileloc[1][1] = JTP_TILE_DWARF_MUMMY;
  tileloc[1][2] = JTP_TILE_ORC_MUMMY; tileloc[1][3] = JTP_TILE_HUMAN_MUMMY;
  tileloc[1][4] = JTP_TILE_ELF_MUMMY; tileloc[1][5] = JTP_TILE_HOMUNCULUS;
  tileloc[2][0] = JTP_TILE_IMP; tileloc[2][1] = JTP_TILE_LEMURE;
  tileloc[2][2] = JTP_TILE_QUASIT; tileloc[2][3] = JTP_TILE_TENGU;
  tileloc[2][4] = JTP_TILE_ORACLE; tileloc[2][5] = JTP_TILE_LAWFUL_PRIEST;
  tileloc[3][0] = JTP_TILE_CHAOTIC_PRIEST; tileloc[3][1] = JTP_TILE_NEUTRAL_PRIEST;
  tileloc[3][2] = JTP_TILE_UNALIGNED_PRIEST; tileloc[3][3] = JTP_TILE_WATCHMAN;
  tileloc[3][4] = JTP_TILE_WATCH_CAPTAIN; tileloc[3][5] = JTP_TILE_SOLDIER;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon1.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);

  /* Wow, this is a lot of monster tiles! */

  tileloc[0][0] = JTP_TILE_SERGEANT; tileloc[0][1] = JTP_TILE_LIEUTENANT;
  tileloc[0][2] = JTP_TILE_CAPTAIN; tileloc[0][3] = JTP_TILE_GRID_BUG;
  tileloc[0][4] = JTP_TILE_XAN; tileloc[0][5] = JTP_TILE_GARGOYLE;
  tileloc[1][0] = JTP_TILE_WINGED_GARGOYLE; tileloc[1][1] = JTP_TILE_DINGO;
  tileloc[1][2] = JTP_TILE_WOLF; tileloc[1][3] = JTP_TILE_WEREWOLF;
  tileloc[1][4] = JTP_TILE_WARG; tileloc[1][5] = JTP_TILE_WINTER_WOLF_CUB;
  tileloc[2][0] = JTP_TILE_WINTER_WOLF; tileloc[2][1] = JTP_TILE_HELL_HOUND_PUP;
  tileloc[2][2] = JTP_TILE_HELL_HOUND; tileloc[2][3] = JTP_TILE_JAGUAR;
  tileloc[2][4] = JTP_TILE_LYNX; tileloc[2][5] = JTP_TILE_PANTHER;
  tileloc[3][0] = JTP_TILE_TIGER; tileloc[3][1] = JTP_TILE_MIND_FLAYER;
  tileloc[3][2] = JTP_TILE_MASTER_MIND_FLAYER; tileloc[3][3] = JTP_TILE_LICH;
  tileloc[3][4] = JTP_TILE_DEMILICH; tileloc[3][5] = JTP_TILE_MASTER_LICH;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon2.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);

  /* Haven't we had enough monster tiles yet? */

  tileloc[0][0] = JTP_TILE_ARCH_LICH; tileloc[0][1] = JTP_TILE_GUARDIAN_NAGA;
  tileloc[0][2] = JTP_TILE_GUARDIAN_NAGA_HATCHLING; tileloc[0][3] = JTP_TILE_GOLDEN_NAGA;
  tileloc[0][4] = JTP_TILE_GOLDEN_NAGA_HATCHLING; tileloc[0][5] = JTP_TILE_RED_NAGA;
  tileloc[1][0] = JTP_TILE_RED_NAGA_HATCHLING; tileloc[1][1] = JTP_TILE_BLACK_NAGA;
  tileloc[1][2] = JTP_TILE_BLACK_NAGA_HATCHLING; tileloc[1][3] = JTP_TILE_RUST_MONSTER;
  tileloc[1][4] = JTP_TILE_GREMLIN; tileloc[1][5] = JTP_TILE_BABY_PURPLE_WORM;
  tileloc[2][0] = JTP_TILE_MONKEY; tileloc[2][1] = JTP_TILE_APE;
  tileloc[2][2] = JTP_TILE_OWLBEAR; tileloc[2][3] = JTP_TILE_YETI;
  tileloc[2][4] = JTP_TILE_CARNIVOROUS_APE; tileloc[2][5] = JTP_TILE_STRAW_GOLEM;
  tileloc[3][0] = JTP_TILE_PAPER_GOLEM; tileloc[3][1] = JTP_TILE_ROPE_GOLEM;
  tileloc[3][2] = JTP_TILE_GOLD_GOLEM; tileloc[3][3] = JTP_TILE_LEATHER_GOLEM;
  tileloc[3][4] = JTP_TILE_WOOD_GOLEM; tileloc[3][5] = JTP_TILE_FLESH_GOLEM;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon3.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);

  /* Load tall monster tiles */

  tileloc[0][0] = JTP_TILE_GIANT; tileloc[0][1] = JTP_TILE_STONE_GIANT;
  tileloc[0][2] = JTP_TILE_HILL_GIANT; tileloc[0][3] = JTP_TILE_FROST_GIANT;
  tileloc[0][4] = JTP_TILE_FIRE_GIANT; tileloc[0][5] = JTP_TILE_STORM_GIANT;
  tileloc[1][0] = JTP_TILE_ETTIN; tileloc[1][1] = JTP_TILE_TITAN;
  tileloc[1][2] = JTP_TILE_MINOTAUR; tileloc[1][3] = JTP_TILE_GIANT_ZOMBIE;
  tileloc[1][4] = JTP_TILE_ETTIN_ZOMBIE; tileloc[1][5] = JTP_TILE_GIANT_MUMMY;
  tileloc[2][0] = JTP_TILE_ETTIN_MUMMY; tileloc[2][1] = JTP_TILE_OGRE;
  tileloc[2][2] = JTP_TILE_OGRE_LORD; tileloc[2][3] = JTP_TILE_OGRE_KING;
  tileloc[2][4] = JTP_TILE_DISENCHANTER; tileloc[2][5] = JTP_TILE_SASQUATCH;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon4.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(3, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_LARGE_TILE_DY, tileloc);

  /* Load tall and wide monster tiles */

  tileloc[0][0] = JTP_TILE_SUCCUBUS; tileloc[0][1] = JTP_TILE_INCUBUS;
  tileloc[0][2] = JTP_TILE_BABY_YELLOW_DRAGON; tileloc[0][3] = JTP_TILE_BABY_WHITE_DRAGON;
  tileloc[0][4] = JTP_TILE_BABY_SILVER_DRAGON; 
  tileloc[1][0] = JTP_TILE_BABY_RED_DRAGON; tileloc[1][1] = JTP_TILE_BABY_BLACK_DRAGON;
  tileloc[1][2] = JTP_TILE_BABY_GRAY_DRAGON; tileloc[1][3] = JTP_TILE_BABY_GREEN_DRAGON;
  tileloc[1][4] = JTP_TILE_BABY_ORANGE_DRAGON; 
  tileloc[2][0] = JTP_TILE_BABY_BLUE_DRAGON; tileloc[2][1] = JTP_TILE_PURPLE_WORM;
  tileloc[2][2] = JTP_TILE_LONG_WORM_TAIL; tileloc[2][3] = JTP_TILE_LONG_WORM;
  tileloc[2][4] = JTP_TILE_BABY_LONG_WORM; 

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon5.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(3, 5, 1, 1, JTP_MON_LARGE_TILE_DX, JTP_MON_LARGE_TILE_DY, tileloc);

  /* Load more tall monster tiles */

  tileloc[0][0] = JTP_TILE_MUMAK; tileloc[0][1] = JTP_TILE_CLAY_GOLEM;
  tileloc[0][2] = JTP_TILE_STONE_GOLEM; tileloc[0][3] = JTP_TILE_GLASS_GOLEM;
  tileloc[0][4] = JTP_TILE_IRON_GOLEM; tileloc[0][5] = -1;
  tileloc[1][0] = -1; tileloc[1][1] = -1;
  tileloc[1][2] = -1; tileloc[1][3] = -1;
  tileloc[1][4] = -1; tileloc[1][5] = -1;
  tileloc[2][0] = -1; tileloc[2][1] = -1;
  tileloc[2][2] = -1; tileloc[2][3] = -1;
  tileloc[2][4] = -1; tileloc[2][5] = -1;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon16.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(3, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_LARGE_TILE_DY, tileloc);

  /* Load more tall and wide monster tiles */

  tileloc[0][0] = JTP_TILE_ZRUTY; tileloc[0][1] = JTP_TILE_LEOCROTTA;
  tileloc[0][2] = JTP_TILE_TITANOTHERE; tileloc[0][3] = JTP_TILE_XORN;
  tileloc[0][4] = -1; 
  tileloc[1][0] = -1; tileloc[1][1] = -1;
  tileloc[1][2] = -1; tileloc[1][3] = -1;
  tileloc[1][4] = -1; 
  tileloc[2][0] = -1; tileloc[2][1] = -1;
  tileloc[2][2] = -1; tileloc[2][3] = -1;
  tileloc[2][4] = -1; 

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon18.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(3, 5, 1, 1, JTP_MON_LARGE_TILE_DX, JTP_MON_LARGE_TILE_DY, tileloc);

  /* Load huge monster tiles */

  tileloc[0][0] = JTP_TILE_SILVER_DRAGON; tileloc[0][1] = JTP_TILE_BLACK_DRAGON;
  tileloc[0][2] = JTP_TILE_WHITE_DRAGON; 
  tileloc[1][0] = JTP_TILE_BALUCHITHERIUM; tileloc[1][1] = JTP_TILE_MASTADON;
  tileloc[1][2] = JTP_TILE_WIZARD_OF_YENDOR; 

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon14.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(2, 3, 1, 1, JTP_MON_HUGE_TILE_DX, JTP_MON_HUGE_TILE_DY, tileloc);

  /* Load huge monster tiles */

  tileloc[0][0] = JTP_TILE_RED_DRAGON; tileloc[0][1] = JTP_TILE_GREEN_DRAGON;
  tileloc[0][2] = JTP_TILE_ORANGE_DRAGON; 
  tileloc[1][0] = JTP_TILE_YELLOW_DRAGON; tileloc[1][1] = JTP_TILE_BLUE_DRAGON;
  tileloc[1][2] = JTP_TILE_GRAY_DRAGON; 

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_mon15.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(2, 3, 1, 1, JTP_MON_HUGE_TILE_DX, JTP_MON_HUGE_TILE_DY, tileloc);

  /* Tiles for the rogue level... hehehe  :)  */

  tileloc[0][0] = JTP_TILE_ROGUE_LEVEL_A; tileloc[0][1] = JTP_TILE_ROGUE_LEVEL_B;
  tileloc[0][2] = JTP_TILE_ROGUE_LEVEL_C; tileloc[0][3] = JTP_TILE_ROGUE_LEVEL_D;
  tileloc[0][4] = JTP_TILE_ROGUE_LEVEL_E; tileloc[0][5] = JTP_TILE_ROGUE_LEVEL_F;
  tileloc[1][0] = JTP_TILE_ROGUE_LEVEL_G; tileloc[1][1] = JTP_TILE_ROGUE_LEVEL_H;
  tileloc[1][2] = JTP_TILE_ROGUE_LEVEL_I; tileloc[1][3] = JTP_TILE_ROGUE_LEVEL_J;
  tileloc[1][4] = JTP_TILE_ROGUE_LEVEL_K; tileloc[1][5] = JTP_TILE_ROGUE_LEVEL_L;
  tileloc[2][0] = JTP_TILE_ROGUE_LEVEL_M; tileloc[2][1] = JTP_TILE_ROGUE_LEVEL_N;
  tileloc[2][2] = JTP_TILE_ROGUE_LEVEL_O; tileloc[2][3] = JTP_TILE_ROGUE_LEVEL_P;
  tileloc[2][4] = JTP_TILE_ROGUE_LEVEL_Q; tileloc[2][5] = JTP_TILE_ROGUE_LEVEL_R;
  tileloc[3][0] = JTP_TILE_ROGUE_LEVEL_S; tileloc[3][1] = JTP_TILE_ROGUE_LEVEL_T;
  tileloc[3][2] = JTP_TILE_ROGUE_LEVEL_U; tileloc[3][3] = JTP_TILE_ROGUE_LEVEL_V;
  tileloc[3][4] = JTP_TILE_ROGUE_LEVEL_W; tileloc[3][5] = JTP_TILE_ROGUE_LEVEL_X;

  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_monmisc1.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);

  /* And, of course, the last two.  */

  tileloc[0][0] = JTP_TILE_ROGUE_LEVEL_Y; tileloc[0][1] = JTP_TILE_ROGUE_LEVEL_Z;
  tileloc[0][2] = -1; tileloc[0][3] = -1;
  tileloc[0][4] = -1; tileloc[0][5] = -1;
  tileloc[1][0] = -1; tileloc[1][1] = -1;
  tileloc[1][2] = -1; tileloc[1][3] = -1;
  tileloc[1][4] = -1; tileloc[1][5] = -1;
  tileloc[2][0] = -1; tileloc[2][1] = -1;
  tileloc[2][2] = -1; tileloc[2][3] = -1;
  tileloc[2][4] = -1; tileloc[2][5] = -1;
  tileloc[3][0] = -1; tileloc[3][1] = -1;
  tileloc[3][2] = -1; tileloc[3][3] = -1;
  tileloc[3][4] = -1; tileloc[3][5] = -1;
  
  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "jtp_monmisc2.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(4, 6, 1, 1, JTP_MON_TILE_DX, JTP_MON_TILE_DY, tileloc);
  
  /* Load the "engulfed" graphics */

  tileloc[0][0] = JTP_TILE_ENGULF_OCHRE_JELLY; tileloc[0][1] = JTP_TILE_ENGULF_LURKER_ABOVE;
  tileloc[0][2] = JTP_TILE_ENGULF_TRAPPER; tileloc[0][3] = JTP_TILE_ENGULF_PURPLE_WORM;
  tileloc[1][0] = JTP_TILE_ENGULF_DUST_VORTEX; tileloc[1][1] = JTP_TILE_ENGULF_ICE_VORTEX;
  tileloc[1][2] = JTP_TILE_ENGULF_ENERGY_VORTEX; tileloc[1][3] = JTP_TILE_ENGULF_STEAM_VORTEX;
  tileloc[2][0] = JTP_TILE_ENGULF_FIRE_VORTEX; tileloc[2][1] = JTP_TILE_ENGULF_FOG_CLOUD;
  tileloc[2][2] = JTP_TILE_ENGULF_AIR_ELEMENTAL; tileloc[2][3] = JTP_TILE_ENGULF_YEENOGHU;
  
  filename = jtp_make_filename(JTP_GRAPHICS_DIRECTORY, NULL, "engulf.pcx");
  all_ok &= jtp_load_PCX(0, 0, filename, FALSE) != JTP_PCX_FAILURE;
  setlastpcx(filename);
  free(filename);
  jtp_get_tile_group(3, 4, 1, 1, 178, 194, tileloc);

  /* Initialize map */

  jtp_map_width = JTP_MAP_WIDTH;
  jtp_map_height = JTP_MAP_HEIGHT;

  jtp_mapglyph_cmap = (int **)malloc(JTP_MAP_HEIGHT*sizeof(int *));
  jtp_mapglyph_obj = (int **)malloc(JTP_MAP_HEIGHT*sizeof(int *));
  jtp_mapglyph_mon = (int **)malloc(JTP_MAP_HEIGHT*sizeof(int *));
  jtp_mapglyph_special = (unsigned int **)malloc(JTP_MAP_HEIGHT*sizeof(int *));

  jtp_maptile_cmap = (jtp_tilestats ***)malloc(JTP_MAP_HEIGHT*sizeof(jtp_tilestats **));
  jtp_maptile_obj = (jtp_tilestats ***)malloc(JTP_MAP_HEIGHT*sizeof(jtp_tilestats **));
  jtp_maptile_mon = (jtp_tilestats ***)malloc(JTP_MAP_HEIGHT*sizeof(jtp_tilestats **));
  jtp_maptile_wall = (jtp_wall_style **)malloc(JTP_MAP_HEIGHT*sizeof(jtp_wall_style *));
  jtp_maptile_floor_edge = (jtp_floor_edge_style **)malloc(JTP_MAP_HEIGHT*sizeof(jtp_floor_edge_style *));

  jtp_map_light = (int **)malloc(JTP_MAP_HEIGHT*sizeof(int *));
  jtp_room_indices = (int **)malloc(JTP_MAP_HEIGHT*sizeof(int *));

  if ((!jtp_mapglyph_cmap) || (!jtp_mapglyph_obj) || (!jtp_mapglyph_mon) ||
      (!jtp_maptile_cmap) || (!jtp_maptile_obj) || (!jtp_maptile_mon) ||
      (!jtp_maptile_wall) || (!jtp_maptile_floor_edge) ||
      (!jtp_map_light) || (!jtp_room_indices))
  {
    OOM(1);
  }
  
  for (i = 0; i < JTP_MAP_HEIGHT; i++)
  {
    jtp_mapglyph_cmap[i] = (int *)malloc(JTP_MAP_WIDTH*sizeof(int));
    jtp_mapglyph_obj[i] = (int *)malloc(JTP_MAP_WIDTH*sizeof(int));
    jtp_mapglyph_mon[i] = (int *)malloc(JTP_MAP_WIDTH*sizeof(int));
    jtp_mapglyph_special[i] = (unsigned int *)malloc(JTP_MAP_WIDTH*sizeof(unsigned int));

    jtp_maptile_cmap[i] = (jtp_tilestats **)malloc(JTP_MAP_WIDTH*sizeof(jtp_tilestats *));
    jtp_maptile_obj[i] = (jtp_tilestats **)malloc(JTP_MAP_WIDTH*sizeof(jtp_tilestats *));
    jtp_maptile_mon[i] = (jtp_tilestats **)malloc(JTP_MAP_WIDTH*sizeof(jtp_tilestats *));
    jtp_maptile_wall[i] = (jtp_wall_style *)malloc(JTP_MAP_WIDTH*sizeof(jtp_wall_style));
    jtp_maptile_floor_edge[i] = (jtp_floor_edge_style *)malloc(JTP_MAP_WIDTH*sizeof(jtp_floor_edge_style));

    jtp_map_light[i] = (int *)malloc(JTP_MAP_WIDTH*sizeof(int));
    jtp_room_indices[i] = (int *)malloc(JTP_MAP_WIDTH*sizeof(int));

    if ((!jtp_mapglyph_cmap[i]) || (!jtp_mapglyph_obj[i]) || (!jtp_mapglyph_mon[i]) ||
        (!jtp_maptile_cmap[i]) || (!jtp_maptile_obj[i]) || (!jtp_maptile_mon[i]) ||
        (!jtp_maptile_wall[i]) || (!jtp_maptile_floor_edge[i]) ||
        (!jtp_map_light[i]) || (!jtp_room_indices[i]))
    {
      OOM(1);
    }
    
    for (j = 0; j < JTP_MAP_WIDTH; j++)
    {
      jtp_mapglyph_cmap[i][j] = JTP_WINCONTENT_GLYPH_UNEXPLORED;
      jtp_mapglyph_obj[i][j] = JTP_WINCONTENT_GLYPH_UNEXPLORED;
      jtp_mapglyph_mon[i][j] = JTP_WINCONTENT_GLYPH_UNEXPLORED;
      jtp_mapglyph_special[i][j] = 0;
      jtp_map_light[i][j] = 0;
    }
  }

  /* Initialize random number generator */
  srand(time(NULL));

  /* Initialize light sources */
  jtp_nlights = 1;  /* Hero carries a small light */

  jtp_n_floor_decors = 0;
  jtp_floor_decors = NULL;
  jtp_cur_dlevel = -1;
  jtp_prev_dlevel = -1;
  
  jtp_move_length = 0;
  jtp_is_backpack_shortcut_active = 0;

  jtp_map_x = JTP_MAP_WIDTH/2;
  jtp_map_y = JTP_MAP_HEIGHT/2;
  jtp_map_changed = 1;

  /* Clean up */
  for (i = 0; i < 20; i++)
    free(tileloc[i]);
  free(tileloc);
  
  return all_ok;
}

static int jtp_cmap_to_map_symbol(int cur_glyph)
{

  int cur_symbol = -1;

  if (glyph_is_trap(cur_glyph + GLYPH_CMAP_OFF)) /* trap */
    cur_symbol = JTP_MAP_SYMBOL_TRAP;
  else switch (cur_glyph)
  {
    case JTP_WINCONTENT_GLYPH_UNEXPLORED:
    case JTP_WINCONTENT_GLYPH_NOT_VISIBLE:
    case S_stone:
      cur_symbol = -1; break;
    case S_vwall: case S_hwall:
    case S_tlcorn: case S_trcorn: case S_blcorn: case S_brcorn:
    case S_crwall: case S_tuwall: case S_tdwall: case S_tlwall: case S_trwall:
      cur_symbol = JTP_MAP_SYMBOL_WALL; break;
    case S_room: case S_corr: case S_litcorr: 
      cur_symbol = JTP_MAP_SYMBOL_FLOOR; break;
    case S_upstair:
      cur_symbol = JTP_MAP_SYMBOL_UP; break;
    case S_dnstair:
      cur_symbol = JTP_MAP_SYMBOL_DOWN; break;
    case S_ndoor:
      cur_symbol = JTP_MAP_SYMBOL_FLOOR; break;
    case S_vodoor: case S_hodoor: case S_vcdoor: case S_hcdoor:
    case S_vodbridge: case S_hodbridge: case S_vcdbridge: case S_hcdbridge:
      cur_symbol = JTP_MAP_SYMBOL_DOOR; break;
    default:
      cur_symbol = JTP_MAP_SYMBOL_CMAP; break;
  }
  return(cur_symbol);
}

static int jtp_object_to_map_symbol(int cur_glyph)
{
  if (cur_glyph == CORPSE)
  {
    /* Dead monster, currently not differentiated by monster type */
    return(JTP_MAP_SYMBOL_OBJECT);
  }
  else if ((cur_glyph >= 0) && (cur_glyph < NUM_OBJECTS))
    return(JTP_MAP_SYMBOL_OBJECT);  
  return(-1);
}

static int jtp_monster_to_map_symbol(int cur_glyph)
{
  if ((cur_glyph >= 0) && (cur_glyph < NUMMONS))
    return(JTP_MAP_SYMBOL_MONSTER);
  return(-1);
}



static int jtp_monster_to_tile(int cur_glyph)
{
#if defined(VULTURESEYE) || (defined(VULTURESCLAW) && defined(REINCARNATION))
  if (Is_rogue_level(&u.uz))
  {
      switch (cur_glyph)
      {
          case PM_COUATL : case PM_ALEAX : case PM_ANGEL :
          case PM_KI_RIN : case PM_ARCHON :
              return JTP_TILE_ROGUE_LEVEL_A;
              
          case PM_GIANT_BAT : case PM_RAVEN :
          case PM_VAMPIRE_BAT : case PM_BAT :
              return JTP_TILE_ROGUE_LEVEL_B;
              
          case PM_PLAINS_CENTAUR : case PM_FOREST_CENTAUR :
          case PM_MOUNTAIN_CENTAUR :
              return JTP_TILE_ROGUE_LEVEL_C;

          case PM_BABY_GRAY_DRAGON : case PM_BABY_SILVER_DRAGON :
          case PM_BABY_RED_DRAGON :
          case PM_BABY_WHITE_DRAGON : case PM_BABY_ORANGE_DRAGON :
          case PM_BABY_BLACK_DRAGON : case PM_BABY_BLUE_DRAGON :
          case PM_BABY_GREEN_DRAGON : case PM_BABY_YELLOW_DRAGON :
          case PM_GRAY_DRAGON : case PM_SILVER_DRAGON :
          case PM_RED_DRAGON :
          case PM_WHITE_DRAGON : case PM_ORANGE_DRAGON :
          case PM_BLACK_DRAGON : case PM_BLUE_DRAGON :
          case PM_GREEN_DRAGON : case PM_YELLOW_DRAGON :
              return JTP_TILE_ROGUE_LEVEL_D;

          case PM_STALKER : case PM_AIR_ELEMENTAL :
          case PM_FIRE_ELEMENTAL: case PM_EARTH_ELEMENTAL :
          case PM_WATER_ELEMENTAL :
              return JTP_TILE_ROGUE_LEVEL_E;

          case PM_LICHEN : case PM_BROWN_MOLD :
          case PM_YELLOW_MOLD : case PM_GREEN_MOLD :
          case PM_RED_MOLD : case PM_SHRIEKER :
          case PM_VIOLET_FUNGUS :
              return JTP_TILE_ROGUE_LEVEL_F;

          case PM_GNOME : case PM_GNOME_LORD :
          case PM_GNOMISH_WIZARD : case PM_GNOME_KING :
              return JTP_TILE_ROGUE_LEVEL_G;

          case PM_GIANT : case PM_STONE_GIANT :
          case PM_HILL_GIANT : case PM_FIRE_GIANT :
          case PM_FROST_GIANT : case PM_STORM_GIANT :
          case PM_ETTIN : case PM_TITAN : case PM_MINOTAUR :
              return JTP_TILE_ROGUE_LEVEL_H;

          case 999990 :	//None
              return JTP_TILE_ROGUE_LEVEL_I;

          case PM_JABBERWOCK :
              return JTP_TILE_ROGUE_LEVEL_J;

          case PM_KEYSTONE_KOP : case PM_KOP_SERGEANT :
          case PM_KOP_LIEUTENANT : case PM_KOP_KAPTAIN :
              return JTP_TILE_ROGUE_LEVEL_K;

          case PM_LICH : case PM_DEMILICH :
          case PM_MASTER_LICH : case PM_ARCH_LICH :
              return JTP_TILE_ROGUE_LEVEL_L;

          case PM_KOBOLD_MUMMY : case PM_GNOME_MUMMY :
          case PM_ORC_MUMMY : case PM_DWARF_MUMMY :
          case PM_ELF_MUMMY : case PM_HUMAN_MUMMY :
          case PM_ETTIN_MUMMY : case PM_GIANT_MUMMY :
              return JTP_TILE_ROGUE_LEVEL_M;

          case PM_RED_NAGA_HATCHLING :
          case PM_BLACK_NAGA_HATCHLING :
          case PM_GOLDEN_NAGA_HATCHLING :
          case PM_GUARDIAN_NAGA_HATCHLING :
          case PM_RED_NAGA : case PM_BLACK_NAGA :
          case PM_GOLDEN_NAGA : case PM_GUARDIAN_NAGA :
              return JTP_TILE_ROGUE_LEVEL_N;

          case PM_OGRE : case PM_OGRE_LORD :
          case PM_OGRE_KING :
              return JTP_TILE_ROGUE_LEVEL_O;

          case PM_GRAY_OOZE : case PM_BROWN_PUDDING :
          case PM_BLACK_PUDDING : case PM_GREEN_SLIME :
              return JTP_TILE_ROGUE_LEVEL_P;

          case PM_QUANTUM_MECHANIC :
              return JTP_TILE_ROGUE_LEVEL_Q;

          case PM_RUST_MONSTER : case PM_DISENCHANTER :
              return JTP_TILE_ROGUE_LEVEL_R;

          case PM_GARTER_SNAKE : case PM_SNAKE :
          case PM_WATER_MOCCASIN : case PM_PIT_VIPER :
          case PM_PYTHON : case PM_COBRA :
              return JTP_TILE_ROGUE_LEVEL_S;

          case PM_TROLL : case PM_ICE_TROLL :
          case PM_ROCK_TROLL : case PM_WATER_TROLL :
          case PM_OLOG_HAI :
              return JTP_TILE_ROGUE_LEVEL_T;

          case PM_UMBER_HULK :
              return JTP_TILE_ROGUE_LEVEL_U;

          case PM_VAMPIRE : case PM_VAMPIRE_LORD :
              return JTP_TILE_ROGUE_LEVEL_V;

          case PM_BARROW_WIGHT : case PM_WRAITH :
          case PM_NAZGUL :
              return JTP_TILE_ROGUE_LEVEL_W;

          case PM_XORN :
              return JTP_TILE_ROGUE_LEVEL_X;

          case PM_MONKEY : case PM_APE : case PM_OWLBEAR :
          case PM_YETI : case PM_CARNIVOROUS_APE :
          case PM_SASQUATCH :
              return JTP_TILE_ROGUE_LEVEL_Y;

          case PM_KOBOLD_ZOMBIE : case PM_GNOME_ZOMBIE :
          case PM_ORC_ZOMBIE : case PM_DWARF_ZOMBIE :
          case PM_ELF_ZOMBIE : case PM_HUMAN_ZOMBIE :
          case PM_ETTIN_ZOMBIE : case PM_GIANT_ZOMBIE :
              return JTP_TILE_ROGUE_LEVEL_Z;
          default:
          {
              if ((cur_glyph >= 0) && (cur_glyph < NUMMONS))
              {
                  return(jtp_montiles[cur_glyph]);
              }
              else
                  return(JTP_TILE_INVALID);
          }
      }
  }
  else
#endif
  if ((cur_glyph >= 0) && (cur_glyph < NUMMONS))
    return(jtp_montiles[cur_glyph]);
  else return(JTP_TILE_INVALID);
}

static int jtp_object_to_tile(int cur_glyph)
{
  if (cur_glyph == CORPSE)
  {
    /* Dead monster, currently not differentiated by monster type */
    return(JTP_TILE_BONES);
  }
  else if ((cur_glyph >= 0) && (cur_glyph < NUM_OBJECTS))
  {
    return(jtp_objtiles[cur_glyph]);  
  }
  return(JTP_TILE_INVALID);
}

/*
 * Convert wall tile index (ie. wall type) to an associated decoration style.
 */
static int jtp_get_wall_decor(
  int walltile,
  int wally, int wallx,
  int floory, int floorx
)
{
  switch (walltile)
  {
    case JTP_TILE_WALL_ROUGH: 
      return(JTP_WALL_STYLE_ROUGH); 
      break;
    case JTP_TILE_WALL_BRICK:
      switch(jtp_room_indices[floory][floorx] % 4)
      {
        case 0: return(JTP_WALL_STYLE_STUCCO); break;
        case 1: return(JTP_WALL_STYLE_BRICK + ((wally*wallx+wally+wallx)%5)); break;
        case 2: return(JTP_WALL_STYLE_VINE_COVERED); break;
        case 3: return(JTP_WALL_STYLE_MARBLE); break;
        default: return(JTP_WALL_STYLE_BRICK); break;
      }
      break;
    case JTP_TILE_WALL_DARK:
      return JTP_WALL_STYLE_DARK;
    case JTP_TILE_WALL_LIGHT:
      return JTP_WALL_STYLE_LIGHT;
    default:
      return(JTP_WALL_STYLE_BRICK); 
      break;
  }
}

/*
 * Convert floor tile index (ie. floor type) to an associated decoration style.
 */
static int jtp_get_floor_decor(
  int floorstyle,
  int floory, int floorx
)
{
#if defined(VULTURESEYE) || (defined(VULTURESCLAW) && defined(REINCARNATION))
  if (Is_rogue_level(&u.uz))
    return JTP_FLOOR_STYLE_DARK;
#endif

  switch (floorstyle)
  {
    case JTP_TILE_FLOOR_ROUGH: 
      return(JTP_FLOOR_STYLE_ROUGH); 
      break;
    case JTP_TILE_FLOOR_ROUGH_LIT:
      return(JTP_FLOOR_STYLE_ROUGH_LIT);
      break;
    case JTP_TILE_FLOOR_COBBLESTONE:
      switch(jtp_room_indices[floory][floorx] % 4)
      {
        case 0: return(JTP_FLOOR_STYLE_CERAMIC); break;
        case 1: return(JTP_FLOOR_STYLE_COBBLESTONE); break;
        case 2: return(JTP_FLOOR_STYLE_MOSS_COVERED); break;
        case 3: return(JTP_FLOOR_STYLE_MARBLE); break;
        default: return(JTP_FLOOR_STYLE_COBBLESTONE); break;
      }
      break;
    case JTP_TILE_FLOOR_WATER:
      return(JTP_FLOOR_STYLE_WATER);
      break;
    case JTP_TILE_FLOOR_ICE:
      return(JTP_FLOOR_STYLE_ICE);
      break;
    case JTP_TILE_FLOOR_AIR:
      return(JTP_FLOOR_STYLE_AIR);
      break;
    case JTP_TILE_FLOOR_LAVA:
      return(JTP_FLOOR_STYLE_LAVA);
      break;
    case JTP_TILE_FLOOR_DARK:
      return(JTP_FLOOR_STYLE_DARK);
      break;
    default:
      return(JTP_FLOOR_STYLE_COBBLESTONE); 
      break;
  }
}

static void jtp_calculate_lights(void)
{
  int i, j, k, dx, dy;
  double temp_dist;
  double temp_lightlevel;
  double lightlevel;

  /* The hero carries a small light */
  jtp_lights[0].x = u.ux;
  jtp_lights[0].y = u.uy;
  jtp_lights[0].radius = 1.0;

  for (i = JTP_MAP_HEIGHT-1; i >= 0; i--)
    for (j = JTP_MAP_WIDTH-1; j >= 1; j--)
    {
      lightlevel = JTP_AMBIENT_LIGHT;
      for (k = jtp_nlights-1; k >= 0; k--)
      {
        dx = j - jtp_lights[k].x;
        if (dx > 16 || dx < -16)
          continue;
        dy = i - jtp_lights[k].y;
        if (dy > 16 || dy < -16)
          continue;

	/* temp_dist is the square of the straight line distance between i,j and the
	 * light. We subtract temp_dist directly without taking the root, because
	 * that gives us exponential dropoff.
	 * The scaling factor radius*5 brings temp_lightlevel down to ambient light level
	 * after about 16 squares */
        temp_dist = ((dx * dx) + (dy * dy));
        temp_lightlevel = JTP_MAX_SHADES - temp_dist/(jtp_lights[k].radius*5);
        lightlevel = (lightlevel > temp_lightlevel) ? lightlevel : temp_lightlevel;
      }

      if (lightlevel > JTP_MAX_SHADES-1) lightlevel = JTP_MAX_SHADES-1;
      jtp_map_light[i][j] = lightlevel;
    }
}

static void jtp_convert_map_objects(void)
{
  int i, j;
  int cur_glyph, cur_tile;
  for (i = 0; i < JTP_MAP_HEIGHT; i++)
    for (j = 1; j < JTP_MAP_WIDTH; j++)
    {
      struct obj *otmp  = vobj_at(j,i);
      cur_glyph = jtp_mapglyph_obj[i][j];
      cur_tile = jtp_object_to_tile(cur_glyph);
      if (otmp && !objects[otmp->otyp].oc_name_known)
      {
          switch (cur_tile)
          {
              case JTP_TILE_SACK:
              case JTP_TILE_OILSKIN_SACK:
              case JTP_TILE_BAG_OF_TRICKS:
              case JTP_TILE_BAG_OF_HOLDING:
                  cur_tile = JTP_TILE_UNIDENTIFIED_BAG;
                  break;
              case JTP_TILE_LOADSTONE:
              case JTP_TILE_LUCKSTONE:
              case JTP_TILE_FLINT:
              case JTP_TILE_TOUCHSTONE: 
#ifdef HEALTHSTONE /* only in SlashEM */
              case JTP_TILE_HEALTHSTONE:
#endif
#ifdef WHETSTONE /* only in SlashEM */
              case JTP_TILE_WHETSTONE:
#endif
                  cur_tile = JTP_TILE_STONE;
                  break;
              case JTP_TILE_DILITHIUM_CRYSTAL:
              case JTP_TILE_DIAMOND:
              case JTP_TILE_RUBY:
              case JTP_TILE_JACINTH:
              case JTP_TILE_SAPPHIRE:
              case JTP_TILE_BLACK_OPAL:
              case JTP_TILE_EMERALD:
              case JTP_TILE_TURQUOISE:
              case JTP_TILE_CITRINE:
              case JTP_TILE_AQUAMARINE:
              case JTP_TILE_AMBER:
              case JTP_TILE_TOPAZ:
              case JTP_TILE_JET:
              case JTP_TILE_OPAL:
              case JTP_TILE_CHRYSOBERYL:
              case JTP_TILE_GARNET:
              case JTP_TILE_AMETHYST:
              case JTP_TILE_JASPER:
              case JTP_TILE_FLUORITE:
              case JTP_TILE_OBSIDIAN:
              case JTP_TILE_AGATE:
              case JTP_TILE_JADE:
                  switch (objects[otmp->otyp].oc_color)
                  {
                      case CLR_RED:
                          cur_tile = JTP_TILE_RED_GLASS;
                          break;
                      case CLR_BLACK:
                          cur_tile = JTP_TILE_BLACK_GLASS;
                          break;
                      case CLR_GREEN:
                          cur_tile = JTP_TILE_GREEN_GLASS;
                          break;
                      case CLR_BROWN:
                          cur_tile = JTP_TILE_BROWN_GLASS;
                          break;
                      case CLR_MAGENTA:
                          cur_tile = JTP_TILE_VIOLET_GLASS;
                          break;
                      case CLR_ORANGE:
                          cur_tile = JTP_TILE_ORANGE_GLASS;
                          break;
                      case CLR_YELLOW:
                          cur_tile = JTP_TILE_YELLOW_GLASS;
                          break;
                      case CLR_WHITE:
                          cur_tile = JTP_TILE_WHITE_GLASS;
                          break;
                      case CLR_BLUE:
                          cur_tile = JTP_TILE_BLUE_GLASS;
                          break;
                      default:
                          cur_tile = JTP_TILE_BLACK_GLASS;
                          break;
                  }
                  break;
          }
      }

      if (cur_tile != JTP_TILE_INVALID)
        jtp_maptile_obj[i][j] = jtp_tiles[cur_tile];
      else jtp_maptile_obj[i][j] = NULL;
    }
}

static jtp_tilestats *jtp_make_transparent_player_tile(int monnum)
{
	static jtp_tilestats *tile;
	static int tilenum = -1;
	jtp_tilestats *montile;
	int x, y, w, h;
	unsigned char *dst;
	
	/*
	 * monnum may change if player polymorphs...
	 */
	if (monnum != tilenum)
	{
		if (tile != NULL)
		{
			free(tile->graphic);
			free(tile);
		}
		montile = jtp_tiles[jtp_montiles[monnum]];
		jtp_get_dimensions(montile->graphic, &w, &h);
		tile = (jtp_tilestats *)malloc(sizeof(*tile));
		if (tile == NULL)
			return montile;
		*tile = *montile;
		tile->graphic = (unsigned char *)malloc((4 + w * h) * sizeof(unsigned char));
		if (tile->graphic == NULL)
		{
			free(tile);
			tile = NULL;
			return montile;
		}
		dst = tile->graphic;
		memcpy(dst, montile->graphic, (4 + w * h) * sizeof(unsigned char));
		dst += 4;
		for (y = 0; y < h; y++)
			for (x = y & 1; x < w; x += 2)
				dst[y * w + x] = JTP_COLOR_BACKGROUND;
		tilenum = monnum;
	}
	return tile;
}


static jtp_tilestats *jtp_make_invisible_player_tile(int monnum)
{
	static jtp_tilestats *tile;
	static int tilenum = -1;
	jtp_tilestats *montile;
	int x, y, w, h;
	unsigned char *dst;
	unsigned char *src;
	
	/*
	 * monnum may change if player polymorphs...
	 */
	if (monnum != tilenum)
	{
		if (tile != NULL)
		{
			free(tile->graphic);
			free(tile);
		}
		montile = jtp_tiles[jtp_montiles[monnum]];
		jtp_get_dimensions(montile->graphic, &w, &h);
		tile = (jtp_tilestats *)malloc(sizeof(*tile));
		if (tile == NULL)
			return montile;
		*tile = *montile;
		tile->graphic = (unsigned char *)malloc((4 + w * h) * sizeof(unsigned char));
		if (tile->graphic == NULL)
		{
			free(tile);
			tile = NULL;
			return montile;
		}
		dst = tile->graphic;
		memcpy(dst, montile->graphic, 4 * sizeof(unsigned char));
		dst += 4;
		memset(dst, JTP_COLOR_BACKGROUND, w * h * sizeof(unsigned char));
		src = montile->graphic + 4;
		for (y = 0; y < h; y += 2)
			for (x = (y >> 1) & 1; x < w; x += 2)
				dst[y * w + x] = src[y * w + x];
		tilenum = monnum;
	}
	return tile;
}


static void jtp_convert_map_monsters(void)
{
  int i, j;
  int cur_glyph, cur_tile;
  for (i = 0; i < JTP_MAP_HEIGHT; i++)
    for (j = 1; j < JTP_MAP_WIDTH; j++)
    {
      cur_glyph = jtp_mapglyph_mon[i][j];
      if (cur_glyph == PM_ALIGNED_PRIEST)
      {
          register struct monst *mtmp = m_at(j,i);
          if (EPRI(mtmp)->shralign == A_LAWFUL)
              cur_tile = JTP_TILE_LAWFUL_PRIEST;
          else if (EPRI(mtmp)->shralign == A_CHAOTIC)
              cur_tile = JTP_TILE_CHAOTIC_PRIEST;
          else if (EPRI(mtmp)->shralign == A_NEUTRAL)
              cur_tile = JTP_TILE_NEUTRAL_PRIEST;
          else
              cur_tile = JTP_TILE_UNALIGNED_PRIEST;
      }
      else
          cur_tile = jtp_monster_to_tile(cur_glyph);
      if (cur_tile != JTP_TILE_INVALID)
        jtp_maptile_mon[i][j] = jtp_tiles[cur_tile];
      else jtp_maptile_mon[i][j] = NULL;
    }
  if (Invis)
  {
    if (!canseeself())
      jtp_maptile_mon[u.uy][u.ux] = jtp_make_invisible_player_tile(u.umonnum);
    else
      jtp_maptile_mon[u.uy][u.ux] = jtp_make_transparent_player_tile(u.umonnum);
  }
}

static void jtp_convert_map_cmaps(void)
{
  int i, j, k, l;
  int cur_glyph, cur_tile;
  int temp_glyph, temp_tile;
  int iswall, isfloor, isdecor;
  int isedge;
  
  for (i = 0; i < JTP_MAP_HEIGHT; i++)
  {
    for (j = 1; j < JTP_MAP_WIDTH; j++)
    {
      /* Default: no walls around tile */ 
      jtp_maptile_wall[i][j].west = NULL;
      jtp_maptile_wall[i][j].north = NULL;
      jtp_maptile_wall[i][j].east = NULL;
      jtp_maptile_wall[i][j].south = NULL;

      /* Default: no floor edges around tile */
      jtp_maptile_floor_edge[i][j].west = NULL;
      jtp_maptile_floor_edge[i][j].north = NULL;
      jtp_maptile_floor_edge[i][j].east = NULL;
      jtp_maptile_floor_edge[i][j].south = NULL;
      jtp_maptile_floor_edge[i][j].northwest = NULL;
      jtp_maptile_floor_edge[i][j].northeast = NULL;
      jtp_maptile_floor_edge[i][j].southwest = NULL;
      jtp_maptile_floor_edge[i][j].southeast = NULL;
      jtp_maptile_floor_edge[i][j].northwest_bank = NULL;
      jtp_maptile_floor_edge[i][j].northeast_bank = NULL;
      jtp_maptile_floor_edge[i][j].southwest_bank = NULL;
      jtp_maptile_floor_edge[i][j].southeast_bank = NULL;

      cur_glyph = jtp_mapglyph_cmap[i][j];
      cur_tile = jtp_cmap_to_tile(cur_glyph);
      if (cur_tile == JTP_TILE_INVALID)
      {
        /* Unknown glyph or nothing to draw */
        jtp_maptile_cmap[i][j] = NULL;
        continue;
      }

#if defined(VULTURESEYE) || (defined(VULTURESCLAW) && defined(REINCARNATION))
      if ((cur_tile == JTP_TILE_FLOOR_COBBLESTONE) && (Is_rogue_level(&u.uz)))
          cur_tile = JTP_TILE_FLOOR_DARK;
#endif

      /* Is this tile a floor tile that we have to check edges for? */
      isfloor = 0;      
      if ((cur_tile == JTP_TILE_FLOOR_LAVA) ||
          (cur_tile == JTP_TILE_FLOOR_WATER) ||
          (cur_tile == JTP_TILE_FLOOR_ICE) ||
          (cur_tile == JTP_TILE_FLOOR_AIR))
      {
        isfloor = 1;
      }

      /* If this tile is a floor tile, check for floor edges */
      if (isfloor)
      {
        /* The tile is a floor tile, we need to check the surrounding area */
        isedge = 0;
        if (j > 1)
        {
          temp_glyph = jtp_mapglyph_cmap[i][j-1];
          temp_tile = jtp_cmap_to_tile(temp_glyph);
          if (temp_tile != cur_tile)
          {
            /* Floor style ends to the west */
            k = JTP_FLOOR_EDGE_STYLE_COBBLESTONE; /* No others made so far */
            jtp_maptile_floor_edge[i][j].west = jtp_floor_edges[k].west;
          }
          /* Make a naive check for edge banks, clear unwanted ones later */
          if (i > 0)
          {
            temp_glyph = jtp_mapglyph_cmap[i-1][j-1];
            temp_tile = jtp_cmap_to_tile(temp_glyph);
            if (temp_tile != cur_tile)
            {
              /* Floor style ends to the northwest */
              k = JTP_FLOOR_EDGE_STYLE_COBBLESTONE; /* No others made so far */
              jtp_maptile_floor_edge[i][j].northwest_bank = jtp_floor_edges[k].northwest_bank;
            }
          }        
          if (i < JTP_MAP_HEIGHT-1)
          {
            temp_glyph = jtp_mapglyph_cmap[i+1][j-1];
            temp_tile = jtp_cmap_to_tile(temp_glyph);
            if (temp_tile != cur_tile)
            {         
              /* Floor style ends to the southwest */
              k = JTP_FLOOR_EDGE_STYLE_COBBLESTONE; /* No others made so far */
              jtp_maptile_floor_edge[i][j].southwest_bank = jtp_floor_edges[k].southwest_bank;
            }
          }          
        }
        if (i > 0)
        {
          temp_glyph = jtp_mapglyph_cmap[i-1][j];
          temp_tile = jtp_cmap_to_tile(temp_glyph);
          if (temp_tile != cur_tile)
          {
            /* Floor style ends to the north */
            k = JTP_FLOOR_EDGE_STYLE_COBBLESTONE; /* No others made so far */
            jtp_maptile_floor_edge[i][j].north = jtp_floor_edges[k].north;
          }
        }        
        if (i < JTP_MAP_HEIGHT-1)
        {
          temp_glyph = jtp_mapglyph_cmap[i+1][j];
          temp_tile = jtp_cmap_to_tile(temp_glyph);
          if (temp_tile != cur_tile)
          {         
            /* Floor style ends to the south */
            k = JTP_FLOOR_EDGE_STYLE_COBBLESTONE; /* No others made so far */
            jtp_maptile_floor_edge[i][j].south = jtp_floor_edges[k].south;
          }
        }
        if (j < JTP_MAP_WIDTH-1)
        {
          temp_glyph = jtp_mapglyph_cmap[i][j+1];
          temp_tile = jtp_cmap_to_tile(temp_glyph);
          if (temp_tile != cur_tile)
          {
            /* Floor style ends to the east */
            k = JTP_FLOOR_EDGE_STYLE_COBBLESTONE; /* No others made so far */
            jtp_maptile_floor_edge[i][j].east = jtp_floor_edges[k].east;
          }
          /* Make a naive check for edge banks, clear unwanted ones later */
          if (i > 0)
          {
            temp_glyph = jtp_mapglyph_cmap[i-1][j+1];
            temp_tile = jtp_cmap_to_tile(temp_glyph);
            if (temp_tile != cur_tile)
            {
              /* Floor style ends to the northeast */
              k = JTP_FLOOR_EDGE_STYLE_COBBLESTONE; /* No others made so far */
              jtp_maptile_floor_edge[i][j].northeast_bank = jtp_floor_edges[k].northeast_bank;
            }
          }        
          if (i < JTP_MAP_HEIGHT-1)
          {
            temp_glyph = jtp_mapglyph_cmap[i+1][j+1];
            temp_tile = jtp_cmap_to_tile(temp_glyph);
            if (temp_tile != cur_tile)
            {         
              /* Floor style ends to the southeast */
              k = JTP_FLOOR_EDGE_STYLE_COBBLESTONE; /* No others made so far */
              jtp_maptile_floor_edge[i][j].southeast_bank = jtp_floor_edges[k].southeast_bank;
            }
          }          
        }

        /* Check for edge corners */
        k = JTP_FLOOR_EDGE_STYLE_COBBLESTONE; /* No others made so far */
        if (jtp_maptile_floor_edge[i][j].south)
        {
          if (jtp_maptile_floor_edge[i][j].east)
            jtp_maptile_floor_edge[i][j].southeast = jtp_floor_edges[k].southeast;
          if (jtp_maptile_floor_edge[i][j].west)
            jtp_maptile_floor_edge[i][j].southwest = jtp_floor_edges[k].southwest;
        }
        if (jtp_maptile_floor_edge[i][j].north)
        {
          if (jtp_maptile_floor_edge[i][j].east)
            jtp_maptile_floor_edge[i][j].northeast = jtp_floor_edges[k].northeast;
          if (jtp_maptile_floor_edge[i][j].west)
            jtp_maptile_floor_edge[i][j].northwest = jtp_floor_edges[k].northwest;
        }

        /* Erase unnecessary edge banks */
        if (jtp_maptile_floor_edge[i][j].south)
        {
          jtp_maptile_floor_edge[i][j].southeast_bank = NULL;
          jtp_maptile_floor_edge[i][j].southwest_bank = NULL;
        }
        if (jtp_maptile_floor_edge[i][j].north)
        {
          jtp_maptile_floor_edge[i][j].northeast_bank = NULL;
          jtp_maptile_floor_edge[i][j].northwest_bank = NULL;
        }
        if (jtp_maptile_floor_edge[i][j].west)
        {
          jtp_maptile_floor_edge[i][j].southwest_bank = NULL;
          jtp_maptile_floor_edge[i][j].northwest_bank = NULL;
        }
        if (jtp_maptile_floor_edge[i][j].east)
        {
          jtp_maptile_floor_edge[i][j].southeast_bank = NULL;
          jtp_maptile_floor_edge[i][j].northeast_bank = NULL;
        }
      }

      /* If this tile is a floor tile, check for a floor decoration */
      if (cur_tile == JTP_TILE_FLOOR_COBBLESTONE)
      {
        isdecor = 0;
        for (k = 0; k < jtp_n_floor_decors; k++)
        {
          if ((jtp_floor_decors[k].x == j) && (jtp_floor_decors[k].y == i))
          {
            l = jtp_floor_decors[k].style;
            jtp_maptile_cmap[i][j] = jtp_floors[l].pattern[jtp_floor_decors[k].pos];
            isdecor = 1;
            break;
          }          
        }
        if (isdecor) continue;
      }
            
      /* For normal floor tiles (non-decoration), set position in the floor pattern */
      if ((cur_tile == JTP_TILE_FLOOR_COBBLESTONE) ||
          (cur_tile == JTP_TILE_FLOOR_ROUGH) ||
          (cur_tile == JTP_TILE_FLOOR_ROUGH_LIT) ||
        /*  (cur_tile == JTP_TILE_FLOOR_CERAMIC) || */
          (cur_tile == JTP_TILE_FLOOR_LAVA) ||
          (cur_tile == JTP_TILE_FLOOR_ICE) ||
          (cur_tile == JTP_TILE_FLOOR_WATER) ||
          (cur_tile == JTP_TILE_FLOOR_AIR) ||
          (cur_tile == JTP_TILE_FLOOR_DARK))
      {
        k = jtp_get_floor_decor(cur_tile, i, j);
        l = jtp_floors[k].xspan*(i%jtp_floors[k].yspan) + (j%jtp_floors[k].xspan);
        jtp_maptile_cmap[i][j] = jtp_floors[k].pattern[l];
        continue;
      }

      /* Is this tile a known, seen wall ? */
      iswall = 0;      
      if (cur_tile == JTP_TILE_WALL_GENERIC)
      {
        /* if (levl[j][i].seenv) */ iswall = 1;
      }

      if (!iswall)
      {
        jtp_maptile_cmap[i][j] = jtp_tiles[cur_tile];
      }
      else
      {
        /* The tile is a wall, we need to check the surrounding area */
        jtp_maptile_cmap[i][j] = NULL;
        if (j > 1)
        {
          temp_glyph = jtp_mapglyph_cmap[i][j-1];
          temp_tile = jtp_cmap_to_tile(temp_glyph);
          if ((temp_tile != JTP_TILE_WALL_GENERIC) && (temp_tile != JTP_TILE_INVALID)) 
          {
            /* Wall ends to the west */
#if defined(VULTURESEYE) || (defined(VULTURESCLAW) && defined(REINCARNATION))
            if (Is_rogue_level(&u.uz))
              k = jtp_get_wall_decor(JTP_TILE_WALL_LIGHT, i, j, i, j-1);
            else
#endif
            if ((temp_glyph == S_corr) ||
                (temp_glyph == S_litcorr))            
              k = jtp_get_wall_decor(JTP_TILE_WALL_ROUGH, i, j, i, j-1);
            else
              k = jtp_get_wall_decor(JTP_TILE_WALL_BRICK, i, j, i, j-1);
            jtp_maptile_wall[i][j].west = jtp_walls[k].west;
          }
        }
        if (i > 0)
        {
          temp_glyph = jtp_mapglyph_cmap[i-1][j];
          temp_tile = jtp_cmap_to_tile(temp_glyph);
          if ((temp_tile != JTP_TILE_WALL_GENERIC) && (temp_tile != JTP_TILE_INVALID)) 
          {
            /* Wall ends to the north */
#if defined(VULTURESEYE) || (defined(VULTURESCLAW) && defined(REINCARNATION))
            if (Is_rogue_level(&u.uz))
              k = jtp_get_wall_decor(JTP_TILE_WALL_LIGHT, i, j, i-1, j);
            else
#endif
            if ((temp_glyph == S_corr) ||
                (temp_glyph == S_litcorr))
              k = jtp_get_wall_decor(JTP_TILE_WALL_ROUGH, i, j, i-1, j);
            else
              k = jtp_get_wall_decor(JTP_TILE_WALL_BRICK, i, j, i-1, j);
            jtp_maptile_wall[i][j].north = jtp_walls[k].north;
          }
        }        
        if (i < JTP_MAP_HEIGHT-1)
        {
          temp_glyph = jtp_mapglyph_cmap[i+1][j];
          temp_tile = jtp_cmap_to_tile(temp_glyph);
          if ((temp_tile != JTP_TILE_WALL_GENERIC) && (temp_tile != JTP_TILE_INVALID)) 
          {
            /* Wall ends to the south */
#if defined(VULTURESEYE) || (defined(VULTURESCLAW) && defined(REINCARNATION))
            if (Is_rogue_level(&u.uz))
              k = jtp_get_wall_decor(JTP_TILE_WALL_LIGHT, i, j, i+1, j);
            else
#endif
            if ((temp_glyph == S_corr) ||
                (temp_glyph == S_litcorr))
              k = jtp_get_wall_decor(JTP_TILE_WALL_ROUGH, i, j, i+1, j);
            else
              k = jtp_get_wall_decor(JTP_TILE_WALL_BRICK, i, j, i+1, j);
            jtp_maptile_wall[i][j].south = jtp_walls[k].south;
          }
        }
        if (j < JTP_MAP_WIDTH-1)
        {
          temp_glyph = jtp_mapglyph_cmap[i][j+1];
          temp_tile = jtp_cmap_to_tile(temp_glyph);
          if ((temp_tile != JTP_TILE_WALL_GENERIC) && (temp_tile != JTP_TILE_INVALID))  
          {
            /* Wall ends to the east */
#if defined(VULTURESEYE) || (defined(VULTURESCLAW) && defined(REINCARNATION))
            if (Is_rogue_level(&u.uz))
              k = jtp_get_wall_decor(JTP_TILE_WALL_LIGHT, i, j, i, j+1);
            else
#endif
            if ((temp_glyph == S_corr) ||
                (temp_glyph == S_litcorr))
              k = jtp_get_wall_decor(JTP_TILE_WALL_ROUGH, i, j, i, j+1);
            else
              k = jtp_get_wall_decor(JTP_TILE_WALL_BRICK, i, j, i, j+1);
            jtp_maptile_wall[i][j].east = jtp_walls[k].east;
          }                  
        }
      }
    }
  }
}


static void jtp_draw_mini_map(void)
{
  int i, j, k, l, m, n, n_start, n_end;
  int token_x, token_y;

  /* Draw mini-map in lower left corner */
  jtp_set_draw_region(jtp_statusbar_x, jtp_statusbar_y,
                      jtp_statusbar_x+193, jtp_screen.height-1);
  jtp_put_img(jtp_statusbar_x, jtp_statusbar_y, jtp_statusbar);
  jtp_set_draw_region(0, 0, jtp_screen.width-1, jtp_screen.height-1);


  for (i = 0; i < JTP_MAP_HEIGHT; i++)
    for (j = 1; j < JTP_MAP_WIDTH; j++)
    {
      l = JTP_COLOR_BACKGROUND;
      k = jtp_mapglyph_cmap[i][j];
      /* Select a color for this glyph */
      switch(k)
      {
        case S_stone: case S_vwall: case S_hwall:
        case S_tlcorn: case S_trcorn: case S_blcorn: case S_brcorn:
        case S_tuwall: case S_tdwall: case S_tlwall: case S_trwall:
        case JTP_WINCONTENT_GLYPH_UNEXPLORED:
        case JTP_WINCONTENT_GLYPH_NOT_VISIBLE:
          l = JTP_COLOR_BACKGROUND; break;
        case S_corr: case S_litcorr:
          l = JTP_COLOR_MINI_CORRIDOR; break;
        case S_upstair: case S_dnstair:
          l = JTP_COLOR_MINI_STAIRS; break;
        case S_vodoor: case S_vcdoor: case S_hodoor: case S_hcdoor:
        case S_vodbridge: case S_hodbridge: case S_vcdbridge: case S_hcdbridge:
          l = JTP_COLOR_MINI_DOOR; break;
        default:
          l = JTP_COLOR_MINI_FLOOR; break;
      }
      if ((i == u.uy) && (j == u.ux)) l = JTP_COLOR_MINI_YOU;
      
      if (l != JTP_COLOR_BACKGROUND)
      {
        token_x = jtp_statusbar_x + 94 + 2*(j-jtp_map_x) - 2*(i-jtp_map_y);
        token_y = jtp_statusbar_y + 51 + 1*(j-jtp_map_x) + 1*(i-jtp_map_y);
        for (m = 0; m < 2; m++)
        {
          if (m == 0) { n_start = 0; n_end = 0; }
          else { n_start = -1; n_end = 1; }
          for (n = n_start; n <= n_end; n++)
          {
            if ((token_x + n > jtp_statusbar_x + 4) &&
                (token_x + n < jtp_statusbar_x + 193) &&
                (token_y + m > jtp_statusbar_y + 4) &&
                (token_y + m < jtp_statusbar_y + 96) &&
                (jtp_screen.vpage[(token_y+m)*jtp_screen.width+(token_x+n)] <= 188) &&
                (jtp_screen.vpage[(token_y+m)*jtp_screen.width+(token_x+n)] >= 180))
              jtp_screen.vpage[(token_y+m)*jtp_screen.width+(token_x+n)] = l;
          }
        }
      }
    }
}


void jtp_draw_map
(
  jtp_window * mapwindow,
  int xc, int yc
)
{
  int i, j;
  jtp_tilestats * cur_tile;
  int lightlevel;
  int x, y;

  if (!mapwindow) return;
  if (xc < 0) xc = jtp_map_x;
  if (yc < 0) yc = jtp_map_y;

  /* Check if we need to restore the game palette */
  if ((!jtp_game_palette_set) && (jtp_map_changed))
  {
    memcpy(jtp_colors, jtp_game_colors, sizeof(jtp_colors));
    jtp_refresh(&jtp_screen);
    jtp_updatepal(0, 255);
    jtp_game_palette_set = 1;
  }

  if (jtp_map_changed)
  {
    jtp_prev_dlevel = jtp_cur_dlevel;
    jtp_cur_dlevel = u.uz.dlevel;
    if (jtp_cur_dlevel != jtp_prev_dlevel)
    {
      jtp_find_room_indices(jtp_room_indices);
      jtp_init_floor_decors(10);
      jtp_init_lights(JTP_MAX_LIGHTS);
    }
    jtp_calculate_lights();
    jtp_convert_map_objects();
    jtp_convert_map_monsters();
    jtp_convert_map_cmaps();
    jtp_map_changed = 0;
  }

  /* Clear map area */
  memset(jtp_screen.vpage, JTP_COLOR_BACKGROUND, jtp_screen.width*(jtp_screen.height-JTP_STATUSBAR_HEIGHT));

  /* Only draw on map area */
  jtp_set_draw_region(0, 0, jtp_screen.width-1, jtp_screen.height-1-JTP_STATUSBAR_HEIGHT);

  for (i = 0; i < JTP_MAP_HEIGHT; i++)
    for (j = 1; j < JTP_MAP_WIDTH; j++)
    {
      lightlevel = jtp_map_light[i][j];

      /* Find position of tile center */
      x = jtp_map_center_x + JTP_MAP_XMOD*(j - i + yc - xc);
      y = jtp_map_center_y + JTP_MAP_YMOD*(j + i - yc - xc);

      /* 
         Draw Vulture's tiles, in order:
         1. West and north walls
         2. Floor (cmap)
         3. Floor edges
         4. Object
         5. Monster
         6. South and east walls
       */
      if ((cur_tile = jtp_maptile_wall[i][j].west) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     jtp_map_light[i][j-1], cur_tile->graphic);
      if ((cur_tile = jtp_maptile_wall[i][j].north) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     jtp_map_light[i-1][j], cur_tile->graphic);

      if ((cur_tile = jtp_maptile_cmap[i][j]) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);

      if ((cur_tile = jtp_maptile_floor_edge[i][j].west) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].north) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].east) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].south) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);

      if ((cur_tile = jtp_maptile_floor_edge[i][j].northwest) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].northeast) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].southeast) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].southwest) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].northwest_bank) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].northeast_bank) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].southeast_bank) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
      if ((cur_tile = jtp_maptile_floor_edge[i][j].southwest_bank) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);

      if ((cur_tile = jtp_maptile_obj[i][j]) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);

      if ((cur_tile = jtp_maptile_mon[i][j]) != NULL)
      {
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     lightlevel, cur_tile->graphic);
        if (iflags.hilite_pet && (jtp_mapglyph_special[i][j] & MG_PET))
            jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                lightlevel, jtp_tiles[JTP_TILE_HILITE_PET]->graphic);
      }

      if ((cur_tile = jtp_maptile_wall[i][j].south) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     jtp_map_light[i+1][j], cur_tile->graphic);
      if ((cur_tile = jtp_maptile_wall[i][j].east) != NULL)
        jtp_put_tile(x + cur_tile->xmod, y + cur_tile->ymod,
                     jtp_map_light[i][j+1], cur_tile->graphic);
    }

  /* Restore drawing region */
  jtp_set_draw_region(0, 0, jtp_screen.width-1, jtp_screen.height-1);

  /* Draw mini-map to the left of the status area */
  jtp_draw_mini_map();

  /* The old message background area is now invalid, so make sure it isn't used. */
  free(jtp_messages_background);
  jtp_messages_background = NULL;
}



jtp_list * jtp_list_new(void)
{
  jtp_list * list_temp;
  
  list_temp = (jtp_list *)malloc(sizeof(jtp_list));
  if (!list_temp)
  {
    OOM(1);
  }
  list_temp->header = (jtp_listitem *)malloc(sizeof(jtp_listitem));
  if (!list_temp->header)
  {
    OOM(1);
  }
  list_temp->header->previous = list_temp->header;
  list_temp->header->next = NULL;
  list_temp->header->itemdata = NULL;
  list_temp->previous = list_temp->header;
  list_temp->length = 0;
  return(list_temp);
}


void jtp_list_reset(jtp_list * list_to_reset)
{
  list_to_reset->previous = list_to_reset->header;
}

void jtp_list_advance(jtp_list * list_to_advance)
{
  if (list_to_advance->previous->next)
  {
    list_to_advance->previous = (jtp_listitem *)(list_to_advance->previous->next);
  }
}

static void jtp_list_retreat(jtp_list * list_to_retreat)
{
  list_to_retreat->previous = (jtp_listitem *)(list_to_retreat->previous->previous);
}


void *jtp_list_current(jtp_list * list_to_access)
{
  if (!(list_to_access->previous->next))
    return(NULL);
  else
    return(((jtp_listitem *)list_to_access->previous->next)->itemdata);
}

void jtp_list_add(jtp_list * list_to_access, void *item_to_add)
{
  jtp_listitem * tempitem;
  
  tempitem = (jtp_listitem *)malloc(sizeof(jtp_listitem));
  if (!tempitem)
  {
    OOM(1);
  }
  tempitem->itemdata = item_to_add;
  tempitem->previous = list_to_access->previous;
  tempitem->next = list_to_access->previous->next;
  if (tempitem->next)
    ((jtp_listitem *)tempitem->next)->previous = tempitem;
  list_to_access->previous->next = tempitem;
  list_to_access->length++;
}


void jtp_list_remove(jtp_list * list_to_access, void *item_to_remove)
{
  jtp_listitem * tempitem;
  
  jtp_list_reset(list_to_access);
  
  while ((list_to_access->previous->next) && 
         (((jtp_listitem *)list_to_access->previous->next)->itemdata != item_to_remove))
    jtp_list_advance(list_to_access);
  if (list_to_access->previous->next)
  {
    tempitem = (jtp_listitem *)(list_to_access->previous->next);
    list_to_access->previous->next = tempitem->next;
    if (tempitem->next)
      ((jtp_listitem *)tempitem->next)->previous = list_to_access->previous;
    free(tempitem);
  }
  list_to_access->length--;
}


int jtp_list_length(jtp_list *list_to_access)
{
  return(list_to_access->length);
}


void jtp_free_menu
(
  jtp_menu * menu_to_free
)
{
  jtp_menuitem * menuitemtemp;
  
  if (!menu_to_free) return;
  
  jtp_list_reset(menu_to_free->items);
  menuitemtemp = (jtp_menuitem *)jtp_list_current(menu_to_free->items);
  
  while (menuitemtemp)
  {
    jtp_list_remove(menu_to_free->items, menuitemtemp);
    free(menuitemtemp->text);
    free(menuitemtemp);
    
    jtp_list_reset(menu_to_free->items);
    menuitemtemp = (jtp_menuitem *)jtp_list_current(menu_to_free->items);
  }
  
  free(menu_to_free->items->header);
  free(menu_to_free->items);
  free(menu_to_free->prompt);
  free(menu_to_free);
}

void jtp_free_buttons(jtp_list *buttonlist)
{
  jtp_button * buttontemp;
  
  if (!buttonlist) return;
  
  jtp_list_reset(buttonlist);
  buttontemp = jtp_list_current(buttonlist);
  
  while (buttontemp)
  {
    jtp_list_remove(buttonlist, buttontemp);
    free(buttontemp->text);
    free(buttontemp);
    
    jtp_list_reset(buttonlist);
    buttontemp = jtp_list_current(buttonlist);
  }
  
  free(buttonlist->header);
  free(buttonlist);
}


void jtp_clear_screen(void)
{
  memset(jtp_screen.vpage, JTP_COLOR_BACKGROUND, jtp_screen.width*jtp_screen.height);
}

unsigned char *jtp_draw_window(int x, int y, int width, int height)
{
  int i, j;
  unsigned char * window_background;
  
  window_background = jtp_get_img(x, y, x+width, y+height);

  /* Draw corners */
  jtp_put_stencil(x, y, jtp_defwin.corner_tl);
  jtp_put_stencil(x+width-jtp_defwin.corner_tr[3], y, jtp_defwin.corner_tr);
  jtp_put_stencil(x, y+height-jtp_defwin.corner_bl[1], jtp_defwin.corner_bl);
  jtp_put_stencil(x+width-jtp_defwin.corner_br[3], y+height-jtp_defwin.corner_br[1], 
                  jtp_defwin.corner_br);

  /* Draw top border */
  jtp_set_draw_region(x+jtp_defwin.border_left[3], y,
                      x+width-jtp_defwin.border_right[3],
                      y+jtp_defwin.border_top[1]);
  i = x + jtp_defwin.border_left[3];
  while (i <= x+width-jtp_defwin.border_right[3])
  {
    jtp_put_stencil(i, y, jtp_defwin.border_top);
    i += jtp_defwin.border_top[3];
  }

  /* Draw bottom border */
  jtp_set_draw_region(x+jtp_defwin.border_left[3],
                      y+height-jtp_defwin.border_bottom[1],
                      x+width-jtp_defwin.border_right[3],
                      y+height);
  i = x + jtp_defwin.border_left[3];
  while (i <= x+width-jtp_defwin.border_right[3])
  {
    jtp_put_stencil(i, y+height-jtp_defwin.border_bottom[1], jtp_defwin.border_bottom);
    i += jtp_defwin.border_bottom[3];
  }

  /* Draw left border */
  jtp_set_draw_region(x, y+jtp_defwin.border_top[1],
                      x+jtp_defwin.border_left[3],
                      y+height-jtp_defwin.border_bottom[1]);
  i = y + jtp_defwin.border_top[1];
  while (i <= y+height-jtp_defwin.border_bottom[1])
  {
    jtp_put_stencil(x, i, jtp_defwin.border_left);
    i += jtp_defwin.border_left[1];
  }

  /* Draw right border */
  jtp_set_draw_region(x+width-jtp_defwin.border_right[3],
                      y+jtp_defwin.border_top[1],
                      x+width,
                      y+height-jtp_defwin.border_bottom[1]);
  i = y + jtp_defwin.border_top[1];
  while (i <= y+height-jtp_defwin.border_bottom[1])
  {
    jtp_put_stencil(x+width-jtp_defwin.border_right[3], i, jtp_defwin.border_right);
    i += jtp_defwin.border_right[1];
  }

  /* Draw center area */
  jtp_set_draw_region(x+jtp_defwin.border_left[3],
                      y+jtp_defwin.border_top[1],
                      x+width-jtp_defwin.border_right[3],
                      y+height-jtp_defwin.border_bottom[1]);
  i = y + jtp_defwin.border_top[1];
  while (i <= y+height-jtp_defwin.border_bottom[1])
  {
    j = x + jtp_defwin.border_left[3];
    while (j <= x+width-jtp_defwin.border_right[3])
    {
      jtp_put_img(j, i, jtp_defwin.center);
      j += jtp_defwin.center[3];
    }
    i += jtp_defwin.center[1];
  }

  jtp_set_draw_region(0, 0, jtp_screen.width-1, jtp_screen.height-1);
  return(window_background);
}

static unsigned char *jtp_draw_dropdown_window(int x, int y, int width, int height)
{
  int i, j;
  unsigned char * window_background;
  
  window_background = jtp_get_img(x, y, x+width, y+height);

  /* Draw center area */
  jtp_set_draw_region(x, y, x+width-1, y+height-1);
  i = y;
  while (i <= y+height)
  {
    j = x;
    while (j <= x+width)
    {
      jtp_put_img(j, i, jtp_defwin.center);
      j += jtp_defwin.center[3];
    }
    i += jtp_defwin.center[1];
  }

  /* Draw black border */
  jtp_rect(x, y, x+width-1, y+height-1, 0);

  /* Draw edges (raised) */
  jtp_bres_line(x+1, y+1, x+width-3, y+1, 26);
  jtp_bres_line(x+1, y+height-2, x+width-2, y+height-2, 37);
  jtp_bres_line(x+width-2, y+1, x+width-2, y+height-2, 40);
  jtp_bres_line(x+1, y+1, x+1, y+height-3, 26);

  jtp_set_draw_region(0, 0, jtp_screen.width-1, jtp_screen.height-1);
  return(window_background);
}


void jtp_draw_button(int x, int y, int width, int height, const char *str)
{
  int i;
  
  i = (width - jtp_text_length(str, JTP_FONT_BUTTON))/2;

  /* Black edge */
  jtp_rect(x+1, y+1, x+width-2, y+height-2, JTP_COLOR_BACKGROUND);
  /* Outer edge (lowered) */
  jtp_bres_line(x, y, x+width-2, y, 37);
  jtp_bres_line(x, y+1, x, y+height-2, 40);
  jtp_bres_line(x+1, y+height-1, x+width-1, y+height-1, 26);
  jtp_bres_line(x+width-1, y+1, x+width-1, y+height-1, 26);
  /* Inner edge (raised) */
  jtp_bres_line(x+3, y+height-3, x+width-3, y+height-3, 37);
  jtp_bres_line(x+2, y+2, x+width-4, y+2, 26);
  jtp_bres_line(x+width-3, y+2, x+width-3, y+height-3, 40);
  jtp_bres_line(x+2, y+2, x+2, y+height-4, 26);
  jtp_put_text(x+i+1, y+jtp_fonts[JTP_FONT_BUTTON].baseline+6,
               JTP_FONT_BUTTON, JTP_COLOR_BACKGROUND,
               str,
               jtp_screen.vpage);
  jtp_put_text(x+i,
               y+jtp_fonts[JTP_FONT_BUTTON].baseline+5,
               JTP_FONT_BUTTON, JTP_COLOR_TEXT,
               str,
               jtp_screen.vpage);
}

void jtp_draw_buttons(int x, int y, jtp_list *buttons)
{
  jtp_button * tempbutton;
  
  if (!buttons) return;
  
  jtp_list_reset(buttons);
  tempbutton = jtp_list_current(buttons);  
  while (tempbutton)
  {
    jtp_draw_button(x + tempbutton->x, y + tempbutton->y, 
                    tempbutton->width, tempbutton->height, 
                    tempbutton->text);
    jtp_list_advance(buttons);
    tempbutton = (jtp_button *)jtp_list_current(buttons);  
  }
}

void jtp_draw_menu(int x, int y, jtp_menu *menu, jtp_menuitem *firstitem)
{
  int i, j;
  int firstitem_y;
  int firstitem_index = 0;
  int menu_item_count;
  jtp_menuitem * tempmenuitem;

  if (!menu) return;

  if (menu->prompt)
  {
    jtp_put_text(x + menu->prompt_x, 
                 y + menu->prompt_y + jtp_fonts[JTP_FONT_HEADLINE].baseline + 1,
                 JTP_FONT_HEADLINE, JTP_COLOR_BACKGROUND,
                 menu->prompt,
                 jtp_screen.vpage);
    jtp_put_text(x+ menu->prompt_x,
                 y + menu->prompt_y + jtp_fonts[JTP_FONT_HEADLINE].baseline,
                 JTP_FONT_HEADLINE, JTP_COLOR_TEXT,
                 menu->prompt,
                 jtp_screen.vpage);
  }
  
  if (menu->items)
  {
    firstitem_index = 0;  
    jtp_list_reset(menu->items);
    tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
    while ((tempmenuitem) && (tempmenuitem != firstitem))
    {
      jtp_list_advance(menu->items);
      tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
      firstitem_index++;
    }
    if (tempmenuitem) firstitem_y = tempmenuitem->y;
    
    while ((tempmenuitem) &&
           (tempmenuitem->y - firstitem->y + tempmenuitem->height < JTP_MAX_MENUITEMS_HEIGHT))
    {
      i = x + tempmenuitem->x;
      if (tempmenuitem->count == JTP_NOT_SELECTABLE) j = 0;
      else
      {
        switch(menu->selectiontype)
        {
          case PICK_NONE:
            j = 0;
            i += jtp_defwin.radiobutton_off[3] + 4;
            break;
          case PICK_ONE:
            j = (jtp_defwin.radiobutton_off[1] - jtp_fonts[JTP_FONT_MENU].baseline)/2;
            if (j < 0) j = 0;
            if (tempmenuitem->selected == TRUE)
              jtp_put_img(i, y + menu->items_y + tempmenuitem->y - firstitem_y, jtp_defwin.radiobutton_on);
            else
              jtp_put_img(i, y + menu->items_y + tempmenuitem->y - firstitem_y, jtp_defwin.radiobutton_off);
            i += jtp_defwin.radiobutton_off[3] + 4;
            break;
          case PICK_ANY:
            j = (jtp_defwin.checkbox_off[1] - jtp_fonts[JTP_FONT_MENU].baseline)/2;
            if (j < 0) j = 0;
            if (tempmenuitem->selected == TRUE)
              jtp_put_img(i, y + menu->items_y + tempmenuitem->y - firstitem_y, jtp_defwin.checkbox_on);
            else
              jtp_put_img(i, y + menu->items_y + tempmenuitem->y - firstitem_y, jtp_defwin.checkbox_off);
            i += jtp_defwin.checkbox_off[3] + 4;
            break;
          default:
            j = 0;
            break;
        }
      }
      jtp_put_text(i, y + menu->items_y + tempmenuitem->y - firstitem_y + jtp_fonts[JTP_FONT_MENU].baseline + j + 1,
                   JTP_FONT_MENU, JTP_COLOR_BACKGROUND, tempmenuitem->text, jtp_screen.vpage);
      jtp_put_text(i, y + menu->items_y + tempmenuitem->y - firstitem_y + jtp_fonts[JTP_FONT_MENU].baseline + j,
                   JTP_FONT_MENU, JTP_COLOR_TEXT, tempmenuitem->text, jtp_screen.vpage);
      jtp_list_advance(menu->items);
      tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
    }
  }

  if (menu->need_scrollbar)
  {
    jtp_put_img(x + menu->scrollbar_x, y + menu->scrollup_y, jtp_defwin.scrollbutton_up);
    jtp_put_img(x + menu->scrollbar_x, y + menu->scrolldown_y, jtp_defwin.scrollbutton_down);
    
    jtp_set_draw_region(x + menu->scrollbar_x, 
                        y + menu->scrollup_y + jtp_defwin.scrollbutton_up[1],
                        x + menu->scrollbar_x + jtp_defwin.scrollbar[3] - 1,
                        y + menu->scrolldown_y - 1);
    for (i = y + menu->scrollup_y + jtp_defwin.scrollbutton_up[1];
         i < y + menu->scrolldown_y; i+= jtp_defwin.scrollbar[1])
      jtp_put_img(x + menu->scrollbar_x, i, jtp_defwin.scrollbar);
    jtp_set_draw_region(0, 0, jtp_screen.width - 1, jtp_screen.height - 1);

    /* Count n. of items in menu and draw scroll indicator */
    menu_item_count = jtp_list_length(menu->items);
    if (menu_item_count > 1)
    {
      i = menu->scrollup_y + jtp_defwin.scrollbutton_up[1] + 
          (firstitem_index*(menu->scrolldown_y - jtp_defwin.scroll_indicator[1] - 
          menu->scrollup_y - jtp_defwin.scrollbutton_up[1]))/(menu_item_count - 1);
      jtp_put_img(x + menu->scrollbar_x, y + i, jtp_defwin.scroll_indicator);
    }
  }
}


void jtp_draw_status(jtp_window *tempwindow)
{
  int i;
  unsigned int k;
  char * strptr;
  int len;
  char buffer[1024];
  char * tok;
  int  token_ok, token_x = 0, token_y = 0;
  int  n_conditions, name_passed;
  int  lineheight;
  int  warn;
  static int const status_xpos[5] = { 0, 60, 100, 180, 255 };
  
  /* Draw background */
  jtp_set_draw_region(jtp_statusbar_x+193, jtp_statusbar_y,
                      jtp_screen.width-1, jtp_screen.height-1);
  jtp_put_img(jtp_statusbar_x, jtp_statusbar_y, jtp_statusbar);
  jtp_set_draw_region(0, 0, jtp_screen.width-1,jtp_screen.height-1);

  /* If the screen is wider than the statusbar, clear the edge areas */
  if (jtp_screen.width > JTP_STATUSBAR_WIDTH)
  {
    jtp_fill_rect(0, jtp_statusbar_y, jtp_statusbar_x-1, jtp_screen.height-1, 0);
    jtp_fill_rect(jtp_statusbar_x + JTP_STATUSBAR_WIDTH, jtp_statusbar_y, 
                  jtp_screen.width-1, jtp_screen.height-1, 0);
  }
  lineheight = jtp_fonts[JTP_FONT_STATUS].lineheight;

  /* 
   * Parse status lines into 'status tokens'. Assign location of tokens on-screen.
   * Note: this section contains lots of 'magic numbers', but they're all indidivual
   * coordinates, so it doesn't seem worth it to make a separate define for each.
   * They are chosen to match the graphic file used.
   */

  n_conditions = 0;
  buffer[0] = '\0';
  name_passed = 0;
  for (i = 0; i < tempwindow->curs_rows; i++)
  {
    strptr = (char *)tempwindow->rows[i];
    len = strlen(strptr);
    
    tok = strtok(strptr, " ");
    while (tok)
    {
      token_ok = 0;
      warn = JTP_WARN_NONE;
      if (strncmp(tok, "St:", 3) == 0) /* Strength token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 0;
        token_y = 1;
      }
      else if (strncmp(tok, "Dx:", 3) == 0) /* Dexterity token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 0;
        token_y = 2;
      }
      else if (strncmp(tok, "Co:", 3) == 0) /* Constitution token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 0;
        token_y = 3;
      }
      else if (strncmp(tok, "Wt:", 3) == 0) /* Weight token, only possible with SHOW_WEIGHT defined */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 0;
        token_y = 4;
      }
      else if (strncmp(tok, "In:", 3) == 0) /* Intelligence token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 1;
        token_y = 1;
      }
      else if (strncmp(tok, "Wi:", 3) == 0) /* Wisdom token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 1;
        token_y = 2;
      }
      else if (strncmp(tok, "Ch:", 3) == 0) /* Charisma token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 1;
        token_y = 3;
      }
      else if (strncmp(tok, "HP:", 3) == 0) /* Hit points token */
      {
        int hp, hpmax;
        
        token_ok = 1;
        name_passed = 1;
        token_x = 2;
        token_y = 1;
        /*
         * FIXME: the thresholds used here as well as the colors
         * should be made configurable
         */
        hp = Upolyd ? u.mh : u.uhp;
        hpmax = Upolyd ? u.mhmax : u.uhpmax;
        if (hp >= ((hpmax * 90) / 100))
          warn = JTP_WARN_NONE;
        else if (hp >= ((hpmax * 70) / 100))
          warn = JTP_WARN_NORMAL;
        else if (hp >= ((hpmax * 50) / 100))
          warn = JTP_WARN_MORE;
        else if (hp >= ((hpmax * 25) / 100))
          warn = JTP_WARN_ALERT;
        else
          warn = JTP_WARN_CRITICAL;
      }
      else if (strncmp(tok, "Pw:", 3) == 0) /* Power token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 2;
        token_y = 2;
      }
      else if (strncmp(tok, "AC:", 3) == 0) /* Armor class token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 2;
        token_y = 3;
      }
      else if (strncmp(tok, "HD:", 3) == 0) /* Polymorphed token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 2;
        token_y = 4;
      }
      else if (strncmp(tok, "Exp:", 4) == 0 ||  /* Experience token */
        strncmp(tok, "Xp:", 3) == 0)      /* Experience token, only possible with EXP_ON_BOTL defined */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 3;
        token_y = 0;
      }
      else if (strncmp(tok, "Dlvl:", 5) == 0) /* Dungeon level token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 3;
        token_y = 1;
      }
      else if (tok[0] == oc_syms[COIN_CLASS] && /* Gold token */
        tok[1] == ':')
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 3;
        token_y = 2;
      }
      else if (strncmp(tok, "T:", 2) == 0) /* Time token */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 3;
        token_y = 3;
      }
      else if (strncmp(tok, "S:", 2) == 0) /* Score token, only possible with SCORE_ON_BOTL defined */
      {
        token_ok = 1;
        name_passed = 1;
        token_x = 3;
        token_y = 4;
      }
      /* Other non-empty tokens are parts of name & title, conditions or alignment */
      else
      {
        if (name_passed)
        {
          token_ok = 1;
          token_x = 4;
          token_y = n_conditions;
          n_conditions++;
          for (k = 0; k < sizeof(jtp_condition_alerts) / sizeof(jtp_condition_alerts[0]); k++)
          {
            if (strcmp(tok, jtp_condition_alerts[k].str) == 0)
            {
              warn = jtp_condition_alerts[k].level;
              break;
            }
          }
        }
        else
        {
          strcat(buffer, tok);
          strcat(buffer, " ");
        }
      }
      /* If the token was recognized, display it */
      if (token_ok)
      {
        token_x = STATUS_XPOS + status_xpos[token_x];
        token_y = STATUS_YPOS + lineheight * token_y + jtp_fonts[JTP_FONT_STATUS].baseline;
        jtp_put_text(jtp_statusbar_x + token_x, jtp_statusbar_y + token_y + 1,
                     JTP_FONT_STATUS, JTP_COLOR_BACKGROUND, tok, jtp_screen.vpage);
        jtp_put_text(jtp_statusbar_x + token_x, jtp_statusbar_y + token_y,
                     JTP_FONT_STATUS, jtp_warn_colors[warn], tok, jtp_screen.vpage);
      }
      /* Get the next token */
      tok = strtok(NULL, " ");
    }
    /* Show character name */
    jtp_put_text(jtp_statusbar_x + STATUS_XPOS,
                 jtp_statusbar_y + STATUS_YPOS + jtp_fonts[JTP_FONT_STATUS].baseline + 1,
                 JTP_FONT_STATUS, JTP_COLOR_BACKGROUND, buffer, jtp_screen.vpage);
    jtp_put_text(jtp_statusbar_x + STATUS_XPOS,
                 jtp_statusbar_y + STATUS_YPOS + jtp_fonts[JTP_FONT_STATUS].baseline,
                 JTP_FONT_STATUS, JTP_COLOR_TEXT, buffer, jtp_screen.vpage);

    /* undo the damage strtok does to our source string */
    for (k = 0; k < len; k++)
      if (!strptr[k])
        strptr[k] = ' ';
  }
  /*
   * show dungeon name
   */
  buffer[0] = '\0';
#ifdef VULTURESCLAW
  describe_level(buffer, TRUE);
#else
  if (!describe_level(buffer))
  {
    sprintf(buffer, "%s, level %d ", dungeons[u.uz.dnum].dname, depth(&u.uz));
  }
#endif
  jtp_put_text(jtp_statusbar_x + STATUS_XPOS,
    jtp_statusbar_y + STATUS_YPOS + 5 * lineheight + jtp_fonts[JTP_FONT_STATUS].baseline + 1,
         JTP_FONT_STATUS, JTP_COLOR_BACKGROUND, buffer, jtp_screen.vpage);
  jtp_put_text(jtp_statusbar_x + STATUS_XPOS,
    jtp_statusbar_y + STATUS_YPOS + 5 * lineheight + jtp_fonts[JTP_FONT_STATUS].baseline,
         JTP_FONT_STATUS, JTP_COLOR_TEXT, buffer, jtp_screen.vpage);
}



int jtp_draw_messages(jtp_window *tempwindow)
{
  int i, j, k, l;
  int tempwidth;
  char * tempstring;
  
  jtp_put_img(0, 0, jtp_messages_background);
  free(jtp_messages_background);
  
  /* Calculate width and height of messages to be shown */
  jtp_messages_height = 0;
  tempwidth = 0;
  for (i = JTP_MAX_SHOWN_MESSAGES-1+jtp_first_shown_message; i >= jtp_first_shown_message; i--)
    if (tempwindow->rows[i])
    {
      /* Check message age */
      k = moves; /* Current time in moves */
      k -= tempwindow->rows[i][0];
      if (k < 0) k = 0; /* This shouldn't happen, unless there's time travel etc. */
     
      /* If we're viewing previous messages, make sure they all get shown */
      if ((jtp_first_shown_message > 0) && (k >= JTP_MAX_MESSAGE_COLORS))
        k = JTP_MAX_MESSAGE_COLORS-1;

      if (k < JTP_MAX_MESSAGE_COLORS)
      {
        /* Message is new enough to be shown */
        tempstring = (char *)(tempwindow->rows[i]) + sizeof(int);
        jtp_messages_height += jtp_text_height(tempstring, JTP_FONT_MESSAGE);
        j = jtp_text_length(tempstring, JTP_FONT_MESSAGE);
        if (j > tempwidth) tempwidth = j;
      }
    }

  if (jtp_messages_height > 0)
  {
    jtp_messages_height += 4;
    tempwidth += 8;
    jtp_messages_background = jtp_get_img(0, 0, jtp_screen.width-1, jtp_messages_height-1);
  }
  else jtp_messages_background = NULL;

  /* Shade the message area */
  for (i = 0; i < jtp_messages_height; i++)
    for (j = (jtp_screen.width - tempwidth)/2; j <= (jtp_screen.width - tempwidth)/2 + tempwidth; j++)
    {
      k = jtp_screen.vpage[i*jtp_screen.width + j];
      jtp_screen.vpage[i*jtp_screen.width + j] = jtp_shade[(JTP_MAX_SHADES/2)*256+k];
    }

  j = jtp_fonts[JTP_FONT_MESSAGE].baseline;
  for (i = JTP_MAX_SHOWN_MESSAGES-1+jtp_first_shown_message; i >= jtp_first_shown_message; i--)
    if (tempwindow->rows[i])
    {
      /* Shade message according to its age */
      k = moves; /* Current time in moves */
      k -= tempwindow->rows[i][0];
      if (k < 0) k = 0; /* This shouldn't happen, unless there's time travel etc. */
      /* else if (k >= JTP_MAX_MESSAGE_COLORS) k = JTP_MAX_MESSAGE_COLORS-1; */

      /* If we're viewing previous messages, make sure they all get shown */
      if ((jtp_first_shown_message > 0) && (k >= JTP_MAX_MESSAGE_COLORS))
        k = JTP_MAX_MESSAGE_COLORS-1;

      if (k < JTP_MAX_MESSAGE_COLORS)
      {
        /* Center message on-screen */
        tempstring = (char *)(tempwindow->rows[i]) + sizeof(int);
        l = (jtp_screen.width - jtp_text_length(tempstring, JTP_FONT_MESSAGE))/2;
        /* Draw message */
        jtp_put_text(l, j + 1,
                     JTP_FONT_MESSAGE, JTP_COLOR_BACKGROUND,
                     tempstring,
                     jtp_screen.vpage);
        jtp_put_text(l, j,
                     JTP_FONT_MESSAGE, jtp_message_colors[k],
                     tempstring,
                     jtp_screen.vpage);
        j += jtp_text_height(tempstring, JTP_FONT_MESSAGE);
      }
    }

  return(jtp_messages_height); /* Return height of drawn messages */
}

void jtp_draw_all_windows(void)
{
  jtp_window * tempwindow;

  /* Draw basic windows in correct order: map, messages, status */
  tempwindow = jtp_find_window(WIN_MAP);
  jtp_draw_map(tempwindow, -1, -1);
  tempwindow = jtp_find_window(WIN_MESSAGE);
  jtp_draw_messages(tempwindow);
  tempwindow = jtp_find_window(WIN_STATUS);
  jtp_draw_status(tempwindow);
  
  /* Draw the other windows in order of appearance */
  jtp_list_reset(jtp_windowlist);
  tempwindow = (jtp_window *)jtp_list_current(jtp_windowlist);
  while (tempwindow)
  {
    switch(tempwindow->wintype)
    {
      case NHW_MAP: break;
      case NHW_STATUS: break;
      case NHW_MESSAGE: break;
      default: break;
    }
    jtp_list_advance(jtp_windowlist);
    tempwindow = (jtp_window *)jtp_list_current(jtp_windowlist);
  }
}


void jtp_show_screen(void)
{
  jtp_refresh(&jtp_screen);
}

void jtp_show_map_area(void)
{
  jtp_refresh_region(0, 0, jtp_screen.width-1, jtp_statusbar_y-1, &jtp_screen);
}

void jtp_show_status_area(void)
{
  jtp_refresh_region(0, jtp_statusbar_y, jtp_screen.width-1, jtp_screen.height-1, &jtp_screen);
}

void jtp_show_message_area(int messages_height)		/* Height of messages in message area */
{
  jtp_refresh_region(0, 0, jtp_screen.width-1, jtp_messages_height-1, &jtp_screen);
}

void jtp_read_mouse_input(void)
{
  /* If the palette is faded out for some reason, restore it */
  jtp_updatepal(0, 255);
  
  jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_LEFT);
}


int jtp_query_choices(const char *ques, const char *choices, int nchoices)
{
    jtp_button * pchoices = NULL;
    int nbuttons, i, len, longdesc = 0;
    int query_x, query_y;
    char *str = (char*)choices;
    char * pstr[1];
    unsigned char * background;
    int pressedkey, selected;
    
    /* there are two modes of operation:
     * - basic mode, where each button is labeled with a single character which are stored in choices
     *   and nchoices is zero (as the number of buttons is trivially found via strlen(choices)
     * - fancy mode, where choices contains exactly nchoices strings which are separated by '\0' */

    nbuttons = nchoices;
    if (!nchoices)
        nbuttons = strlen(choices);
    else
	longdesc = 1;
    
    /* a very common case is "yn" queries. Improve that to a yes/no query*/
    if (strncmp(choices, "yn", 3) == 0)
    {
        str = "yes\0no";
	longdesc = 1;;
    }
    
    pchoices = malloc(nbuttons * sizeof(jtp_button));

    /* str always points to the start of the next button label, len holds the length of the label */
    for(i = 0; i < nbuttons; i++)
    {
        len = 1;
        if (longdesc)
            len = strlen(str);

	pchoices[i].text = malloc(len+1);
	strncpy(pchoices[i].text, str, len);
	pchoices[i].text[len] = '\0';
	pchoices[i].accelerator = str[0];
        pchoices[i].width = jtp_text_length(pchoices[i].text, JTP_FONT_BUTTON) + 15;
        pchoices[i].height = jtp_fonts[JTP_FONT_BUTTON].lineheight + 10;
	pchoices[i].id = i;
	   
        if (longdesc)
            str += len;
	
	str++;
    }

    /* if we have only one button the accelerator is the ENTER key  */
    if (nchoices == 1)
        pchoices[0].accelerator = '\r';

    /* set up the headline string */
    pstr[0] = (char*)ques;

    /* draw the window & save the background */
    background = jtp_draw_query_window(pstr, 1, pchoices, nbuttons, &query_x, &query_y);
    
    /* get input */
    selected = -1;
    while (selected < 0)
    {
        /* Wait for mouse click or key press */
        jtp_keymouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_LEFT);
        pressedkey = jtp_getch();
        if (pressedkey != 0)
        {
            if (nbuttons == 1)
                selected = 0;
            else
            {
                for (i = 0; i < nbuttons; i++)
                    if (pchoices[i].accelerator == pressedkey)
                        selected = i;
            }
        }
        else if (jtp_mouseb != JTP_MBUTTON_NONE)
        {
            for (i = 0; i < nbuttons; i++)
                if (jtp_mouse_area(pchoices[i].x, pchoices[i].y, 
                                   pchoices[i].x + pchoices[i].width-1,
                                   pchoices[i].y + pchoices[i].height-1))
                    selected = i;
        }
    }
    if (!nchoices)
        selected = choices[selected];

    /* Restore background */
    jtp_put_img(query_x, query_y, background);
    jtp_refresh(&jtp_screen);

    /* Clean up */
    free(background);
    for (i = 0; i < nbuttons; i++)
        free(pchoices[i].text);
    free(pchoices);

    /* Return the chosen answer */
    return selected;
}


int jtp_query_direction(const char *ques)
{
    int height, width;
    int directions_x, directions_y;
    int directions_height, directions_width;
    int query_x, query_y;
    int text_x, text_y;
    int click_x, click_y;
    unsigned char * background;
    int nchoice = -1;
    int i, j;
    
    /* Calculate width, height and position of query window */
    width = jtp_text_length(ques, JTP_FONT_HEADLINE);
    height = jtp_text_height(ques, JTP_FONT_HEADLINE) + jtp_fonts[JTP_FONT_HEADLINE].lineheight/2;

    /* Add direction arrows */
    directions_width = jtp_defwin.direction_arrows[2]*256 + jtp_defwin.direction_arrows[3];
    directions_height = jtp_defwin.direction_arrows[0]*256 + jtp_defwin.direction_arrows[1];
    
    width = (width > directions_width) ? width : directions_width;
    height += directions_height;

    /* calculate window size and position */
    width  += (jtp_defwin.border_left[3] + jtp_defwin.border_right[3]);
    height += (jtp_defwin.border_top[1] + jtp_defwin.border_bottom[1]);

    query_x = (jtp_screen.width - width) / 2;
    query_y = (jtp_screen.height - height) / 2;
	    
    /* calculate direction arrows position  */
    directions_x = query_x + (width - directions_width)/2;
    directions_y = query_y + jtp_defwin.border_top[1] +
                   jtp_text_height(ques, JTP_FONT_HEADLINE) + jtp_fonts[JTP_FONT_HEADLINE].lineheight/2;
    
    /* Store background graphics */
    background = jtp_draw_window(query_x, query_y, width, height);

    /* draw the direction arrows */
    jtp_put_stencil(directions_x, directions_y, jtp_defwin.direction_arrows);
  
    /* Draw query message */
    text_x = query_x + jtp_defwin.border_left[3] + 1;
    text_y = query_y + jtp_defwin.border_top[1] + 1;

    jtp_put_text(text_x + 1, text_y + jtp_fonts[JTP_FONT_HEADLINE].baseline + 1, JTP_FONT_HEADLINE,
                 JTP_COLOR_BACKGROUND, ques, jtp_screen.vpage);
    jtp_put_text(text_x, text_y + jtp_fonts[JTP_FONT_HEADLINE].baseline, JTP_FONT_HEADLINE,
                 JTP_COLOR_TEXT, ques, jtp_screen.vpage);
    
    /* Display window */
    jtp_refresh(&jtp_screen);	
    
    /* Ask for input */
    while (nchoice < 0)
    {
        /* Wait for mouse click or key press */
        jtp_keymouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_LEFT);
        nchoice = jtp_getch();
        if (nchoice != 0)
        {
            /* swap the keys to match the isometric viewpoint. */
            nchoice = jtp_translate_key(nchoice);
            if (nchoice == 0)
                nchoice = -1;
        }
        else if (jtp_mouseb != JTP_MBUTTON_NONE)
        {
            /* Find out if the mouse was clicked on a direction arrow */
     
            /*
             * Find the direction square under the mouse cursor.
             * The isometric mapping is a matrix operation, y = Ax+b, where the y are screen
             * coordinates, the x are map square indices and A, b are constant.
             * Here we use an inverse mapping to find map indices from pixel coordinates.
             */
            i = jtp_mousex - directions_x - directions_width/2;
            j = jtp_mousey - directions_y - directions_height/2;
            click_x = JTP_MAP_YMOD*i + JTP_MAP_XMOD*j + JTP_MAP_XMOD*JTP_MAP_YMOD;
            click_x = click_x/(2*JTP_MAP_XMOD*JTP_MAP_YMOD) - (click_x < 0);
            click_y = -JTP_MAP_YMOD*i + JTP_MAP_XMOD*j + JTP_MAP_XMOD*JTP_MAP_YMOD;
            click_y = click_y/(2*JTP_MAP_XMOD*JTP_MAP_YMOD) - (click_y < 0);
            
      	    /* Select a direction command */
            nchoice = -1;
            if (click_y == -1)
            {
                if (click_x == -1) nchoice = jtp_translate_command(JTP_NHCMD_NORTHWEST);
                else if (click_x == 0) nchoice = jtp_translate_command(JTP_NHCMD_NORTH);
                else if (click_x == 1) nchoice = jtp_translate_command(JTP_NHCMD_NORTHEAST);
            }
            else if (click_y == 0)
            {
                if (click_x == -1) nchoice = jtp_translate_command(JTP_NHCMD_WEST);
                else if (click_x == 0) nchoice = jtp_translate_command(JTP_NHCMD_REST);
                else if (click_x == 1) nchoice = jtp_translate_command(JTP_NHCMD_EAST);
            }
            if (click_y == 1)
            {
                if (click_x == -1) nchoice = jtp_translate_command(JTP_NHCMD_SOUTHWEST);
                else if (click_x == 0) nchoice = jtp_translate_command(JTP_NHCMD_SOUTH);
                else if (click_x == 1) nchoice = jtp_translate_command(JTP_NHCMD_SOUTHEAST);
            }

	    if (click_x >= 2 && i < directions_width/2 && j < directions_height/2)
                nchoice = jtp_translate_command(JTP_NHCMD_DOWN);
	    
	    if (click_x <= -2 && i > -directions_width/2 && j > -directions_height/2)
                nchoice = jtp_translate_command(JTP_NHCMD_UP);

            /* Wait until mouse button is released */
	    jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
        }
        else
        {
            nchoice = -1;
	}
    }
    
    /* Restore background */
    jtp_put_img(query_x, query_y, background);
    jtp_refresh(&jtp_screen);

    /* Clean up */
    free(background);

    /* Return the chosen answer */
    return nchoice;
}


int jtp_query_anykey(const char *ques)
{
    jtp_button * pchoices = NULL;
    int query_x, query_y;
    int nbuttons, i;
    char * pstr[2];
    unsigned char * background;
    int nchoice = -1;

    nbuttons = 3;
    pchoices = (jtp_button *)malloc(nbuttons*sizeof(jtp_button));
    if (!pchoices)
        OOM(1);

    pchoices[0].accelerator = '?';
    pchoices[0].text = "Show choices";

    pchoices[1].accelerator = '*';
    pchoices[1].text = "Show inventory";

    pchoices[2].accelerator = 27; /* ESC */
    pchoices[2].text = "Cancel";

    for (i = 0; i < 3; i++)
    {
        pchoices[i].width = jtp_text_length(pchoices[i].text, JTP_FONT_BUTTON) + 15;
        pchoices[i].height = jtp_fonts[JTP_FONT_BUTTON].lineheight + 10;
        pchoices[i].id = i;
    }

    /* set up the headline & helpstring */   
    pstr[0] = (char*)ques;
    pstr[1] = "(type any key)";

    /* draw the window and save the background */
    background = jtp_draw_query_window(pstr, 2, pchoices, 3, &query_x, &query_y);

    /* get input */
    while (nchoice < 0)
    {
        /* Wait for mouse click or key press */
        jtp_keymouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_LEFT);
        nchoice = jtp_getch();
        if (nchoice == 0 && jtp_mouseb != JTP_MBUTTON_NONE)
        {
            /* Find out if the mouse was clicked on a button */
            for (i = 0; i < nbuttons; i++)
                if (jtp_mouse_area(pchoices[i].x, pchoices[i].y,
                                   pchoices[i].x+pchoices[i].width-1,
                                   pchoices[i].y+pchoices[i].height-1))
                    nchoice = pchoices[i].accelerator;
        }
    }
    
    /* Restore background */
    jtp_put_img(query_x, query_y, background);
    jtp_refresh(&jtp_screen);

    /* Clean up */
    free(background);
    free(pchoices);

    /* Return the chosen answer */
    return nchoice;    
}


unsigned char * jtp_draw_query_window(char * str[], int nstr, jtp_button * buttons, int nbuttons, int *win_x, int *win_y)
{
    int i, temp;
    int text_width, text_height;
    int buttons_width = 0, buttons_height = 0;
    int height, width;
    int query_x, query_y, text_x, text_y;
    unsigned char * query_background;

    /* calculate height & width of the text  */
    text_width = jtp_text_length(str[0], JTP_FONT_HEADLINE);
    text_height = jtp_text_height(str[0], JTP_FONT_HEADLINE) + jtp_fonts[JTP_FONT_HEADLINE].lineheight/2;
    for (i = 1; i < nstr; i++)
    {
        temp = jtp_text_length(str[i], JTP_FONT_MENU);
	text_width = (text_width > temp) ? text_width : temp;

	text_height += jtp_text_height(str[i], JTP_FONT_MENU) + jtp_fonts[JTP_FONT_MENU].lineheight/2;
    }
    text_height += 3; /* pad slightly  */

    /* calculate height and width of the buttons*/
    temp = 0;
    for (i = 0; i < nbuttons; i++)
    {
        buttons_width += buttons[i].width + 10;
        if (buttons[i].height > buttons_height)
            buttons_height = buttons[i].height;

	/* find maximum button width */
	temp = (temp > buttons[i].width) ? temp : buttons[i].width;
    }
    buttons_width -= 10; /* Remove extra spacing */

    /* calculate window dimensions & position */
    height = text_height + buttons_height + 5; /* +5 to accommodate padding */
    width = buttons_width;

    if (text_width > buttons_width)
    {
        width = text_width;
	
        /* if the text is a lot wider than the buttons, make all buttons equally large  */
	if (width > ((temp+10)*nbuttons-10))
	{
            for (i = 0; i < nbuttons; i++)
                buttons[i].width = temp;
	    buttons_width = (temp+10)*nbuttons-10;
	}
    }

    width  += (jtp_defwin.border_left[3] + jtp_defwin.border_right[3]);
    height += (jtp_defwin.border_top[1] + jtp_defwin.border_bottom[1]);
    
    query_x = (jtp_screen.width - width) / 2;
    query_y = (jtp_screen.height - height) / 2;

    text_x = query_x + jtp_defwin.border_left[3];
    text_y = query_y + jtp_defwin.border_top[1];

    /* calculate button positions */
    temp = query_x + (width - buttons_width) / 2;
    for (i = 0; i < nbuttons; i++)
    {
        buttons[i].x = temp;
        buttons[i].y = text_y + text_height;
        temp += buttons[i].width+10;
    }

    /* Draw the window and store the background */
    query_background = jtp_draw_window(query_x, query_y, width, height);

    /* Draw buttons */
    for (i = 0; i < nbuttons; i++)
    {
        jtp_draw_button(buttons[i].x, buttons[i].y,
                        buttons[i].width, buttons[i].height,
                        buttons[i].text);
    }
    
    /* Draw query message */
    jtp_put_text(text_x + 1, text_y + jtp_fonts[JTP_FONT_HEADLINE].baseline + 1, JTP_FONT_HEADLINE,
                 JTP_COLOR_BACKGROUND, str[0], jtp_screen.vpage);
    jtp_put_text(text_x, text_y + jtp_fonts[JTP_FONT_HEADLINE].baseline, JTP_FONT_HEADLINE,
                 JTP_COLOR_TEXT, str[0], jtp_screen.vpage);

    text_y += (jtp_text_height(str[0], JTP_FONT_HEADLINE) + jtp_fonts[JTP_FONT_HEADLINE].lineheight/2);

    for (i = 1; i < nstr; i++)
    {
        jtp_put_text(text_x + 1, text_y + jtp_fonts[JTP_FONT_MENU].baseline + 1,
                     JTP_FONT_MENU, JTP_COLOR_BACKGROUND, str[i], jtp_screen.vpage);
        jtp_put_text(text_x, text_y + jtp_fonts[JTP_FONT_MENU].baseline,
                    JTP_FONT_MENU, JTP_COLOR_TEXT, str[i], jtp_screen.vpage);

	text_y += (jtp_text_height(str[1], JTP_FONT_MENU) + jtp_fonts[JTP_FONT_MENU].lineheight/2);
    }

    /* Display window */
    jtp_refresh(&jtp_screen);
    
    /* If the palette is faded out for some reason, restore it */
    jtp_updatepal(0, 255);
	
    if (win_x)
        *win_x = query_x;
    if (win_y)
        *win_y = query_y;

    return query_background;
}

static int jtp_dropdown(
  int qx, int qy,                 /* Dropdown menu position */
  int nanswers,                   /* Number of menu items */
  jtp_dropdown_action ** panswers /* Menu item details */
)
{
  int i, j, k, l;
  int query_x, query_y;
  int totalwidth, totalheight;
  int ncolumns, column_height;
  int nbuttons, buttons_width;
  int nchoice = -1;
  jtp_button * pchoices;
  unsigned char * query_background;
  char pressedkey;

  /* discard all keys currently in the buffer to avoid unexpected results  */
  jtp_sdl_keybuf_reset();

  /* Find out how many of the menu items are buttons (nonzero id) */
  nbuttons = 0;
  for (i = 0; i < nanswers; i++)
    if ((panswers[i])->action_id != 0)
      nbuttons++;
  if (nbuttons <= 0) return(0);


  /* Create button table */
  pchoices = (jtp_button *)malloc(nbuttons*sizeof(jtp_button));
  if (pchoices == NULL)
  {
    OOM(0);
    return(0);
  }


  /* Fill button table */
  j = 0;
  for (i = 0; i < nanswers; i++)
  {
    if ((panswers[i])->action_id != 0)
    {
      pchoices[j].id = (panswers[i])->action_id;
      pchoices[j].text = (panswers[i])->str;
      pchoices[j].width = jtp_text_length(pchoices[j].text, JTP_FONT_BUTTON) + 11;
      pchoices[j].height = jtp_fonts[JTP_FONT_BUTTON].lineheight + 10;
      if (nbuttons == 1) pchoices[j].accelerator = '\r'; /* Enter */
      else pchoices[j].accelerator = pchoices[j].text[0];
      j++;
    }
  }


  /* Calculate width and height of dropdown menu */
  totalwidth = 0;
  totalheight = 0;
  j = 0;
  ncolumns = 1; column_height = 0;
  for (i = 0; i < nanswers; i++)
  {
    if ((panswers[i])->action_id != 0)
    {
      if (pchoices[j].width > totalwidth) totalwidth = pchoices[j].width;
      l = pchoices[j].height;
      if (column_height + l < jtp_screen.height)
        column_height += l;
      else
      {
        ncolumns++;
        if (column_height > totalheight) totalheight = column_height;
        column_height = l;
      }
      j++;
    }
    else
    {
      k = jtp_text_length((panswers[i])->str, JTP_FONT_HEADLINE);
      if (k > totalwidth) totalwidth = k;
      l = jtp_text_height((panswers[i])->str, JTP_FONT_HEADLINE);
      if (column_height + l < jtp_screen.height)
        column_height += l;
      else
      {
        ncolumns++;
        if (column_height > totalheight) totalheight = column_height;
        column_height = l;
      }
    }
  }


  buttons_width = totalwidth;
  totalwidth *= ncolumns;
  totalwidth += 6;
  if (column_height > totalheight) totalheight = column_height;
  totalheight += 6;
  
  /* Calculate position of dropdown menu */
  if (qx < 0) query_x = (jtp_screen.width - totalwidth) / 2;
  else if (qx < jtp_screen.width - totalwidth) query_x = qx;
  else query_x = jtp_screen.width - totalwidth;

  if (qy < 0) query_y = (jtp_screen.height - totalheight) / 2;
  else if (qy < jtp_screen.height - totalheight) query_y = qy;
  else query_y = jtp_screen.height - totalheight;

  /* Store background graphics */
  query_background = jtp_draw_dropdown_window(query_x, query_y, totalwidth, totalheight);

  /* Calculate menuitem positions and draw them */
  j = 0;
  k = query_x + 3;
  l = query_y + 3;
  for (i = 0; i < nanswers; i++)
  {
    if ((panswers[i])->action_id != 0)
    {
      pchoices[j].x = k;
      pchoices[j].y = l;
      pchoices[j].width = buttons_width;
      jtp_draw_button(pchoices[j].x, pchoices[j].y,
                      pchoices[j].width, pchoices[j].height,
                      pchoices[j].text);
      l += pchoices[j].height;
      if (l >= query_y + totalheight - 3)
      {
        l = query_y + 3;
        k += buttons_width;
      }
      j++;
    }
    else
    {
      /* Draw query message */
      jtp_put_text(k + 1,
                   l + jtp_fonts[JTP_FONT_HEADLINE].baseline + 1,
                   JTP_FONT_HEADLINE,
                   JTP_COLOR_BACKGROUND,
                   (panswers[i])->str,
                   jtp_screen.vpage);
      jtp_put_text(k,
                   l + jtp_fonts[JTP_FONT_HEADLINE].baseline,
                   JTP_FONT_HEADLINE,
                   JTP_COLOR_TEXT,
                   (panswers[i])->str,
                   jtp_screen.vpage);
      l += jtp_text_height((panswers[i])->str, JTP_FONT_HEADLINE);
      if (l >= query_y + totalheight - 3)
      {
        l = query_y + 3;
        k += buttons_width;
      }
    }
  }

  /* Display window */
  jtp_refresh(&jtp_screen);
  /* If the palette is faded out for some reason, restore it */
  jtp_updatepal(0, 255);

  if (nanswers == 0)
  {
    nchoice = jtp_getch();
  }
  else
  {
    /* Ask for input */
    while (nchoice < 0)
    {
      /* Wait for mouse click or key press */
      jtp_keymouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_LEFT);
      pressedkey = jtp_getch();
      if (pressedkey != 0)
      {
        if (nanswers == 1) nchoice = 0;
        else
        {
          for (i = 0; i < nbuttons; i++)
            if (pchoices[i].accelerator == pressedkey)
            {
              /* Wait until mouse button is released */
              jtp_press_button(pchoices[i].x+1, pchoices[i].y+1,
                               pchoices[i].x+pchoices[i].width-2,
                               pchoices[i].y+pchoices[i].height-2,
                               jtp_mcursor[JTP_CURSOR_NORMAL]);
              nchoice = i;
            }
        }
      }
      else if (jtp_mouseb != JTP_MBUTTON_NONE)
      {
        for (i = 0; i < nbuttons; i++)
          if (jtp_mouse_area(pchoices[i].x, pchoices[i].y,
                             pchoices[i].x+pchoices[i].width-1,
                             pchoices[i].y+pchoices[i].height-1))
          {
            /* Wait until mouse button is released */
            jtp_press_button(pchoices[i].x+1, pchoices[i].y+1,
                             pchoices[i].x+pchoices[i].width-2,
                             pchoices[i].y+pchoices[i].height-2,
                             jtp_mcursor[JTP_CURSOR_NORMAL]);
            nchoice = i;
          }
        if (nchoice < 0) nchoice = nbuttons+1;
      }
    }
  }

  /* Restore background */
  jtp_put_img(query_x, query_y, query_background);
  jtp_refresh(&jtp_screen);

  if (nchoice < nbuttons) i = pchoices[nchoice].id;
  else i = 0;
  
  /* Clean up */
  free(query_background);
  free(pchoices);

  /* Return the chosen answer */
  return(i);
}


void jtp_messagebox(const char *message)	/* Message to show player */
{
    jtp_query_choices(message, "Continue", 1);
}


void jtp_show_logo_screen(void)
{
  unsigned char *logo;
  
  jtp_play_event_sound("nhfe_music_main_title");

  if (iflags.wc_splash_screen)
  {
    logo = jtp_load_graphic(NULL, JTP_FILENAME_NETHACK_LOGO, TRUE);
    if (logo != NULL)
    {
      int w, h;
      
      jtp_get_dimensions(logo, &w, &h);
      /*
       * should stretch the image to fit screen,
       * but there is no such function, so just fill screen
       * with color in upper left corner.
       */
      jtp_rect(0, 0, jtp_screen.width - 1, jtp_screen.height - 1, logo[4]);
      jtp_put_img((jtp_screen.width - w) / 2, (jtp_screen.height - h) / 2, logo);
      jtp_blankpal(0, 255);
      jtp_refresh(&jtp_screen);
      jtp_game_palette_set = 0;
  
      jtp_fade_in(1.0);
      jtp_refresh(&jtp_screen);
      while (jtp_getch() == 0 && jtp_readmouse() == JTP_MBUTTON_NONE)
        jtp_usleep(5000);
      jtp_fade_out(0.3);
      
      free(logo);
    }
  }
      
  /* Restore regular game palette */
  memcpy(jtp_colors, jtp_game_colors, sizeof(jtp_colors));
  jtp_clear_screen();
  jtp_refresh(&jtp_screen);
  jtp_game_palette_set = 1;
}


static void jtp_view_messages(void)
{
  char tempbuffer[1024];
  winid window;
  jtp_window * msgwindow;
  int i, msgtime;
  
  msgwindow = jtp_find_window(WIN_MESSAGE);
  if (!msgwindow) return;
  
  /* 
   * Make a NHW_MENU window, add each message as a (textual) menu item.
   * This is a very unoptimized way of showing a text file ...
   */
  window = jtp_create_nhwindow(NHW_MENU);
  for (i = 0; i < msgwindow->curs_rows; i++)
  {
    if (msgwindow->rows[i])
    {
      msgtime = ((int *)msgwindow->rows[i])[0];
      sprintf(tempbuffer, "T:%d %s", msgtime, (char *)(msgwindow->rows[i]) + sizeof(int));
      jtp_putstr(window, ATR_NONE, tempbuffer);
    }  
  }  
  
  /* Display the messages */
  jtp_display_nhwindow(window, TRUE);
  
  /* Clean up */
  jtp_destroy_nhwindow(window);
}


void jtp_view_map(void)
{
  int x, y;
  int map_x, map_y;
  int i, j;
  int cur_glyph, cur_symbol;
  unsigned char * parchment_bg;
  char * temp_tooltip;
  int n_hotspots;
  jtp_hotspot ** map_hotspots;
  
  /* Find upper left corner of parchment */
  x = (jtp_screen.width - 640)/2;
  y = (jtp_screen.height - 480)/2;

  parchment_bg = jtp_get_img(x, y, x + 640-1, y + 480-1);

  /* Draw parchment */
  jtp_put_stencil(x, y, jtp_map_parchment_top);
  jtp_put_stencil(x, y + 480 - jtp_map_parchment_bottom[1], jtp_map_parchment_bottom);
  jtp_put_stencil(x, y, jtp_map_parchment_left);
  jtp_put_stencil(x + 640 - jtp_map_parchment_right[3], y, jtp_map_parchment_right);
  jtp_put_img(x + jtp_map_parchment_left[3], y + jtp_map_parchment_top[1], jtp_map_parchment_center);

  /* Find upper left corner of map on parchment */
  map_x = x + 39;
  map_y = y + 91;
  
  /* Draw map on parchment, and create hotspots */
  for (i = 0; i < JTP_MAP_HEIGHT; i++)
    for (j = 1; j < JTP_MAP_WIDTH; j++)
    {
      cur_glyph = jtp_mapglyph_cmap[i][j];
      cur_symbol = jtp_cmap_to_map_symbol(cur_glyph);

      if (cur_symbol >= 0)       
        jtp_put_img(map_x + 7*j, map_y + 14*i, jtp_map_symbols[cur_symbol]);
      
      cur_glyph = jtp_mapglyph_obj[i][j];
      cur_symbol = jtp_object_to_map_symbol(cur_glyph);
      if (cur_symbol >= 0) jtp_put_img(map_x + 7*j, map_y + 14*i, jtp_map_symbols[cur_symbol]);
      
      cur_glyph = jtp_mapglyph_mon[i][j];
      cur_symbol = jtp_monster_to_map_symbol(cur_glyph);
      if (cur_symbol >= 0) jtp_put_img(map_x + 7*j, map_y + 14*i, jtp_map_symbols[cur_symbol]);
    }

  /* DEBUG: show center of map window */
  jtp_fill_rect(map_x + 7*jtp_map_x, map_y + 14*jtp_map_y,
                map_x + 7*jtp_map_x + 6, map_y + 14*jtp_map_y + 13,
                15);

  /* Create hotspots */
  n_hotspots = 0;
  map_hotspots = NULL;
  for (i = 0; i < JTP_MAP_HEIGHT; i++)
    for (j = 1; j < JTP_MAP_WIDTH; j++)
    {
      temp_tooltip = jtp_choose_target_tooltip(j, i);
      if (temp_tooltip)
      {
        n_hotspots++;
        map_hotspots = (jtp_hotspot **)realloc(map_hotspots, n_hotspots*sizeof(jtp_hotspot *));
        map_hotspots[n_hotspots-1] = (jtp_hotspot *)malloc(sizeof(jtp_hotspot));
        (map_hotspots[n_hotspots-1])->mcursor = jtp_mcursor[JTP_CURSOR_NORMAL];
        (map_hotspots[n_hotspots-1])->tooltip = temp_tooltip;
        (map_hotspots[n_hotspots-1])->x1 = map_x + 7*j;
        (map_hotspots[n_hotspots-1])->x2 = map_x + 7*j + 6;
        (map_hotspots[n_hotspots-1])->y1 = map_y + 14*i;
        (map_hotspots[n_hotspots-1])->y2 = map_y + 14*i + 13;
        (map_hotspots[n_hotspots-1])->accelerator = 0;
      }
    }

  
  jtp_refresh(&jtp_screen);
  /* Wait for mouse button release, then wait for another mouse button click */
  jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
  jtp_get_mouse_inventory_input(jtp_mcursor[JTP_CURSOR_NORMAL], map_hotspots, n_hotspots, JTP_MBUTTON_LEFT);
  if (jtp_kbhit())
    (void) jtp_getch();
  jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);

  /* Restore background and clean up */
  jtp_put_img(x, y, parchment_bg);
  jtp_refresh(&jtp_screen);
  free(parchment_bg);
  if (n_hotspots > 0)
  {
    for (i = 0; i < n_hotspots; i++)
    {
      free((map_hotspots[i])->tooltip);
      free(map_hotspots[i]);
    }
    free(map_hotspots);
  }
}


static void trimright(char *buf)
{
	int i;
	
	i = strlen(buf) - 1;
	while (i >= 0 && (buf[i] == ' ' || buf[i] == '\n' || buf[i] == '\r'))
		i--;
	buf[i + 1] = '\0';
}


static void jtp_show_intro(const char *introscript_name)
{
  FILE   * f;
  int      i, j;
  int      nScenes;
  int    * subtitle_rows;
  char *** subtitles;
  char  ** scene_images;
  char   * tempbuffer;
  double  start_clock, cur_clock;
  int      lineno;
  unsigned char *image;
  int image_width = 0, image_height = 0;
  
  nScenes = 0;
  scene_images = NULL;
  subtitle_rows = NULL;
  subtitles = NULL;
  tempbuffer = (char *)malloc(1024);
  if (!tempbuffer)
  {
    OOM(1);
  }

  jtp_play_event_sound("nhfe_music_introduction");
  
  f = fopen(introscript_name, "rb");
  if (f == NULL)
  {
    jtp_write_log_message(JTP_LOG_NOTE, NULL, 0, "intro script %s not found\n", introscript_name);
  } else
  {
    lineno = 1;
    while (fgets(tempbuffer, 1024, f))
    {
      if (tempbuffer[0] == '%') /* Start of new scene */
      {
        trimright(&tempbuffer[1]);
        i = strlen(&tempbuffer[1]);
        if (i > 0)
        {
          char *dot;
          
          nScenes++;
          scene_images = (char **)realloc(scene_images, nScenes*sizeof(char *));
          scene_images[nScenes-1] = (char *)malloc((i + 1) * sizeof(*tempbuffer));
          if (!scene_images[nScenes - 1])
          {
            OOM(1);
          }
          strcpy(scene_images[nScenes - 1], tempbuffer + 1);
          dot = strrchr(scene_images[nScenes - 1], '.');
          if (dot != NULL)
          {
            if (strcmp(dot, ".pcx") == 0)
            {
              *dot = '\0';
            } else
            {
              jtp_write_log_message(JTP_LOG_NOTE, NULL, 0, "scene image %s not pcx?", scene_images[nScenes - 1]);
            }
          }
          subtitle_rows = (int *)realloc(subtitle_rows, nScenes * sizeof(int));

          subtitle_rows[nScenes - 1] = 0;
          subtitles = (char ***)realloc(subtitles, nScenes * sizeof(char **));

          subtitles[nScenes - 1] = NULL;
        }
      }
      else /* New subtitle line for latest scene */
      {
        if (nScenes > 0)
        {
          subtitle_rows[nScenes - 1]++;
          subtitles[nScenes - 1] = (char **)realloc(subtitles[nScenes - 1],
            subtitle_rows[nScenes - 1] * sizeof(char *));
          
          /* Remove extra whitespace from line */
          trimright(tempbuffer);
          i = 0;
          while (tempbuffer[i] == ' ')
            i++;
          trimright(&tempbuffer[i]);
          /* Copy line to subtitle array */
          subtitles[nScenes - 1][subtitle_rows[nScenes - 1] - 1] = (char *)malloc(strlen(tempbuffer + i) + 1);
          if (!subtitles[nScenes - 1][subtitle_rows[nScenes - 1] - 1])
          {
            OOM(1);
          }
          strcpy(subtitles[nScenes - 1][subtitle_rows[nScenes - 1] - 1], tempbuffer + i);
          /* DEBUG printf("%s", subtitles[nScenes-1][subtitle_rows[nScenes-1]-1]); DEBUG */
        } else
        {
          jtp_write_log_message(JTP_LOG_NOTE, NULL, 0, "subtitle without a preceding scene in line %d of intro script %s\n",
            lineno, introscript_name);
        }
      }
    }
    fclose(f);

    if (nScenes == 0)
    {
      jtp_write_log_message(JTP_LOG_NOTE, NULL, 0, "no scenes found in intro script %s\n", introscript_name);
    } else
    {
      /*
       * Show each scene of the introduction in four steps:
       * - Erase previous image, load and fade in new image
       * - Print the subtitles
       * - Wait out a set delay
       * - Erase subtitles, Fade out 
       */
      jtp_set_draw_region(0, 0, jtp_screen.width - 1, jtp_screen.height - 1);
      for (i = 0; i < nScenes; i++)
      {
        /* If we are starting, or the previous image was different, fade in the current image */
        if ((i <= 0) || (strcmp(scene_images[i], scene_images[i - 1]) != 0))
        {
          image = jtp_load_graphic(NULL, scene_images[i], TRUE);
          jtp_get_dimensions(image, &image_width, &image_height);
          jtp_clear_screen();
          jtp_put_img((jtp_screen.width - image_width) / 2, (jtp_screen.height - image_height) / 6, image);
          jtp_refresh(&jtp_screen);
          jtp_fade_in(0.2);
        }
        /* Show subtitles */
        for (j = 0; j < subtitle_rows[i]; j++)
        {
          jtp_put_text((jtp_screen.width - jtp_text_length(subtitles[i][j], JTP_FONT_INTRO)) / 2,
                 2 * (jtp_screen.height - image_height) / 6 + image_height +
                 j * jtp_fonts[JTP_FONT_INTRO].lineheight,
                 JTP_FONT_INTRO, JTP_COLOR_INTRO_TEXT,
                 subtitles[i][j],
                 jtp_screen.vpage);
        }
        jtp_refresh(&jtp_screen);
    
        /* Wait until scene is over or player pressed a key */
        /* FIXME: this is a busy loop with event polling;
           also should make the timeout depend on amount of text */
        start_clock = jtp_clocktick();
        cur_clock = start_clock;
        while (cur_clock - start_clock < 5)
        {
          cur_clock = jtp_clocktick();
          if (jtp_kbhit() || jtp_readmouse() != JTP_MBUTTON_NONE)
          {
            jtp_getch();
            cur_clock = start_clock + 7;
            i = nScenes;
          } else
          {
          	jtp_usleep(10000);
          }
        }
    
        /* Erase subtitles */
    
        jtp_fill_rect(0, (jtp_screen.height - image_height) / 6 + image_height,
                jtp_screen.width - 1, jtp_screen.height - 1, 0);
        jtp_refresh(&jtp_screen);
    
        /* If we are at the end, or the next image is different, fade out the current image */
        if ((i >= nScenes - 1) || (strcmp(scene_images[i], scene_images[i + 1]) != 0))
          jtp_fade_out(0.2);
      }
      
      /* Clean up */
      for (i = 0; i < nScenes; i++)
      {
        free(scene_images[i]);
        for (j = 0; j < subtitle_rows[i]; j++)
          free(subtitles[i][j]);
        if (subtitles[i] != NULL)
          free(subtitles[i]);
      }
      if (subtitle_rows != NULL)
        free(subtitle_rows);
      if (scene_images != NULL)
        free(scene_images);
    }
  }
  jtp_blankpal(0, 255);
  jtp_game_palette_set = 0;
}


void jtp_select_player(void)
{
  int i, j, k, n;
  winid win;
  anything any;
  menu_item *selected = 0;
  char thisch, lastch = 0;
  char pbuf[1024];
  char *logo;
  int w, h;
  char *filename;
  
  jtp_clear_screen();
  /*
   * FIXME: loading the palette here has to make
   * sure that it contains the colors needed for displaying menus.
   */
  logo = jtp_load_graphic(NULL, JTP_FILENAME_CHARACTER_GENERATION, TRUE);
  if (logo != NULL)
  {
    jtp_get_dimensions(logo, &w, &h);
    jtp_put_img((jtp_screen.width - w) / 2, (jtp_screen.height - h) / 2, logo);
    free(logo);
  }
  jtp_blankpal(0, 255);
  jtp_refresh(&jtp_screen);
  jtp_game_palette_set = 0;

  jtp_fade_in(0.2);

  /* Select a role, if necessary */
  /* we'll try to be compatible with pre-selected race/gender/alignment,
   * but may not succeed */
  if (flags.initrole < 0) 
  {
    /* Process the choice */
    if (flags.initrole == ROLE_RANDOM) 
    {
      /* Pick a random role */
      flags.initrole = pick_role(flags.initrace, flags.initgend, flags.initalign, PICK_RANDOM);
      if (flags.initrole < 0)
      {
/*
 * WE made the choice, not the player, so don't bother complaining.
 * BTW: if pick_role() returns < 0, no valid role could be found,
 * and we should better go back picking another race/gender/alignment.
 */
#if 0
        tty_putstr(BASE_WINDOW, 0, "Incompatible role!");
#endif
        flags.initrole = randrole();
      }
    }
    else
    {
      /* Prompt for a role */
      win = create_nhwindow(NHW_MENU);
      start_menu(win);
      any.a_void = 0;         /* zero out all bits */
      for (i = 0; roles[i].name.m; i++)
      {
        any.a_int = i + 1;    /* must be non-zero */
        thisch = lowc(roles[i].name.m[0]);
        if (thisch == lastch)
          thisch = highc(thisch);
        add_menu(win, NO_GLYPH, &any, thisch, 0, ATR_NONE, an(roles[i].name.m), MENU_UNSELECTED);
        lastch = thisch;
      }
      any.a_int = randrole() + 1;  /* must be non-zero */
      add_menu(win, NO_GLYPH, &any, '*', 0, ATR_NONE, "Random", MENU_SELECTED);
      any.a_int = i + 1;      /* must be non-zero */
      add_menu(win, NO_GLYPH, &any, 'q', 0, ATR_NONE, "Quit", MENU_UNSELECTED);
      end_menu(win, "Pick a role");
      n = select_menu(win, PICK_ONE, &selected);
      destroy_nhwindow(win);

      /* Process the choice */
      if (n != 1 || selected[0].item.a_int == any.a_int)
      {
        /* Selected quit */
        if (selected)
          free((genericptr_t) selected);
        bail((char *) 0);
        /*NOTREACHED*/
      }
      flags.initrole = selected[0].item.a_int - 1;
      free((genericptr_t) selected);
      selected = 0;
    }
  }

  /* Select a race, if necessary */
  /* force compatibility with role, try for compatibility with
   * pre-selected gender/alignment */
  if (flags.initrace < 0 || !validrace(flags.initrole, flags.initrace))
  {
    /* pre-selected race not valid */
    if (flags.initrace == ROLE_RANDOM)
    {
      flags.initrace = pick_race(flags.initrole, flags.initgend, flags.initalign, PICK_RANDOM);
      if (flags.initrace < 0)
      {
        jtp_messagebox("The selected race is incompatible with other options.\nChoosing a random race.\n");
        flags.initrace = randrace(flags.initrole);
      }
    }
    else
    {
      /* Select a race */
      if (!validrace(flags.initrole, flags.initrace))
        i = j = k = randrace(flags.initrole);
      else
        i = j = k = flags.initrace;

      /* Count the number of valid races */
      n = 0;
      do
      {
        if (validrace(flags.initrole, i))
          n++;
        else if ((i == k) && (!races[++k].noun))
          k = 0;

        if (!races[++i].noun)
          i = 0;
      } while (i != j);

      /* Permit the user to pick a race */
      if (!validrace(flags.initrole, flags.initrace))
      {
        win = create_nhwindow(NHW_MENU);
        start_menu(win);
        any.a_void = 0;         /* zero out all bits */
        for (i = 0; races[i].noun; i++)
          if (validrace(flags.initrole, i))
          {
            any.a_int = i + 1;  /* must be non-zero */
            add_menu(win, NO_GLYPH, &any, races[i].noun[0], 0, ATR_NONE, races[i].noun, MENU_UNSELECTED);
          }
        any.a_int = randrace(flags.initrole) + 1;
        add_menu(win, NO_GLYPH, &any, '*', 0, ATR_NONE, "Random", MENU_SELECTED);
        any.a_int = i + 1;      /* must be non-zero */
        add_menu(win, NO_GLYPH, &any, 'q', 0, ATR_NONE, "Quit", MENU_UNSELECTED);
        Sprintf(pbuf, "Pick the race of your %s", roles[flags.initrole].name.m);
        end_menu(win, pbuf);
        n = select_menu(win, PICK_ONE, &selected);
        destroy_nhwindow(win);
        if (n != 1 || selected[0].item.a_int == any.a_int)
        {
          /* Selected quit */
          if (selected)
            free((genericptr_t) selected);
          bail((char *) 0);
          /*NOTREACHED*/
        }

        k = selected[0].item.a_int - 1;
        free((genericptr_t) selected);
        selected = 0;
      }
      flags.initrace = k;
    }
  }


  /* Select a gender, if necessary */
  /* force compatibility with role/race, try for compatibility with
   * pre-selected alignment */
  if (flags.initgend < 0 || !validgend(flags.initrole, flags.initrace, flags.initgend))
  {
    if (flags.initgend == ROLE_RANDOM)
    {
      flags.initgend = pick_gend(flags.initrole, flags.initrace, flags.initalign, PICK_RANDOM);
      if (flags.initgend < 0)
      {
        jtp_messagebox("The selected gender is incompatible with other options.\nChoosing a random gender.\n");
        flags.initgend = randgend(flags.initrole, flags.initrace);
      }
    }
    else
    {
      /* Select a gender */
      if (!validgend(flags.initrole, flags.initrace, flags.initgend))
        /* Pick a random valid gender */
        i = j = k = randgend(flags.initrole, flags.initrace);
      else
        i = j = k = flags.initgend;

      /* Count the number of valid genders */
      n = 0;
      do
      {
        if (validgend(flags.initrole, flags.initrace, i))
          n++;
        else if ((i == k) && (++k >= ROLE_GENDERS))
          k = 0;

        if (++i >= ROLE_GENDERS)
          i = 0;
      } while (i != j);

      /* Permit the user to pick a gender */
      if (!validgend(flags.initrole, flags.initrace, flags.initgend))
      {
        win = create_nhwindow(NHW_MENU);
        start_menu(win);
        any.a_void = 0;         /* zero out all bits */
        for (i = 0; i < ROLE_GENDERS; i++)
          if (validgend(flags.initrole, flags.initrace, i))
          {
            any.a_int = i + 1;  /* must be non-zero */
            add_menu(win, NO_GLYPH, &any, genders[i].adj[0], 0, ATR_NONE, genders[i].adj, MENU_UNSELECTED);
          }
        any.a_int = randgend(flags.initrole, flags.initrace) + 1;
        add_menu(win, NO_GLYPH, &any, '*', 0, ATR_NONE, "Random", MENU_SELECTED);
        any.a_int = i + 1;      /* must be non-zero */
        add_menu(win, NO_GLYPH, &any, 'q', 0, ATR_NONE, "Quit", MENU_UNSELECTED);
        sprintf(pbuf, "Pick the gender of your %s %s", races[flags.initrace].adj, roles[flags.initrole].name.m);
        end_menu(win, pbuf);
        n = select_menu(win, PICK_ONE, &selected);
        destroy_nhwindow(win);
        if (n != 1 || selected[0].item.a_int == any.a_int)
        {
          /* Selected quit */
          if (selected)
            free((genericptr_t) selected);
          bail((char *) 0);
          /*NOTREACHED*/
        }

        k = selected[0].item.a_int - 1;
        free((genericptr_t) selected);
        selected = 0;
      }
      flags.initgend = k;
    }
  }

  /* Select an alignment, if necessary */
  /* force compatibility with role/race/gender */
  if (flags.initalign < 0 || !validalign(flags.initrole, flags.initrace, flags.initalign))
  {
    if (flags.initalign == ROLE_RANDOM)
    {
      flags.initalign = pick_align(flags.initrole, flags.initrace, flags.initgend, PICK_RANDOM);
      if (flags.initalign < 0)
      {
        jtp_messagebox("The selected alignment is incompatible with other options.\nChoosing a random alignment.\n");
        flags.initalign = randalign(flags.initrole, flags.initrace);
      }
    }
    else
    {
      /* Select an alignment */
      if (!validalign(flags.initrole, flags.initrace, flags.initalign))
        /* Pick a random valid alignment */
        i = j = k = randalign(flags.initrole, flags.initrace);
      else
        i = j = k = flags.initalign;
      /* Count the number of valid alignments */
      n = 0;
      do
      {
        if (validalign(flags.initrole, flags.initrace, i))
          n++;
        else if ((i == k) && (++k >= ROLE_ALIGNS))
          k = 0;

        if (++i >= ROLE_ALIGNS)
          i = 0;
      } while (i != j);

      /* Permit the user to pick, if there is more than one */
      if (!validalign(flags.initrole, flags.initrace, flags.initalign))
      {
        win = create_nhwindow(NHW_MENU);
        start_menu(win);
        any.a_void = 0;         /* zero out all bits */
        for (i = 0; i < ROLE_ALIGNS; i++)
          if (validalign(flags.initrole, flags.initrace, i))
          {
            any.a_int = i + 1;  /* must be non-zero */
            add_menu(win, NO_GLYPH, &any, aligns[i].adj[0], 0, ATR_NONE, aligns[i].adj, MENU_UNSELECTED);
          }
        any.a_int = randalign(flags.initrole, flags.initrace) + 1;
        add_menu(win, NO_GLYPH, &any, '*', 0, ATR_NONE, "Random", MENU_SELECTED);
        any.a_int = i + 1;      /* must be non-zero */
        add_menu(win, NO_GLYPH, &any, 'q', 0, ATR_NONE, "Quit", MENU_UNSELECTED);
        sprintf(pbuf, "Pick the alignment of your %s %s %s",
            genders[flags.initgend].adj,
            races[flags.initrace].adj,
            (flags.initgend && roles[flags.initrole].name.f) ?
            roles[flags.initrole].name.f :
            roles[flags.initrole].name.m);
        end_menu(win, pbuf);
        n = select_menu(win, PICK_ONE, &selected);
        destroy_nhwindow(win);
        if (n != 1 || selected[0].item.a_int == any.a_int)
        {
          /* Selected quit */
          if (selected)
            free((genericptr_t) selected);
          bail((char *) 0);
          /*NOTREACHED*/
        }

        k = selected[0].item.a_int - 1;
        free((genericptr_t) selected);
        selected = 0;
      }
      flags.initalign = k;
    }
  }
  
  
  /* Success! Show introduction. */
  jtp_fade_out(0.2);
  filename = jtp_make_filename(JTP_CONFIG_DIRECTORY, NULL, JTP_FILENAME_INTRO_SCRIPT);
  jtp_show_intro(filename);
  free(filename);
  
  /* Restore regular game palette */
  memcpy(jtp_colors, jtp_game_colors, sizeof(jtp_colors));
  jtp_clear_screen();
  jtp_refresh(&jtp_screen);
  jtp_updatepal(0, 255);
  jtp_game_palette_set = 1;  
}

static int jtp_construct_shortcut_action(
  int tgtx, int tgty, /* Target square, or item accelerator in tgtx */
  int action_id       /* Shortcut action type */
)
{
  jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "jtp_construct_shortcut_action\n");

  switch(action_id)
  {
    case JTP_ACTION_CHAT:
    case JTP_ACTION_KICK:
    case JTP_ACTION_CLOSE_DOOR:
    case JTP_ACTION_OPEN_DOOR:
    case JTP_ACTION_FORCE_LOCK:
    case JTP_ACTION_UNTRAP:
      jtp_is_shortcut_active = 1;
      if (tgtx == u.ux-1)
      {
        if (tgty == u.uy-1) jtp_shortcut_query_response = jtp_translate_command(JTP_NHCMD_NORTHWEST);
        if (tgty == u.uy) jtp_shortcut_query_response = jtp_translate_command(JTP_NHCMD_WEST);
        if (tgty == u.uy+1) jtp_shortcut_query_response = jtp_translate_command(JTP_NHCMD_SOUTHWEST);

      }
      else if (tgtx == u.ux)
      {
        if (tgty == u.uy-1) jtp_shortcut_query_response = jtp_translate_command(JTP_NHCMD_NORTH);
        if (tgty == u.uy) jtp_shortcut_query_response = jtp_translate_command(JTP_NHCMD_REST);
        if (tgty == u.uy+1) jtp_shortcut_query_response = jtp_translate_command(JTP_NHCMD_SOUTH);
      }
      if (tgtx == u.ux+1)
      {
        if (tgty == u.uy-1) jtp_shortcut_query_response = jtp_translate_command(JTP_NHCMD_NORTHEAST);
        if (tgty == u.uy) jtp_shortcut_query_response = jtp_translate_command(JTP_NHCMD_EAST);
        if (tgty == u.uy+1) jtp_shortcut_query_response = jtp_translate_command(JTP_NHCMD_SOUTHEAST);
      }
      break;
    case JTP_ACTION_WHATS_THIS:
      jtp_is_shortcut_active = 1;
      jtp_shortcut_query_response = 'y';
      break;
    case JTP_ACTION_EAT_ITEM:
    case JTP_ACTION_DRINK_ITEM:
    case JTP_ACTION_READ_ITEM:
    case JTP_ACTION_DROP_ITEM:
    case JTP_ACTION_WEAR_ITEM:
    case JTP_ACTION_PUT_ON_ITEM:
    case JTP_ACTION_WIELD_ITEM:
    case JTP_ACTION_APPLY_ITEM:
    case JTP_ACTION_ZAP_ITEM:
    case JTP_ACTION_REMOVE_ITEM:
    case JTP_ACTION_CAST_SPELL:
      jtp_is_shortcut_active = 1;
      jtp_shortcut_query_response = tgtx;
      break;
    default:
      jtp_is_shortcut_active = 0;
      break;
  }
  switch(action_id)
  {
    case JTP_ACTION_CLOSE_DOOR: return(jtp_translate_command(JTP_NHCMD_CLOSE_DOOR)); break;
    case JTP_ACTION_DRINK: return(jtp_translate_command(JTP_NHCMD_QUAFF)); break;
    case JTP_ACTION_ENGRAVE: return(jtp_translate_command(JTP_NHCMD_ENGRAVE)); break;
    case JTP_ACTION_GO_DOWN: return(jtp_translate_command(JTP_NHCMD_DOWN)); break;
    case JTP_ACTION_GO_UP: return(jtp_translate_command(JTP_NHCMD_UP)); break;
    case JTP_ACTION_KICK: return(jtp_translate_command(JTP_NHCMD_KICK)); break;
    case JTP_ACTION_OPEN_DOOR: return(jtp_translate_command(JTP_NHCMD_OPEN_DOOR)); break;
    case JTP_ACTION_PAY_BILL: return(jtp_translate_command(JTP_NHCMD_PAY_BILL)); break;
    case JTP_ACTION_PICK_UP: return(jtp_translate_command(JTP_NHCMD_PICKUP)); break;
    case JTP_ACTION_REST: return(jtp_translate_command(JTP_NHCMD_REST)); break;
    case JTP_ACTION_SEARCH: return(jtp_translate_command(JTP_NHCMD_SEARCH)); break;
    case JTP_ACTION_LOOK_AROUND: return(jtp_translate_command(JTP_NHCMD_LOOK_HERE)); break;

    case JTP_ACTION_CHAT: return(jtp_translate_command(JTP_NHCMD_CHAT)); break;
    case JTP_ACTION_FORCE_LOCK: return(jtp_translate_command(JTP_NHCMD_FORCE_LOCK)); break;
    case JTP_ACTION_LOOT: return(jtp_translate_command(JTP_NHCMD_LOOT)); break;
    case JTP_ACTION_MONSTER_ABILITY: return(jtp_translate_command(JTP_NHCMD_MONSTER_ABILITY)); break;
    case JTP_ACTION_PRAY: return(jtp_translate_command(JTP_NHCMD_PRAY)); break;
    case JTP_ACTION_SIT: return(jtp_translate_command(JTP_NHCMD_SIT)); break;
    case JTP_ACTION_TURN_UNDEAD: return(jtp_translate_command(JTP_NHCMD_TURN_UNDEAD)); break;
    case JTP_ACTION_UNTRAP: return(jtp_translate_command(JTP_NHCMD_UNTRAP)); break;
    case JTP_ACTION_WIPE_FACE: return(jtp_translate_command(JTP_NHCMD_WIPE_FACE)); break;

    case JTP_ACTION_ATTACK:
    case JTP_ACTION_ENTER_TRAP:
    case JTP_ACTION_PUSH_BOULDER:
      if (tgtx == u.ux-1)
      {
        if (tgty == u.uy-1) return(jtp_translate_command(JTP_NHCMD_NORTHWEST));
        if (tgty == u.uy) return(jtp_translate_command(JTP_NHCMD_WEST));
        if (tgty == u.uy+1) return(jtp_translate_command(JTP_NHCMD_SOUTHWEST));
      }
      else if (tgtx == u.ux)
      {
        if (tgty == u.uy-1) return(jtp_translate_command(JTP_NHCMD_NORTH));
        if (tgty == u.uy) return(jtp_translate_command(JTP_NHCMD_REST));
        if (tgty == u.uy+1) return(jtp_translate_command(JTP_NHCMD_SOUTH));
      }
      if (tgtx == u.ux+1)
      {
        if (tgty == u.uy-1) return(jtp_translate_command(JTP_NHCMD_NORTHEAST));
        if (tgty == u.uy) return(jtp_translate_command(JTP_NHCMD_EAST));
        if (tgty == u.uy+1) return(jtp_translate_command(JTP_NHCMD_SOUTHEAST));
      }
      break;

    case JTP_ACTION_MOVE_HERE:
        u.tx = tgtx;
        u.ty = tgty;
        return(CMD_TRAVEL);
        break;

    case JTP_ACTION_WHATS_THIS:
        jtp_move_length = 2;
        jtp_autopilot_type = JTP_AUTOPILOT_WHATSTHIS;
        jtp_movebuffer[0] = tgty*JTP_MAP_WIDTH+tgtx;
        jtp_movebuffer[1] = -1;
        return(jtp_translate_command(JTP_NHCMD_EXPLAIN_SYMBOL));
        break;

    case JTP_ACTION_EAT_ITEM: return(jtp_translate_command(JTP_NHCMD_EAT)); break;
    case JTP_ACTION_DRINK_ITEM: return(jtp_translate_command(JTP_NHCMD_QUAFF)); break;
    case JTP_ACTION_READ_ITEM: return(jtp_translate_command(JTP_NHCMD_READ)); break;
    case JTP_ACTION_DROP_ITEM: return(jtp_translate_command(JTP_NHCMD_DROP)); break;
    case JTP_ACTION_WEAR_ITEM: return(jtp_translate_command(JTP_NHCMD_WEAR_ARMOR)); break;
    case JTP_ACTION_PUT_ON_ITEM: return(jtp_translate_command(JTP_NHCMD_PUT_ON_ACCESSORY)); break;
    case JTP_ACTION_WIELD_ITEM: return(jtp_translate_command(JTP_NHCMD_WIELD_WEAPON)); break;
    case JTP_ACTION_APPLY_ITEM: return(jtp_translate_command(JTP_NHCMD_APPLY)); break;
    case JTP_ACTION_ZAP_ITEM: return(jtp_translate_command(JTP_NHCMD_ZAP)); break;
    case JTP_ACTION_REMOVE_ITEM: return(jtp_translate_command(JTP_NHCMD_REMOVE_ITEM)); break;
    case JTP_ACTION_CAST_SPELL: return(jtp_translate_command(JTP_NHCMD_CAST_SPELL)); break;

  }
  return 0;
}


static void jtp_add_dropdown_action(
  int *n_actions,
  jtp_dropdown_action *** dropdown_actions,
  int action_id,
  char * action_str
)
{
  int i, j;
  jtp_dropdown_action * temp_action;


  i = *n_actions;
  *dropdown_actions = (jtp_dropdown_action **)realloc(*dropdown_actions, (i+1)*sizeof(jtp_dropdown_action *));
  if (*dropdown_actions == NULL)
  {
    OOM(0);
    return;
  }
  temp_action = (jtp_dropdown_action *)malloc(sizeof(jtp_dropdown_action));
  if (temp_action == NULL)
  {
    OOM(0);
    return;
  }

  temp_action->action_id = action_id;
  if (!action_str) temp_action->str = NULL;
  else
  {
    j = strlen(action_str);
    temp_action->str = malloc(j+1);
    if (temp_action->str == NULL)
    {
      OOM(0);
      return;
    }
    memcpy(temp_action->str, action_str, j+1);
  }
  (*dropdown_actions)[i] = temp_action;
  *n_actions = i+1;
}
  

static int jtp_get_dropdown_command(int mx, int my, int tgtx, int tgty)
{
  jtp_dropdown_action ** dropdown_actions;
  int n_actions, selected_action = JTP_ACTION_NONE;
  int mapglyph_offset;
  int i;
  char * mapsquare_descr;


  /* Dropdown commands are shown only for valid squares */
  if ((tgtx < 1) || (tgtx >= JTP_MAP_WIDTH) || (tgty < 0) || (tgty >= JTP_MAP_HEIGHT))
    return(0);

  /* Construct a context-sensitive drop-down menu */
  dropdown_actions = NULL;
  n_actions = 0;

  if ((u.ux == tgtx) && (u.uy == tgty))
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, 0, plname);
  else
  {
    mapsquare_descr = jtp_map_square_description(tgtx, tgty, 0);
    if (mapsquare_descr)
    {
      jtp_add_dropdown_action(&n_actions, &dropdown_actions, 0, mapsquare_descr);
      free(mapsquare_descr);
    }
  }

  if ((u.ux == tgtx) && (u.uy == tgty))
  {
    /* Add personal options: */
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_ENGRAVE, "Engrave");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_LOOK_AROUND, "Look around");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_MONSTER_ABILITY, "Monster ability");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_PAY_BILL, "Pay bill");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_PRAY, "Pray");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_REST, "Rest");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_SEARCH, "Search");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_SIT, "Sit");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_TURN_UNDEAD, "Turn undead");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_WIPE_FACE, "Wipe face");
  }
  else if (jtp_mapglyph_mon[tgty][tgtx] >= 0)
  {
    /* Add monster options: */
    if ((u.ux != tgtx) || (u.uy != tgty))
      if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
        {
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_CHAT, "Chat");
          /* jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_RIDE, "Ride"); */
        }
  }

  if (jtp_mapglyph_obj[tgty][tgtx] >= 0)
  {
    /* Add object options: */
    mapglyph_offset =  jtp_mapglyph_obj[tgty][tgtx];
    switch(mapglyph_offset)
    {
      case LARGE_BOX: case ICE_BOX: case CHEST:
        if ((u.ux == tgtx) && (u.uy == tgty))
        {
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_FORCE_LOCK, "Force lock");
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_LOOT, "Loot");
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_PICK_UP, "Pick up");
        }
        if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_UNTRAP, "Untrap");
        break;
      case SACK: case OILSKIN_SACK: case BAG_OF_HOLDING: case BAG_OF_TRICKS:
        if ((u.ux == tgtx) && (u.uy == tgty))
        {
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_LOOT, "Loot");
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_PICK_UP, "Pick up");
        }
        break;
      case BOULDER:
        if ((u.ux != tgtx) || (u.uy != tgty))
          if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_PUSH_BOULDER, "Push");
        break;
      default:
        if ((u.ux == tgtx) && (u.uy == tgty))        
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_PICK_UP, "Pick up");
        break;      
    }
  }
  if (jtp_mapglyph_cmap[tgty][tgtx] >= 0)
  {
    /* Add cmap options: */
    mapglyph_offset =  jtp_mapglyph_cmap[tgty][tgtx];
    switch(mapglyph_offset)
    {
      case S_vodoor: case S_hodoor:
        if ((u.ux != tgtx) || (u.uy != tgty))
          if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
          {
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_CLOSE_DOOR, "Close door");
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_UNTRAP, "Untrap");
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_KICK, "Kick");
          }
        break;
      case S_vcdoor: case S_hcdoor:
        if ((u.ux != tgtx) || (u.uy != tgty))
          if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
          {
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_OPEN_DOOR, "Open door");
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_UNTRAP, "Untrap");
            /* jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_FORCE_LOCK, "Force lock"); */
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_KICK, "Kick");
          }
        break;
      case S_dnstair: case S_dnladder:
        if ((u.ux == tgtx) && (u.uy == tgty))
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_GO_DOWN, "Go down");
        if ((u.ux != tgtx) || (u.uy != tgty))
          if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_KICK, "Kick");
        break;
      case S_upstair: case S_upladder:
        if ((u.ux == tgtx) && (u.uy == tgty))
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_GO_UP, "Go up");
        if ((u.ux != tgtx) || (u.uy != tgty))
          if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_KICK, "Kick");
        break;
      case S_fountain:
        if ((u.ux == tgtx) && (u.uy == tgty))
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_DRINK, "Drink");
        if ((u.ux != tgtx) || (u.uy != tgty))
          if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_KICK, "Kick");
        break;
      default:
        if (glyph_is_trap(jtp_mapglyph_cmap[tgty][tgtx] + GLYPH_CMAP_OFF))
        {
          jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_UNTRAP, "Untrap");
          if ((u.ux != tgtx) || (u.uy != tgty))
            if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
              jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_ENTER_TRAP, "Enter trap");
        }
        if ((u.ux != tgtx) || (u.uy != tgty))
          if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
            jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_KICK, "Kick");
        break;
    }
    if ((u.ux != tgtx) || (u.uy != tgty))    
      jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_MOVE_HERE, "Move here");
    jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_WHATS_THIS, "What's this?");
  }


  if (n_actions > 0)
  {
    selected_action = jtp_dropdown(mx, my, n_actions, dropdown_actions);
    for (i = 0; i < n_actions; i++)
    {
      free(dropdown_actions[i]->str);
      free(dropdown_actions[i]);
    }
    free(dropdown_actions);
  }


  if (selected_action == JTP_ACTION_NONE) return(0);
  else return(jtp_construct_shortcut_action(tgtx, tgty, selected_action));
}

static int jtp_get_default_command(int tgtx, int tgty)
{
  int selected_action;
  int mapglyph_offset;

  /* Off-map squares have no default action */
  if ((tgtx < 1) || (tgtx >= JTP_MAP_WIDTH) ||
      (tgty < 0) || (tgty >= JTP_MAP_HEIGHT))
    return(0);

  /* Select a default command */
  selected_action = 0;

  /* Target is at least 2 squares away */
  if ((abs(u.ux-tgtx) >= 2) || (abs(u.uy-tgty) >= 2))
    selected_action = JTP_ACTION_MOVE_HERE;
 
  /* Monster on target square */
  if ((!selected_action) && (jtp_mapglyph_mon[tgty][tgtx] >= 0))
  {
    if ((u.ux != tgtx) || (u.uy != tgty))
      selected_action = JTP_ACTION_ATTACK;
  }

  /* Object on target square */
  if ((!selected_action) && (jtp_mapglyph_obj[tgty][tgtx] >= 0))
  {
    mapglyph_offset = jtp_mapglyph_cmap[tgty][tgtx];
    if ((u.ux == tgtx) && (u.uy == tgty))
      switch(mapglyph_offset)
      {
        case LARGE_BOX: case ICE_BOX: case CHEST:
          selected_action = JTP_ACTION_LOOT; break;
        default:
          selected_action = JTP_ACTION_PICK_UP; break;
      }
    else selected_action = JTP_ACTION_MOVE_HERE;     
  }

  /* map feature on target square  */
  if ((!selected_action) && (jtp_mapglyph_cmap[tgty][tgtx] >= 0))
  {
    /* Add cmap options: */
    mapglyph_offset =  jtp_mapglyph_cmap[tgty][tgtx];
    if ((mapglyph_offset == S_dnstair) || (mapglyph_offset == S_dnladder))
      if ((u.ux == tgtx) && (u.uy == tgty))
        selected_action = JTP_ACTION_GO_DOWN;
    if ((mapglyph_offset == S_upstair) || (mapglyph_offset == S_upladder))
      if ((u.ux == tgtx) && (u.uy == tgty))
        selected_action = JTP_ACTION_GO_UP;
    if (mapglyph_offset == S_sink)
      if ((u.ux != tgtx) || (u.uy != tgty))
        if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
          selected_action = JTP_ACTION_KICK;
    if ((mapglyph_offset == S_vcdoor) || (mapglyph_offset == S_hcdoor))
      if ((u.ux != tgtx) || (u.uy != tgty))
        if ((abs(u.ux-tgtx) <= 1) && (abs(u.uy-tgty) <= 1))
          selected_action = JTP_ACTION_OPEN_DOOR;
    if (mapglyph_offset == S_fountain)
      if ((u.ux == tgtx) && (u.uy == tgty))        
        selected_action = JTP_ACTION_DRINK;
  }
  /* default action for your own square */
  if ((!selected_action) && (u.ux == tgtx) && (u.uy == tgty))
    selected_action = JTP_ACTION_SEARCH;

  /* default action for adjacent squares (nonadjacent squares were handled further up)*/
  if (!selected_action)
    if ((u.ux != tgtx) || (u.uy != tgty))
      selected_action = JTP_ACTION_ATTACK;

  if (!selected_action) return(0);
  else return(jtp_construct_shortcut_action(tgtx, tgty, selected_action));
}


void jtp_view_inventory(void)
{
  int x, y;
  int inven_x, inven_y;
  int total_selectable_items;
  int selectable_items;
  int i;
  int quit_viewing_inventory;
  int inventory_page_changed;
  int pressedkey;
  unsigned char * backpack_bg;

  jtp_window * menuwindow;
  jtp_menu * menu;
  int firstitem_index;
  jtp_menuitem * tempmenuitem;
  int item_x, item_y, item_index, item_tile;

  jtp_hotspot ** inven_hotspots;
  int n_hotspots;
  int selected_hotspot;

  jtp_dropdown_action ** dropdown_actions;
  int n_actions;
  int selected_action;

  /* Find upper left corner of backpack */
  x = (jtp_screen.width - 640)/2;
  y = (jtp_screen.height - 480)/2;

  backpack_bg = jtp_get_img(x, y, x + 640-1, y + 480-1);

  /* Draw parchment */
  jtp_put_stencil(x, y, jtp_backpack_top);
  jtp_put_stencil(x, y + 480 - jtp_backpack_bottom[1], jtp_backpack_bottom);
  jtp_put_stencil(x, y, jtp_backpack_left);
  jtp_put_stencil(x + 640 - jtp_backpack_right[3], y, jtp_backpack_right);

  /* Find upper left corner of inventory on backpack */
  inven_x = x + 113;
  inven_y = y + 106;

  menuwindow = jtp_find_window(WIN_INVEN);
  if (!menuwindow) return;
  menu = menuwindow->menu;
  if ((!menu) || (!menu->items)) return;

  /* Find out total number of selectable items in inventory */
  total_selectable_items = 0;
  jtp_list_reset(menu->items);
  tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
  while (tempmenuitem)
  {
    if (tempmenuitem->count != JTP_NOT_SELECTABLE)     
      total_selectable_items++;
    jtp_list_advance(menu->items);
    tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
  }

  quit_viewing_inventory = 0;
  inventory_page_changed = 1;
  firstitem_index = 0;
  inven_hotspots = NULL;
  n_hotspots = 0;

  /* Wait for mouse button release, then display the inventory */
  jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);

  while (!quit_viewing_inventory)
  {
    if (inventory_page_changed)
    {
      /* Clean up previous hotspots */
      if (n_hotspots > 0)
      {
        for (i = 0; i < n_hotspots; i++)
        {
          free((inven_hotspots[i])->tooltip);
          free(inven_hotspots[i]);
        }
        free(inven_hotspots);
        inven_hotspots = NULL;
        n_hotspots = 0;
      }

      /* Draw inventory on backpack, and create hotspots */
      jtp_put_img(x + jtp_backpack_left[3], y + jtp_backpack_top[1], jtp_backpack_center);

      /* Find the first selectable item to be displayed */
      item_index = -1;
      jtp_list_reset(menu->items);
      tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
      while ((tempmenuitem) && (item_index < firstitem_index))
      {
        if (tempmenuitem->count != JTP_NOT_SELECTABLE)
          item_index++;
        if (item_index < firstitem_index)
        {
          jtp_list_advance(menu->items);
          tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
        }
      }
      
      item_x = inven_x;
      item_y = inven_y;
      selectable_items = 0; /* None shown so far */
      while ((tempmenuitem) && (selectable_items < 25))
      {
        if (tempmenuitem->count != JTP_NOT_SELECTABLE)     
        {
          int color;
          int glyph = glyph_to_obj(tempmenuitem->glyph);
          item_tile = jtp_object_to_tile(glyph_to_obj(tempmenuitem->glyph));
          if (
               ((item_tile == JTP_TILE_SACK ||
                 item_tile == JTP_TILE_OILSKIN_SACK ||
                 item_tile == JTP_TILE_BAG_OF_HOLDING ||
                 item_tile == JTP_TILE_BAG_OF_TRICKS
                ) && !objects[glyph].oc_name_known)
             )
          {
              item_tile = JTP_TILE_UNIDENTIFIED_BAG;
          }
          else if (
               ((item_tile == JTP_TILE_LOADSTONE ||
                 item_tile == JTP_TILE_LUCKSTONE ||
                 item_tile == JTP_TILE_FLINT ||
                 item_tile == JTP_TILE_TOUCHSTONE
#ifdef HEALTHSTONE /* only in SlashEM */
               || item_tile == JTP_TILE_HEALTHSTONE
#endif
#ifdef WHETSTONE /* only in SlashEM */
               || item_tile == JTP_TILE_WHETSTONE
#endif
                ) && !objects[glyph].oc_name_known)
             )
          {
              item_tile = JTP_TILE_STONE;
          }
          else if (
               ((item_tile == JTP_TILE_DILITHIUM_CRYSTAL ||
                 item_tile == JTP_TILE_DIAMOND ||
                 item_tile == JTP_TILE_RUBY ||
                 item_tile == JTP_TILE_JACINTH ||
                 item_tile == JTP_TILE_SAPPHIRE ||
                 item_tile == JTP_TILE_BLACK_OPAL ||
                 item_tile == JTP_TILE_EMERALD ||
                 item_tile == JTP_TILE_TURQUOISE ||
                 item_tile == JTP_TILE_CITRINE ||
                 item_tile == JTP_TILE_AQUAMARINE ||
                 item_tile == JTP_TILE_AMBER ||
                 item_tile == JTP_TILE_TOPAZ ||
                 item_tile == JTP_TILE_JET ||
                 item_tile == JTP_TILE_OPAL ||
                 item_tile == JTP_TILE_CHRYSOBERYL ||
                 item_tile == JTP_TILE_GARNET ||
                 item_tile == JTP_TILE_AMETHYST ||
                 item_tile == JTP_TILE_JASPER ||
                 item_tile == JTP_TILE_FLUORITE ||
                 item_tile == JTP_TILE_OBSIDIAN ||
                 item_tile == JTP_TILE_AGATE ||
                 item_tile == JTP_TILE_JADE
                ) && !objects[glyph].oc_name_known)
             )
         {
         	 color = objects[glyph].oc_color;
             switch (color)
             {
                  case CLR_RED:
                      item_tile = JTP_TILE_RED_GLASS;
                      break;
                  case CLR_BLACK:
                      item_tile = JTP_TILE_BLACK_GLASS;
                      break;
                  case CLR_GREEN:
                      item_tile = JTP_TILE_GREEN_GLASS;
                      break;
                  case CLR_BROWN:
                      item_tile = JTP_TILE_BROWN_GLASS;
                      break;
                  case CLR_MAGENTA:
                      item_tile = JTP_TILE_VIOLET_GLASS;
                      break;
                  case CLR_ORANGE:
                      item_tile = JTP_TILE_ORANGE_GLASS;
                      break;
                  case CLR_YELLOW:
                      item_tile = JTP_TILE_YELLOW_GLASS;
                      break;
                  case CLR_WHITE:
                      item_tile = JTP_TILE_WHITE_GLASS;
                      break;
                  case CLR_BLUE:
                      item_tile = JTP_TILE_BLUE_GLASS;
                      break;
                  default:
                      item_tile = JTP_TILE_BLACK_GLASS;
                      break;
              }
          }
          
          if ((item_tile != JTP_TILE_INVALID) && (jtp_tiles[item_tile]))
            jtp_put_tile(item_x + jtp_tiles[item_tile]->xmod,
                         item_y + jtp_tiles[item_tile]->ymod,
                         JTP_MAX_SHADES-1,
                         jtp_tiles[item_tile]->graphic);

          n_hotspots++;
          inven_hotspots = (jtp_hotspot **)realloc(inven_hotspots, n_hotspots*sizeof(jtp_hotspot *));
          inven_hotspots[n_hotspots-1] = (jtp_hotspot *)malloc(sizeof(jtp_hotspot));
          (inven_hotspots[n_hotspots-1])->mcursor = jtp_mcursor[JTP_CURSOR_NORMAL];
          (inven_hotspots[n_hotspots-1])->tooltip = jtp_make_tooltip(tempmenuitem->text);
          (inven_hotspots[n_hotspots-1])->x1 = item_x - 49;
          (inven_hotspots[n_hotspots-1])->x2 = item_x + 48;
          (inven_hotspots[n_hotspots-1])->y1 = item_y - 17;
          (inven_hotspots[n_hotspots-1])->y2 = item_y + 18;
          (inven_hotspots[n_hotspots-1])->accelerator = tempmenuitem->accelerator;

          selectable_items++;
          item_x = inven_x + (selectable_items%5)*100;
          item_y = inven_y + (selectable_items/5)*60;
        }
        jtp_list_advance(menu->items);
        tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
      }
      /* Add the 'flip page'-arrow hotspots */
      if (firstitem_index > 0) /* Add 'previous page' arrow */
      {
        n_hotspots++;
        inven_hotspots = (jtp_hotspot **)realloc(inven_hotspots, n_hotspots*sizeof(jtp_hotspot *));
        inven_hotspots[n_hotspots-1] = (jtp_hotspot *)malloc(sizeof(jtp_hotspot));
        (inven_hotspots[n_hotspots-1])->mcursor = jtp_mcursor[JTP_CURSOR_NORMAL];
        (inven_hotspots[n_hotspots-1])->tooltip = jtp_make_tooltip("Previous page");
        (inven_hotspots[n_hotspots-1])->x1 = x + 71;
        (inven_hotspots[n_hotspots-1])->x2 = x + 193;
        (inven_hotspots[n_hotspots-1])->y1 = y + 410;
        (inven_hotspots[n_hotspots-1])->y2 = y + 443;
        (inven_hotspots[n_hotspots-1])->accelerator = JTP_KEY_MENU_SCROLLPAGEUP;
      }
      if (total_selectable_items - firstitem_index > 25) /* Add 'next page' arrow */
      {
        n_hotspots++;
        inven_hotspots = (jtp_hotspot **)realloc(inven_hotspots, n_hotspots*sizeof(jtp_hotspot *));
        inven_hotspots[n_hotspots-1] = (jtp_hotspot *)malloc(sizeof(jtp_hotspot));
        (inven_hotspots[n_hotspots-1])->mcursor = jtp_mcursor[JTP_CURSOR_NORMAL];
        (inven_hotspots[n_hotspots-1])->tooltip = jtp_make_tooltip("Next page");
        (inven_hotspots[n_hotspots-1])->x1 = x + 448;
        (inven_hotspots[n_hotspots-1])->x2 = x + 570;
        (inven_hotspots[n_hotspots-1])->y1 = y + 410;
        (inven_hotspots[n_hotspots-1])->y2 = y + 443;
        (inven_hotspots[n_hotspots-1])->accelerator = JTP_KEY_MENU_SCROLLPAGEDOWN;
      }
      jtp_refresh(&jtp_screen);
      inventory_page_changed = 0;
    }

    selected_hotspot = jtp_get_mouse_inventory_input(jtp_mcursor[JTP_CURSOR_NORMAL], inven_hotspots, n_hotspots, JTP_MBUTTON_LEFT);
    pressedkey = jtp_getch();
    if (pressedkey != 0)
    {
      if (pressedkey == JTP_MOUSEWHEEL_UP)
        pressedkey = JTP_KEY_MENU_SCROLLPAGEUP;
      else if (pressedkey == JTP_MOUSEWHEEL_DOWN)
        pressedkey = JTP_KEY_MENU_SCROLLPAGEDOWN;
      if (pressedkey == 27) /* ESC */
        quit_viewing_inventory = 1;
      else if ((pressedkey == JTP_KEY_MENU_SCROLLPAGEDOWN) || 
               (pressedkey == JTP_KEY_MENU_SCROLLPAGEUP))
      {
        /* If the 'flip page' hotspot exists, select it */
        for (i = 0; i < n_hotspots; i++)        
          if ((inven_hotspots[i])->accelerator == pressedkey)
          {
            selected_hotspot = i;
            jtp_mouseb = JTP_MBUTTON_LEFT;
          }
      }
    }
    if ((jtp_mouseb == JTP_MBUTTON_RIGHT) && (selected_hotspot >= 0))
    {
      /* If the hotspot accelerator is nonnegative, then this is an inventory item */
      if ((inven_hotspots[selected_hotspot])->accelerator >= 0)
      {
        /* Select a shortcut action for this inventory item */
        dropdown_actions = NULL;
        n_actions = 0;  
        /* Add personal options: */
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_APPLY_ITEM, "Apply");
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_DRINK_ITEM, "Drink");
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_EAT_ITEM, "Eat");
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_READ_ITEM, "Read");
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_ZAP_ITEM, "Zap");
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_WEAR_ITEM, "Wear");
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_PUT_ON_ITEM, "Put on");
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_WIELD_ITEM, "Wield");
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_REMOVE_ITEM, "Remove");
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_DROP_ITEM, "Drop");
        selected_action = jtp_dropdown(jtp_mousex, jtp_mousey, n_actions, dropdown_actions);
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
        if (selected_action > 0)
        {
          jtp_is_backpack_shortcut_active = 1;
          jtp_backpack_shortcut_action = jtp_construct_shortcut_action((inven_hotspots[selected_hotspot])->accelerator, 0, selected_action);
          quit_viewing_inventory = 1;
        }
        /* Clean up the dropdown menu */
        for (i = 0; i < n_actions; i++)
        {
          free(dropdown_actions[i]->str);
          free(dropdown_actions[i]);
        }
        free(dropdown_actions);
      }
      else
      {
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      }
    }
    else if ((jtp_mouseb == JTP_MBUTTON_LEFT) && (selected_hotspot >= 0))
    {
      if ((inven_hotspots[selected_hotspot])->accelerator == JTP_KEY_MENU_SCROLLPAGEUP)
      {
        /* Wait for mouse button release, then redisplay the inventory */
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
        firstitem_index = firstitem_index - 25;
        inventory_page_changed = 1;
      }
      else if ((inven_hotspots[selected_hotspot])->accelerator == JTP_KEY_MENU_SCROLLPAGEDOWN)
      {
        /* Wait for mouse button release, then redisplay the inventory */
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
        firstitem_index = firstitem_index + 25;
        inventory_page_changed = 1;
      }
      else
      {
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      }
    }
    else if ((jtp_mouseb == JTP_MBUTTON_LEFT) && (selected_hotspot < 0))
    {
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      quit_viewing_inventory = 1;
    }
    else
    {
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
    }
  }

  /* Restore background and clean up */
  jtp_put_img(x, y, backpack_bg);
  jtp_refresh(&jtp_screen);
  free(backpack_bg);

  if (n_hotspots > 0)
  {
    for (i = 0; i < n_hotspots; i++)
    {
      free((inven_hotspots[i])->tooltip);
      free(inven_hotspots[i]);
    }
    free(inven_hotspots);
  }
}

static int jtp_text_to_spell_symbol(const char *spelltext)
{
  int spellglyph = 0;
  int i;

  if (!spelltext) return(0);

  for (i = 6; (i < 26) & (spelltext[i] != '\0'); i++)
    spellglyph += (unsigned char)spelltext[i];
  spellglyph = spellglyph % 10;
  return(spellglyph);
}

static void jtp_view_spellbook(jtp_window *menuwindow)
{
  int x, y;
  int spells_x, spells_y;
  int total_selectable_items;
  int selectable_items;
  int i;
  int quit_viewing_spellbook;
  int spellbook_page_changed;
  unsigned char * spellbook_bg;

  jtp_menu * menu;
  int firstitem_index;
  jtp_menuitem * tempmenuitem;
  int item_x, item_y, item_index;
  int item_tile;

  jtp_hotspot ** spells_hotspots;
  int n_hotspots;
  int selected_hotspot;
  int pressedkey;

  jtp_dropdown_action ** dropdown_actions;
  int n_actions;
  int selected_action;

  if (!menuwindow) return;

  /* Find upper left corner of backpack */
  x = (jtp_screen.width - 640)/2;
  y = (jtp_screen.height - 480)/2;

  spellbook_bg = jtp_get_img(x, y, x + 640-1, y + 480-1);

  /* Draw spellbook */
  jtp_put_stencil(x, y, jtp_spellbook_top);
  jtp_put_stencil(x, y + 480 - jtp_spellbook_bottom[1], jtp_spellbook_bottom);
  jtp_put_stencil(x, y, jtp_spellbook_left);
  jtp_put_stencil(x + 640 - jtp_spellbook_right[3], y, jtp_spellbook_right);

  /* Find upper left corner of spells on spellbook */
  spells_x = x + 73;
  spells_y = y + 60;

  menu = menuwindow->menu;
  if ((!menu) || (!menu->items)) return;

  /* Find out total number of selectable items in spellbook */
  total_selectable_items = 0;
  jtp_list_reset(menu->items);
  tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
  while (tempmenuitem)
  {
    if (tempmenuitem->count != JTP_NOT_SELECTABLE)     
      total_selectable_items++;
    jtp_list_advance(menu->items);
    tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
  }

  quit_viewing_spellbook = 0;
  spellbook_page_changed = 1;
  firstitem_index = 0;
  spells_hotspots = NULL;
  n_hotspots = 0;

  /* Wait for mouse button release, then display the spellbook */
  jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);

  while (!quit_viewing_spellbook)
  {
    if (spellbook_page_changed)
    {
      /* Clean up previous hotspots */
      if (n_hotspots > 0)
      {
        for (i = 0; i < n_hotspots; i++)
        {
          free((spells_hotspots[i])->tooltip);
          free(spells_hotspots[i]);
        }
        free(spells_hotspots);
        spells_hotspots = NULL;
        n_hotspots = 0;
      }

      /* Draw spells on backpack, and create hotspots */
      jtp_put_img(x + jtp_spellbook_left[3], y + jtp_spellbook_top[1], jtp_spellbook_center);

      /* Find the first selectable item to be displayed */
      item_index = -1;
      jtp_list_reset(menu->items);
      tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
      while ((tempmenuitem) && (item_index < firstitem_index))
      {
        if (tempmenuitem->count != JTP_NOT_SELECTABLE)
          item_index++;
        if (item_index < firstitem_index)
        {
          jtp_list_advance(menu->items);
          tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
        }
      }
      
      item_x = spells_x;
      item_y = spells_y;
      selectable_items = 0; /* None shown so far */
      while ((tempmenuitem) && (selectable_items < 12))
      {
        if (tempmenuitem->count != JTP_NOT_SELECTABLE)     
        {
          item_tile = jtp_text_to_spell_symbol(tempmenuitem->text);
          jtp_put_stencil(item_x, item_y, jtp_spell_symbols[item_tile]);

          n_hotspots++;
          spells_hotspots = (jtp_hotspot **)realloc(spells_hotspots, n_hotspots*sizeof(jtp_hotspot *));
          spells_hotspots[n_hotspots-1] = (jtp_hotspot *)malloc(sizeof(jtp_hotspot));
          (spells_hotspots[n_hotspots-1])->mcursor = jtp_mcursor[JTP_CURSOR_NORMAL];
          (spells_hotspots[n_hotspots-1])->tooltip = jtp_make_tooltip(tempmenuitem->text);
          (spells_hotspots[n_hotspots-1])->x1 = item_x;
          (spells_hotspots[n_hotspots-1])->x2 = item_x + 97;
          (spells_hotspots[n_hotspots-1])->y1 = item_y;
          (spells_hotspots[n_hotspots-1])->y2 = item_y + 97;
          (spells_hotspots[n_hotspots-1])->accelerator = tempmenuitem->accelerator;

          selectable_items++;
          item_x = spells_x + (selectable_items%4)*100;
          if ((selectable_items%4) > 1) item_x += 100;
          item_y = spells_y + (selectable_items/4)*110;
        }
        jtp_list_advance(menu->items);
        tempmenuitem = (jtp_menuitem *)jtp_list_current(menu->items);
      }
      /* Add the 'flip page'-arrow hotspots */
      if (firstitem_index > 0) /* Add 'previous page' arrow */
      {
        n_hotspots++;
        spells_hotspots = (jtp_hotspot **)realloc(spells_hotspots, n_hotspots*sizeof(jtp_hotspot *));
        spells_hotspots[n_hotspots-1] = (jtp_hotspot *)malloc(sizeof(jtp_hotspot));
        (spells_hotspots[n_hotspots-1])->mcursor = jtp_mcursor[JTP_CURSOR_NORMAL];
        (spells_hotspots[n_hotspots-1])->tooltip = jtp_make_tooltip("Previous page");
        (spells_hotspots[n_hotspots-1])->x1 = x + 41;
        (spells_hotspots[n_hotspots-1])->x2 = x + 91;
        (spells_hotspots[n_hotspots-1])->y1 = y + 397;
        (spells_hotspots[n_hotspots-1])->y2 = y + 424;
        (spells_hotspots[n_hotspots-1])->accelerator = JTP_KEY_MENU_SCROLLPAGEUP;
      }
      if (total_selectable_items - firstitem_index > 12) /* Add 'next page' arrow */
      {
        n_hotspots++;
        spells_hotspots = (jtp_hotspot **)realloc(spells_hotspots, n_hotspots*sizeof(jtp_hotspot *));
        spells_hotspots[n_hotspots-1] = (jtp_hotspot *)malloc(sizeof(jtp_hotspot));
        (spells_hotspots[n_hotspots-1])->mcursor = jtp_mcursor[JTP_CURSOR_NORMAL];
        (spells_hotspots[n_hotspots-1])->tooltip = jtp_make_tooltip("Next page");
        (spells_hotspots[n_hotspots-1])->x1 = x + 549;
        (spells_hotspots[n_hotspots-1])->x2 = x + 599;
        (spells_hotspots[n_hotspots-1])->y1 = y + 397;
        (spells_hotspots[n_hotspots-1])->y2 = y + 424;
        (spells_hotspots[n_hotspots-1])->accelerator = JTP_KEY_MENU_SCROLLPAGEDOWN;
      }
      jtp_refresh(&jtp_screen);
      spellbook_page_changed = 0;
    }

    selected_hotspot = jtp_get_mouse_inventory_input(jtp_mcursor[JTP_CURSOR_NORMAL], spells_hotspots, n_hotspots, JTP_MBUTTON_LEFT);
    pressedkey = jtp_getch();
    if (pressedkey != 0)
    {
      if (pressedkey == JTP_MOUSEWHEEL_UP)
        pressedkey = JTP_KEY_MENU_SCROLLPAGEUP;
      else if (pressedkey == JTP_MOUSEWHEEL_DOWN)
        pressedkey = JTP_KEY_MENU_SCROLLPAGEDOWN;
      if (pressedkey == 27) /* ESC */
        quit_viewing_spellbook = 1;
      else if ((pressedkey == JTP_KEY_MENU_SCROLLPAGEDOWN) || 
               (pressedkey == JTP_KEY_MENU_SCROLLPAGEUP))
      {
        /* If the 'flip page' hotspot exists, select it */
        for (i = 0; i < n_hotspots; i++)        
          if ((spells_hotspots[i])->accelerator == pressedkey)
          {
            selected_hotspot = i;
            jtp_mouseb = JTP_MBUTTON_LEFT;
          }
      }
    }
    if ((jtp_mouseb == JTP_MBUTTON_RIGHT) && (selected_hotspot >= 0))
    {
      /* If the hotspot accelerator is nonnegative, then this is an inventory item */
      if ((spells_hotspots[selected_hotspot])->accelerator >= 0)
      {
        /* Select a shortcut action for this inventory item */
        dropdown_actions = NULL;
        n_actions = 0;  
        /* Add personal options: */
        jtp_add_dropdown_action(&n_actions, &dropdown_actions, JTP_ACTION_CAST_SPELL, "Cast Spell");
        selected_action = jtp_dropdown(jtp_mousex, jtp_mousey, n_actions, dropdown_actions);
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
        if (selected_action > 0)
        {
          jtp_is_backpack_shortcut_active = 1;
          jtp_backpack_shortcut_action = jtp_construct_shortcut_action((spells_hotspots[selected_hotspot])->accelerator, 0, selected_action);
          quit_viewing_spellbook = 1;
        }
        /* Clean up the dropdown menu */
        for (i = 0; i < n_actions; i++)
        {
          free(dropdown_actions[i]->str);
          free(dropdown_actions[i]);
        }
        free(dropdown_actions);
      }
      else
      {
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      }
    }
    else if ((jtp_mouseb == JTP_MBUTTON_LEFT) && (selected_hotspot >= 0))
    {
      if ((spells_hotspots[selected_hotspot])->accelerator == JTP_KEY_MENU_SCROLLPAGEUP)
      {
        /* Wait for mouse button release, then redisplay the spells */
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
        firstitem_index = firstitem_index - 12;
        spellbook_page_changed = 1;
      }
      else if ((spells_hotspots[selected_hotspot])->accelerator == JTP_KEY_MENU_SCROLLPAGEDOWN)
      {
        /* Wait for mouse button release, then redisplay the spells */
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
        firstitem_index = firstitem_index + 12;
        spellbook_page_changed = 1;
      }
      else
      {
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      }
    }
    else if ((jtp_mouseb == JTP_MBUTTON_LEFT) && (selected_hotspot < 0))
    {
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      quit_viewing_spellbook = 1;
    }
    else
    {
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
    }
  }

  /* Restore background and clean up */
  jtp_put_img(x, y, spellbook_bg);
  jtp_refresh(&jtp_screen);
  free(spellbook_bg);

  if (n_hotspots > 0)
  {
    for (i = 0; i < n_hotspots; i++)
    {
      free((spells_hotspots[i])->tooltip);
      free(spells_hotspots[i]);
    }
    free(spells_hotspots);
  }

  /* Not viewing spellbook anymore. The next menu will be normal-style. */
  jtp_is_spellbook_being_viewed = 0;
}


static void jtp_recenter_from_minimap(void)
{
  int i, j;
  i = jtp_mousey - (jtp_statusbar_y + 51);
  j = jtp_mousex - (jtp_statusbar_x + 98);
  jtp_map_x = jtp_map_x + (j+2*i)/4;
  jtp_map_y = jtp_map_y + (2*i-j)/4;
  if (jtp_map_x < 1) jtp_map_x = 1;
  if (jtp_map_x >= JTP_MAP_WIDTH) jtp_map_x = JTP_MAP_WIDTH-1;
  if (jtp_map_y < 0) jtp_map_y = 0;
  if (jtp_map_y >= JTP_MAP_HEIGHT) jtp_map_y = JTP_MAP_HEIGHT-1;
  jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
}

static void jtp_autopilot_from_minimap(void)
{
  int i, j, tx, ty;
  i = jtp_mousey - (jtp_statusbar_y + 51);
  j = jtp_mousex - (jtp_statusbar_x + 98);
  tx = jtp_map_x + (j+2*i)/4;
  ty = jtp_map_y + (2*i-j)/4;
  if (tx < 1) tx = 1;
  if (tx >= JTP_MAP_WIDTH) tx = JTP_MAP_WIDTH-1;
  if (ty < 0) ty = 0;
  if (ty >= JTP_MAP_HEIGHT) ty = JTP_MAP_HEIGHT-1;
  jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
  u.tx = tx;
  u.ty = ty;  
}


char jtp_process_mouseclick(void)
{
  int hotspot;
  char selected_command;
  double cur_time;
  
  if (jtp_mouseb == JTP_MBUTTON_NONE) 
    return(0);

  hotspot = jtp_mouse_hotspot();
  cur_time = jtp_clocktick();
  switch (hotspot)
  {
    /* Scroll commands */
    case JTP_HOTSPOT_SCROLL_UP: 
       if (cur_time-jtp_last_scroll_time > jtp_min_scroll_delay)
       {
         jtp_last_scroll_time = cur_time;
         jtp_map_x--; jtp_map_y--; 
       }
       break;
    case JTP_HOTSPOT_SCROLL_DOWN: 
       if (cur_time-jtp_last_scroll_time > jtp_min_scroll_delay)
       {
         jtp_last_scroll_time = cur_time;
         jtp_map_x++; jtp_map_y++; 
       }
       break;
    case JTP_HOTSPOT_SCROLL_LEFT: 
       if (cur_time-jtp_last_scroll_time > jtp_min_scroll_delay)
       {
         jtp_last_scroll_time = cur_time;
         jtp_map_x--; jtp_map_y++; 
       }
       break;
    case JTP_HOTSPOT_SCROLL_RIGHT: 
       if (cur_time-jtp_last_scroll_time > jtp_min_scroll_delay)
       {
         jtp_last_scroll_time = cur_time;
         jtp_map_x++; jtp_map_y--; 
       }
       break;
    /* Autopilot or recenter from mini-map */
    case JTP_HOTSPOT_MINI_MAP:
      if (jtp_mouseb == JTP_MBUTTON_LEFT)
      {
        jtp_autopilot_from_minimap();
        return(CMD_TRAVEL);
      }
      else
      {
        jtp_recenter_from_minimap();
        return(0);
      }
      break;
    /* Autopilot */
    case JTP_HOTSPOT_MAP:
      if (jtp_mouseb == JTP_MBUTTON_LEFT)
      {
        if (cur_time-jtp_last_scroll_time > jtp_min_command_delay)
        {      
          /* Use default command for target square */
          jtp_last_scroll_time = cur_time;
          selected_command = jtp_get_default_command(jtp_map_tgtx, jtp_map_tgty);
          if (jtp_one_command_per_click)
            while(jtp_mouseb != JTP_MBUTTON_NONE) 
              jtp_readmouse();
          return(selected_command);
        }
      }
      else
      {
        /* Select command from context-sensitive menu */
        return(jtp_get_dropdown_command(jtp_mousex, jtp_mousey, jtp_map_tgtx, jtp_map_tgty));
      }
      break;
    /* Command shortcuts */  
    case JTP_HOTSPOT_BUTTON_MAP:
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      jtp_view_map();
      break;
    case JTP_HOTSPOT_BUTTON_MESSAGES:
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      jtp_view_messages();
      break;
    case JTP_HOTSPOT_BUTTON_HELP:
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      return(jtp_translate_command(JTP_NHCMD_HELP_MENU));
      break;
    case JTP_HOTSPOT_BUTTON_SPELLBOOK:
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      jtp_is_spellbook_being_viewed = 1;
      return(jtp_translate_command(JTP_NHCMD_LIST_SPELLS));
      break;
    case JTP_HOTSPOT_BUTTON_INVENTORY:
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      return(jtp_translate_command(JTP_NHCMD_LIST_INVENTORY));
      break;
    case JTP_HOTSPOT_BUTTON_OPTIONS:
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      return(jtp_translate_command(JTP_NHCMD_SET_OPTIONS));
      break;
    case JTP_HOTSPOT_BUTTON_LOOK:
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      jtp_is_shortcut_active = 1;
      jtp_shortcut_query_response = 'y';
      return(jtp_translate_command(JTP_NHCMD_EXPLAIN_SYMBOL)); 
      break;
    case JTP_HOTSPOT_BUTTON_EXTENDED:
      jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);
      return(jtp_translate_command(JTP_NHCMD_EXTENDED_COMMAND)); 
      break;
    default: break;    
  }
  
  if (jtp_map_x >= JTP_MAP_WIDTH) jtp_map_x = JTP_MAP_WIDTH-1;
  if (jtp_map_x < 0) jtp_map_x = 0;
  if (jtp_map_y >= JTP_MAP_HEIGHT) jtp_map_y = JTP_MAP_HEIGHT-1;
  if (jtp_map_y < 0) jtp_map_y = 0;
  return(0);
}


char
jtp_whatis_mouseclick(tx, ty)
int *tx, *ty;
{
  int hotspot;
  
  *tx = -1; *ty = -1;
  if (jtp_mouseb == JTP_MBUTTON_NONE) 
    return(0);
  
  hotspot = jtp_mouse_hotspot();
  switch (hotspot)
  {
    /* Scroll commands */
    case JTP_HOTSPOT_SCROLL_UP: jtp_map_x--; jtp_map_y--; break;
    case JTP_HOTSPOT_SCROLL_DOWN: jtp_map_x++; jtp_map_y++; break;
    case JTP_HOTSPOT_SCROLL_LEFT: jtp_map_x--; jtp_map_y++; break;
    case JTP_HOTSPOT_SCROLL_RIGHT: jtp_map_x++; jtp_map_y--; break;
    /* Autopilot */
    case JTP_HOTSPOT_MAP:
      if (isok(jtp_map_tgtx, jtp_map_tgty))
      {
        *tx = jtp_map_tgtx;
        *ty = jtp_map_tgty;
        return(0);
      }
      break;
    /* Command shortcuts */  
    case JTP_HOTSPOT_BUTTON_MAP:
      jtp_view_map();
      break;      
    case JTP_HOTSPOT_BUTTON_MESSAGES:
      jtp_view_messages();
      break;
    case JTP_HOTSPOT_BUTTON_HELP:
      return(jtp_translate_command(JTP_NHCMD_EXPLAIN_SYMBOL));
      break;
    case JTP_HOTSPOT_BUTTON_SPELLBOOK:
    case JTP_HOTSPOT_BUTTON_INVENTORY:
    case JTP_HOTSPOT_BUTTON_LOOK:
    case JTP_HOTSPOT_BUTTON_EXTENDED:
    case JTP_HOTSPOT_BUTTON_OPTIONS:    
      return(' ');   /* Stop whatis first */
      break;
    default: break;    
  }
  
  if (jtp_map_x > 80) jtp_map_x = 80;
  if (jtp_map_x < 0) jtp_map_x = 0;
  if (jtp_map_y > 50) jtp_map_y = 50;
  if (jtp_map_y < 0) jtp_map_y = 0;
  return(0);
}


int jtp_get_input
(
  int forced_x, int forced_y, /* Forced location of prompt window (-1 = not forced) */
  const char * ques,          /* Message to show player */
  char * input                /* Answer string */
)
{
  int i;
  int totalwidth, totalheight;
  int query_x, query_y;
  unsigned char * query_background;
  unsigned char * input_background;
  int key_result;

  /* Calculate width, height and position of query window */
  totalwidth = 500;
  i = jtp_text_length((char *)ques, JTP_FONT_HEADLINE) + 
      jtp_defwin.border_left[3] + 
      jtp_defwin.border_right[3];
  if (i > totalwidth) totalwidth = i;
  
  totalheight = jtp_text_height(ques, JTP_FONT_HEADLINE);
  totalheight += 3*jtp_fonts[JTP_FONT_INPUT].lineheight;

  totalwidth += jtp_defwin.border_left[3];
  totalwidth += jtp_defwin.border_right[3];
  totalheight += jtp_defwin.border_top[1];
  totalheight += jtp_defwin.border_bottom[1];

  if (forced_x >= 0) query_x = forced_x;
  else query_x = (jtp_screen.width - totalwidth) / 2;

  if (forced_y >= 0) query_y = forced_y;
  else query_y = (jtp_screen.height - totalheight) / 2;

  /* Store background graphics */
  query_background = jtp_draw_window(query_x, query_y, totalwidth, totalheight);
  input_background = jtp_get_img(query_x + jtp_defwin.border_left[3],
                                 query_y + jtp_defwin.border_top[1] + 
                                   jtp_text_height(ques, JTP_FONT_HEADLINE) + 
                                   jtp_fonts[JTP_FONT_INPUT].lineheight,
                                 query_x + totalwidth - jtp_defwin.border_right[3],
                                 query_y + jtp_defwin.border_top[1] + 
                                   jtp_text_height(ques, JTP_FONT_HEADLINE) + 
                                   2*jtp_fonts[JTP_FONT_INPUT].lineheight);
  /* Draw query message */
  jtp_put_text(jtp_defwin.border_left[3] + query_x + 1,
               jtp_defwin.border_top[1] + query_y + 
                 jtp_fonts[JTP_FONT_HEADLINE].baseline + 1,
               JTP_FONT_HEADLINE,
               JTP_COLOR_BACKGROUND,
               ques,
               jtp_screen.vpage);
  jtp_put_text(jtp_defwin.border_left[3] + query_x,
               jtp_defwin.border_top[1] + query_y + 
                 jtp_fonts[JTP_FONT_HEADLINE].baseline,
               JTP_FONT_HEADLINE,
               JTP_COLOR_TEXT,
               ques,
               jtp_screen.vpage);

  /* Display window */
  jtp_refresh(&jtp_screen);
  /* In case the palette is faded out for some reason, restore it */
  jtp_updatepal(0, 255);
    
  /* Wait for input */
  i = 0;
  input[0] = '\0';
  
  do
  {
    /* Redraw text */  
    jtp_put_img(query_x + jtp_defwin.border_left[3], 
                query_y + jtp_defwin.border_top[1] + 
                  jtp_text_height(ques, JTP_FONT_HEADLINE) +
                  jtp_fonts[JTP_FONT_INPUT].lineheight,
                input_background);

    
    
    jtp_put_text(jtp_defwin.border_left[3]+query_x+1, 
                 query_y + jtp_defwin.border_top[1] + 
                   jtp_text_height(ques, JTP_FONT_HEADLINE) + 
                   jtp_fonts[JTP_FONT_INPUT].lineheight +
                   jtp_fonts[JTP_FONT_INPUT].baseline + 1,
                 JTP_FONT_INPUT, JTP_COLOR_BACKGROUND,
                 input,
                 jtp_screen.vpage);
    jtp_put_text(jtp_defwin.border_left[3]+query_x+1, 
                 query_y + jtp_defwin.border_top[1] + 
                   jtp_text_height(ques, JTP_FONT_HEADLINE) + 
                   jtp_fonts[JTP_FONT_INPUT].lineheight +
                   jtp_fonts[JTP_FONT_INPUT].baseline,
                 JTP_FONT_INPUT, JTP_COLOR_TEXT,
                 input,
                 jtp_screen.vpage);
    /* Draw prompt */
    jtp_rect(query_x + jtp_defwin.border_left[3] + jtp_text_length(input, JTP_FONT_INPUT) + 2,
             query_y + jtp_defwin.border_top[1] + 
               jtp_text_height(ques, JTP_FONT_HEADLINE) +
               jtp_fonts[JTP_FONT_INPUT].lineheight,
             query_x + jtp_defwin.border_left[3] + jtp_text_length(input, JTP_FONT_INPUT) + 2,
             query_y + jtp_defwin.border_top[1] +
               jtp_text_height(ques, JTP_FONT_HEADLINE) +
               jtp_fonts[JTP_FONT_INPUT].lineheight +
               jtp_fonts[JTP_FONT_INPUT].baseline,
             15);
    /* Display window */
    jtp_refresh(&jtp_screen);
  
    key_result = jtp_getch();

    /* if ((key_result < 'a') || (key_result > 'z')) key_result = '?'; */
    if (key_result != 0 && key_result < 0x100 && (jtp_fonts[JTP_FONT_INPUT].fontpics[key_result].kuva != NULL) && (i < 80))
    {
      input[i] = key_result;
      input[i+1] = '\0';
      i++;
    }

    /* Backspace key */
    if ((key_result == 8)  || (jtp_text_length(input, JTP_FONT_INPUT) > 490))
      if (i>0)
      {
        input[i-1]='\0';
        i--;
      }

  } while (key_result != 0x0d && key_result != 0x1b);


  /* Restore background */
  jtp_put_img(query_x, query_y, query_background);
  jtp_refresh(&jtp_screen);

  /* Clean up */
  free(query_background);
  free(input_background);
  return key_result == 0x0d;
}

void jtp_askname(void)
{
	int done;
	
	done = jtp_get_input(-1, jtp_screen.height - 170,
				  "What is your name?", plname);
	if (!done)
	{
		/* Player pressed ESC during the name query, so quit the game */
		bail((char *) 0);
	}
	
	/* do not fade out if user didn't enter anything, we will come back here */
	
	if (plname[0])
	{
		jtp_fade_out(0.2);
	}
}

static void jtp_read_options(int *screen_width, int *screen_height)
{
  FILE * f;
  char tempbuffer[1024];
  char *tok;
  char *tok2;
  int soundtype;
  char *filename;

  /* printf("DEBUG[jtp_win.c/30]: Reading options from [%s]\n", optfile); */

  *screen_width = 800;
  *screen_height = 600;

  /* Read interface options */
  filename = jtp_make_filename(JTP_CONFIG_DIRECTORY, NULL, JTP_FILENAME_OPTIONS);
  f = fopen(filename, "rb");
  free(filename);
  if (f == NULL)
  {
    /* Use defaults */
  } else
  {
    while (fgets(tempbuffer, sizeof(tempbuffer), f))
    {
      tok = NULL;
      if (tempbuffer[0] != '%')
        tok = strstr(tempbuffer, "=");

      if (tok)
      {
        if (!strncmp(tempbuffer, "screen_xsize", tok - tempbuffer))
          *screen_width = atoi(tok + 1);
        else if (!strncmp(tempbuffer, "screen_ysize", tok - tempbuffer))
          *screen_height = atoi(tok + 1);
        else if (!strncmp(tempbuffer, "command_delay", tok - tempbuffer))
          jtp_min_command_delay = atof(tok + 1);
        else if (!strncmp(tempbuffer, "scrolling_delay", tok - tempbuffer))
          jtp_min_scroll_delay = atof(tok + 1);
        else if (!strncmp(tempbuffer, "wall_style", tok - tempbuffer))
        {
          if (!strncmp(tok + 1, "full", 4))
            jtp_wall_display_style = JTP_WALL_DISPLAY_STYLE_FULL;
          else if (!strncmp(tok + 1, "half_height", 11))
            jtp_wall_display_style = JTP_WALL_DISPLAY_STYLE_HALF_HEIGHT;
          else if (!strncmp(tok + 1, "transparent", 11))
            jtp_wall_display_style = JTP_WALL_DISPLAY_STYLE_TRANSPARENT;
        }
        else if (!strncmp(tempbuffer, "recenter_after_movement", tok - tempbuffer))
          jtp_recenter_after_movement = atoi(tok + 1);
        else if (!strncmp(tempbuffer, "play_music", tok - tempbuffer))
          jtp_play_music = atoi(tok + 1);
        else if (!strncmp(tempbuffer, "play_effects", tok - tempbuffer))
          jtp_play_effects = atoi(tok + 1);
        else if (!strncmp(tempbuffer, "one_command_per_click", tok - tempbuffer))
          jtp_one_command_per_click = atoi(tok + 1);
        else if (!strncmp(tempbuffer, "fullscreen", tok - tempbuffer))
          iflags.wc2_fullscreen = atoi(tok + 1);
        else if (!strncmp(tempbuffer, "gamma_correction", tok - tempbuffer))
          jtp_gamma_correction = atof(tok + 1);
        else if (!strncmp(tempbuffer, "midi_player", tok - tempbuffer) ||
          !strncmp(tempbuffer, "linux_midi_player", tok - tempbuffer))
        {
          jtp_external_midi_player_command = (char *)malloc(strlen(tok + 1) + 1);
          strcpy(jtp_external_midi_player_command, tok + 1);
          /* Remove end-of-line from the string */
          trimright(jtp_external_midi_player_command);
        }
        else if (!strncmp(tempbuffer, "mp3_player", tok - tempbuffer) ||
          !strncmp(tempbuffer, "linux_mp3_player", tok - tempbuffer))
        {
          jtp_external_mp3_player_command = (char *)malloc(strlen(tok + 1) + 1);
          strcpy(jtp_external_mp3_player_command, tok + 1);
          /* Remove end-of-line from the string */
          trimright(jtp_external_mp3_player_command);
        }
      }
    }
    fclose(f);
  }
  
  /* Read key mapping options */
  /* Create the key binding table */
  jtp_keymaps = (jtp_command *)calloc(sizeof(jtp_command), JTP_MAX_NETHACK_COMMANDS);
  jtp_set_nethack_keys();
  /* jtp_set_default_keymaps(); */ /* Use whatever NetHack has */
  filename = jtp_make_filename(JTP_CONFIG_DIRECTORY, NULL, JTP_FILENAME_KEYS_CONFIG);
  jtp_read_key_configuration(filename);
  free(filename);

  /* Read event sounds options */
  jtp_event_sounds = NULL;
  jtp_n_event_sounds = 0;

  filename = jtp_make_filename(JTP_CONFIG_DIRECTORY, NULL, JTP_FILENAME_SOUNDS_CONFIG);
  f = fopen(filename, "rb");
  free(filename);
  if (f == NULL) return;
  while (fgets(tempbuffer, 1024, f))
  {
    if ((tempbuffer[0] == '%') || (tempbuffer[0] == '\0') ||
        (tempbuffer[0] == 10) || (tempbuffer[0] == 13))
    {
      /* Comment or empty line. Skip. */
    }
    else
    {
      /* Check for sound type */

      soundtype = -1;
      if ((tok = strstr(tempbuffer, "],SND,[")) != NULL) /* sound found */
        soundtype = JTP_EVENT_SOUND_TYPE_SND;      
      else if ((tok = strstr(tempbuffer, "],MUS,[")) != NULL) /* music found */      
        soundtype = JTP_EVENT_SOUND_TYPE_MUS;      
      else if ((tok = strstr(tempbuffer, "],RSNG,[")) != NULL) /* Random song file found */
        soundtype = JTP_EVENT_SOUND_TYPE_RANDOM_SONG;
      else if ((tok = strstr(tempbuffer, "],CDAU,[")) != NULL) /* CD audio track found */
        soundtype = JTP_EVENT_SOUND_TYPE_CD_AUDIO;      
      else if ((tok = strstr(tempbuffer, "],NONE,[")) != NULL) /* NONE placeholder found */
        soundtype = JTP_EVENT_SOUND_TYPE_NONE;      

      if (soundtype >= 0) /* Valid sound found */
      {
        jtp_n_event_sounds++;
        jtp_event_sounds = (jtp_event_sound **)realloc(jtp_event_sounds, jtp_n_event_sounds*sizeof(jtp_event_sound *));
        jtp_event_sounds[jtp_n_event_sounds-1] = (jtp_event_sound *)malloc(sizeof(jtp_event_sound));
        (jtp_event_sounds[jtp_n_event_sounds-1])->filename = (char *)malloc(JTP_MAX_FILENAME_LENGTH*sizeof(char));

        (jtp_event_sounds[jtp_n_event_sounds-1])->searchpattern = (char *)malloc(JTP_MAX_FILENAME_LENGTH*sizeof(char));
        memcpy((jtp_event_sounds[jtp_n_event_sounds-1])->searchpattern, tempbuffer+1, tok-tempbuffer-1);
        (jtp_event_sounds[jtp_n_event_sounds-1])->searchpattern[tok-tempbuffer-1] = '\0';

        /* Check for a background music event */
        if (!strcmp((jtp_event_sounds[jtp_n_event_sounds-1])->searchpattern, "nhfe_music_background"))
	{
          jtp_n_background_songs++;
          free((jtp_event_sounds[jtp_n_event_sounds-1])->searchpattern);
          (jtp_event_sounds[jtp_n_event_sounds-1])->searchpattern = (char *)malloc(strlen("nhfe_music_background")+4);
          sprintf((jtp_event_sounds[jtp_n_event_sounds-1])->searchpattern, "nhfe_music_background%03d", jtp_n_background_songs-1);
	}

        if (soundtype == JTP_EVENT_SOUND_TYPE_SND||soundtype == JTP_EVENT_SOUND_TYPE_MUS) tok = tok + 7;
        else tok = tok + 8;

        tok2 = strstr(tok, "]");
        memcpy((jtp_event_sounds[jtp_n_event_sounds-1])->filename, tok, tok2-tok);
        (jtp_event_sounds[jtp_n_event_sounds-1])->filename[tok2-tok] = '\0';

        (jtp_event_sounds[jtp_n_event_sounds-1])->soundtype = soundtype;


        /* If this isn't a CD track, add path to sounds subdirectory before filename */
        if (soundtype != JTP_EVENT_SOUND_TYPE_CD_AUDIO)
        {
          char *tmp = jtp_event_sounds[jtp_n_event_sounds-1]->filename;
          jtp_event_sounds[jtp_n_event_sounds-1]->filename = jtp_make_filename(soundtype == JTP_EVENT_SOUND_TYPE_SND ? JTP_SOUND_DIRECTORY : JTP_MUSIC_DIRECTORY, NULL, tmp);
          free(tmp);
        }

        jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "Mapped [%s] to [%s]\n", (jtp_event_sounds[jtp_n_event_sounds-1])->searchpattern, (jtp_event_sounds[jtp_n_event_sounds-1])->filename);
      }
    }
  }
  fclose(f);
}


static void jtp_init_filenames(void)
{
  /* Get starting directory, and save it for reference */
#ifdef CHDIR
	char hackdir[1024];
	getcwd(hackdir, sizeof(hackdir));
	jtp_game_path = jtp_strdup(hackdir);
#else
	jtp_game_path = jtp_strdup(hackdir);
#endif
}


int jtp_init_graphics(void)
{
  int i;
  int screen_width, screen_height;
  int all_ok = TRUE;
  unsigned char *image;
  
  jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "Initializing filenames\n");
  jtp_init_filenames();

  jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "Reading Vulture's options\n");
  /* Read options file */
  jtp_read_options(&screen_width, &screen_height);
  /*
   * the size of the logo bitmap;
   * bad things happen if screen size is less than this; FIXME
   */
  if (screen_width < 800)
    screen_width = 800;
  if (screen_height < 600)
    screen_height = 600;

  jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "Initializing screen buffer\n");
  /* Initialize screen and calculate some often used coordinates */
  jtp_init_screen(screen_width, screen_height);
  jtp_statusbar_x = (jtp_screen.width-JTP_STATUSBAR_WIDTH)/2;
  jtp_statusbar_y = jtp_screen.height-JTP_STATUSBAR_HEIGHT;
  jtp_map_center_x = jtp_screen.width/2;
  jtp_map_center_y = (jtp_screen.height-JTP_STATUSBAR_HEIGHT)/2;

  jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "Initializing fonts\n");
  /* Load fonts */
  jtp_fonts = (jtp_font *)calloc(JTP_MAX_FONTS, sizeof(jtp_font));
  all_ok &= jtp_load_font(JTP_FILENAME_FONT_SMALL, JTP_FONT_SMALL);
  all_ok &= jtp_load_font(JTP_FILENAME_FONT_LARGE, JTP_FONT_LARGE);

  /* Load window style graphics */
  image = jtp_load_graphic(NULL, JTP_FILENAME_WINDOW_STYLE, FALSE);
  if (image == NULL)
  {
    all_ok = FALSE;
  } else
  {
    jtp_defwin.corner_tl = jtp_get_img_src(1, 1, 23, 23, image);
    jtp_defwin.border_top = jtp_get_img_src(27, 1, 57, 23, image);
    jtp_defwin.corner_tr = jtp_get_img_src(61, 1, 84, 23, image);
    jtp_defwin.border_left = jtp_get_img_src(1, 27, 23, 54, image);
    /* jtp_defwin.center = jtp_get_img_src(27, 27, 57, 54, image); */ /* This is the small graphic... */
    jtp_defwin.center = jtp_get_img_src(141, 1, 238, 168, image);  /* But let's use this big one. */
    jtp_defwin.border_right = jtp_get_img_src(61, 27, 84, 54, image);
    jtp_defwin.corner_bl = jtp_get_img_src(1, 58, 23, 82, image);
    jtp_defwin.border_bottom = jtp_get_img_src(27, 58, 57, 82, image);
    jtp_defwin.corner_br = jtp_get_img_src(61, 58, 84, 82, image);
    jtp_defwin.checkbox_off = jtp_get_img_src(1, 107, 17, 123, image);
    jtp_defwin.checkbox_on = jtp_get_img_src(21, 107, 37, 123, image);
    jtp_defwin.radiobutton_off = jtp_get_img_src(41, 107, 57, 123, image);
    jtp_defwin.radiobutton_on = jtp_get_img_src(61, 107, 77, 123, image);
    jtp_defwin.scrollbar = jtp_get_img_src(81, 107, 97, 123, image);
    jtp_defwin.scrollbutton_down = jtp_get_img_src(101, 107, 117, 123, image);
    jtp_defwin.scrollbutton_up = jtp_get_img_src(121, 107, 137, 123, image);
    jtp_defwin.scroll_indicator = jtp_get_img_src(1, 127, 17, 154, image);
    jtp_defwin.direction_arrows = jtp_get_img_src(242, 1, 576, 134, image);
    free(image);
  }
  
  /* Load status bar */
  image = jtp_load_graphic(NULL, JTP_FILENAME_STATUS_BAR, FALSE);
  if (image == NULL)
  {
    all_ok = FALSE;
  } else
  {
    jtp_statusbar = image;
  }
  
  /* Load map parchment */
  image = jtp_load_graphic(NULL, JTP_FILENAME_MAP_PARCHMENT, FALSE);
  if (image == NULL)
  {
    all_ok = FALSE;
  } else
  {
    jtp_map_parchment_center = jtp_get_img_src(21, 18, 606, 463, image);
    jtp_map_parchment_top = jtp_get_img_src(0, 0, 639, 17, image);
    jtp_map_parchment_bottom = jtp_get_img_src(0, 464, 639, 479, image);
    jtp_map_parchment_left = jtp_get_img_src(0, 0, 20, 479, image);
    jtp_map_parchment_right = jtp_get_img_src(601, 0, 639, 479, image);
    free(image);
  }

  /* Load backpack */
  image = jtp_load_graphic(NULL, JTP_FILENAME_BACKPACK, FALSE);
  if (image == NULL)
  {
    all_ok = FALSE;
  } else
  {
    jtp_backpack_center = jtp_get_img_src(23, 15, 620, 405, image);
    jtp_backpack_top = jtp_get_img_src(0, 0, 639, 14, image);
    jtp_backpack_bottom = jtp_get_img_src(0, 406, 639, 479, image);
    jtp_backpack_left = jtp_get_img_src(0, 0, 22, 479, image);
    jtp_backpack_right = jtp_get_img_src(621, 0, 639, 479, image);
    free(image);
  }

  /* Load spellbook */
  image = jtp_load_graphic(NULL, JTP_FILENAME_SPELLBOOK, FALSE);
  if (image == NULL)
  {
    all_ok = FALSE;
  } else
  {
    jtp_spellbook_center = jtp_get_img_src(2, 7, 628, 430, image);
    jtp_spellbook_top = jtp_get_img_src(0, 0, 639, 6, image);
    jtp_spellbook_bottom = jtp_get_img_src(0, 431, 639, 479, image);
    jtp_spellbook_left = jtp_get_img_src(0, 0, 1, 479, image);
    jtp_spellbook_right = jtp_get_img_src(629, 0, 639, 479, image);
    free(image);
  }

  /* Load spell symbols */
  image = jtp_load_graphic(NULL, JTP_FILENAME_SPELL_SYMBOLS, FALSE);
  if (image == NULL)
  {
    all_ok = FALSE;
  } else
  {
    for (i = 0; i < 10; i++)
      jtp_spell_symbols[i] = jtp_get_img_src(1 + 101 * (i % 6), 1 + 101 * (i / 6), 98 + 101 * (i % 6), 98 + 101 * (i / 6), image);
    free(image);
  }

  /* Load map symbols */
  image = jtp_load_graphic(NULL, JTP_FILENAME_MAP_SYMBOLS, FALSE);
  if (image == NULL)
  {
    all_ok = FALSE;
  } else
  {
    for (i = 0; i < JTP_MAX_MAP_SYMBOLS; i++)
      jtp_map_symbols[i] = jtp_get_img_src(1 + 10 * i, 1, 7 + 10 * i, 14, image);
    free(image);
  }

  /* Load mouse cursors */
  image = jtp_load_graphic(NULL, JTP_FILENAME_MOUSE_CURSORS, TRUE);
  if (image == NULL)
  {
    all_ok = FALSE;
  } else
  {
    jtp_mcursor[JTP_CURSOR_NORMAL] = jtp_get_mcursor(image, 1, 1, 17, 24);
    jtp_mcursor[JTP_CURSOR_SCROLLRIGHT] = jtp_get_mcursor(image, 21, 1, 40, 23);
    jtp_mcursor[JTP_CURSOR_SCROLLLEFT] = jtp_get_mcursor(image, 44, 1, 63, 23);
    jtp_mcursor[JTP_CURSOR_SCROLLUP] = jtp_get_mcursor(image, 67, 1, 89, 20);
    jtp_mcursor[JTP_CURSOR_SCROLLDOWN] = jtp_get_mcursor(image, 93, 1, 115, 20);
    jtp_mcursor[JTP_CURSOR_TARGET_GREEN] = jtp_get_mcursor(image, 119, 1, 169, 26);
    jtp_mcursor[JTP_CURSOR_TARGET_RED] = jtp_get_mcursor(image, 173, 1, 223, 26);
    jtp_mcursor[JTP_CURSOR_TARGET_INVALID] = jtp_get_mcursor(image, 227, 1, 273, 26);
    jtp_mcursor[JTP_CURSOR_TARGET_HELP] = jtp_get_mcursor(image, 1, 30, 51, 79);
    jtp_mcursor[JTP_CURSOR_HOURGLASS] = jtp_get_mcursor(image, 277, 1, 306, 33);
    jtp_mcursor[JTP_CURSOR_OPENDOOR] = jtp_get_mcursor(image, 310, 1, 342, 30);
    jtp_mcursor[JTP_CURSOR_STAIRS] = jtp_get_mcursor(image, 346, 1, 383, 35);
    jtp_mcursor[JTP_CURSOR_GOBLET] = jtp_get_mcursor(image, 312, 34, 336, 68);
    /* these also contain the regular game palette */
    memcpy(jtp_game_colors, jtp_colors, sizeof(jtp_colors));
    free(image);
  }

  /* Set message shading */
  for (i = 0; i < JTP_MAX_MESSAGE_COLORS; i++)
    jtp_message_colors[i] = 20 + i/2;
  jtp_message_colors[0] = JTP_COLOR_TEXT;
  jtp_message_colors[1] = 17;

  /* Set warning colors */
  jtp_warn_colors[JTP_WARN_NONE] = JTP_COLOR_TEXT;
  jtp_warn_colors[JTP_WARN_NORMAL] = 10;
  jtp_warn_colors[JTP_WARN_MORE] = 84;
  jtp_warn_colors[JTP_WARN_ALERT] = 215;
  jtp_warn_colors[JTP_WARN_CRITICAL] = 222;
  
  /* Initialize the isometric tiles */
#if 0
	/* can't be done now, because the object descriptions are not yet set up */
	jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "Initializing tile conversion.\n");
	jtp_init_glyph_tiles(); /* Initialize glyph-tile correspondence tables just before game starts */
#endif
  jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "Loading tile graphics.\n");
  all_ok &= jtp_init_tilegraphics();  /* Initialize tile bitmaps */
  jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "Tile graphics loaded.\n");
 
  /* jtp_template_conversion(); */
 
  
  jtp_write_log_message(JTP_LOG_DEBUG, __FILE__, __LINE__, "Vulture's window system ready.\n");

  jtp_clear_screen();  /* Clear the screen buffer */
  /* Enter graphics mode */
  jtp_enter_graphics_mode(&jtp_screen); 
  jtp_blankpal(0,255); /* Set palette to all black */
  jtp_set_draw_region(0, 0, jtp_screen.width, jtp_screen.height);

  /* 
   * Set regular game palette. If any function changes the palette
   * (fade-ins, etc.), it is expected to restore the palette before
   * it returns.
   */
  memcpy(jtp_colors, jtp_game_colors, sizeof(jtp_colors));
  jtp_clear_screen();
  jtp_refresh(&jtp_screen);
  jtp_updatepal(0, 255);
  jtp_game_palette_set = 1;

  return all_ok;
}

void jtp_get_menu_coordinates(jtp_window *menuwindow)
{
  int i, j;
  int totalwidth, totalheight;
  int menuitems_width, menuitems_height;
  int prompt_width, prompt_height;
  int buttons_width, buttons_height;
  int top_separator_height, bottom_separator_height;
  jtp_menuitem * tempmenuitem;
  jtp_button * tempbutton;

  if (!menuwindow) return;
    
  i = jtp_defwin.border_top[1];
  j = jtp_defwin.border_left[3];

  /* Calculate width and height of prompt */
  prompt_width = jtp_text_length(menuwindow->menu->prompt, JTP_FONT_HEADLINE);
  prompt_height = jtp_text_height(menuwindow->menu->prompt, JTP_FONT_HEADLINE);
  menuwindow->menu->prompt_x = j;
  menuwindow->menu->prompt_y = i;

  /* If there is a prompt, add a small separator between it and the window content. */
  if (menuwindow->menu->prompt)
    top_separator_height = jtp_fonts[JTP_FONT_HEADLINE].lineheight;
  else
    top_separator_height = 0;

  /* Calculate width and height of each menu item */
  menuitems_width = 0;
  menuitems_height = 0;
  menuwindow->menu->items_y = jtp_defwin.border_top[1] + prompt_height + top_separator_height;
  menuwindow->menu->need_scrollbar = 0;
  i = 0; /* Menuitem y-coordinates are offsets from menuwindow->menu->items_y */

  if (menuwindow->menu)
  {
    jtp_list_reset(menuwindow->menu->items);
    tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    while (tempmenuitem)
    {
      tempmenuitem->width = jtp_text_length(tempmenuitem->text, JTP_FONT_MENU);
      if (tempmenuitem->count != JTP_NOT_SELECTABLE)
        switch (menuwindow->menu->selectiontype)
        {
          case PICK_NONE: tempmenuitem->width += jtp_defwin.radiobutton_off[3] + 4; break;
          case PICK_ONE: tempmenuitem->width += jtp_defwin.radiobutton_off[3] + 4; break;
          case PICK_ANY: tempmenuitem->width += jtp_defwin.checkbox_off[3] + 4; break;
          default: break;
        }
      tempmenuitem->height = jtp_fonts[JTP_FONT_MENU].lineheight;
      /* If the content is not textual, add some extra space between the items */
      if (!menuwindow->menu->content_is_text) tempmenuitem->height += 10;
      
      tempmenuitem->x = j;
      tempmenuitem->y = i;
      if (menuitems_width < tempmenuitem->width) menuitems_width = tempmenuitem->width;
      
      i += tempmenuitem->height + 4;
      
      if (menuitems_height + tempmenuitem->height + 4 < JTP_MAX_MENUITEMS_HEIGHT)
        menuitems_height += tempmenuitem->height + 4;
      else
        menuwindow->menu->need_scrollbar = 1;
    
      jtp_list_advance(menuwindow->menu->items);
      tempmenuitem = jtp_list_current(menuwindow->menu->items);
    }
  }

  /* If the scrollbar is needed, add its width to total width of menuitems */
  if (menuwindow->menu->need_scrollbar)
    menuitems_width += jtp_defwin.scrollbar[3];

  /* Add a small separator between the menu items and the buttons */
  if (menuwindow->menu->content_is_text)
    bottom_separator_height = jtp_fonts[JTP_FONT_MENU].lineheight;
  else
    bottom_separator_height = 0;
    
  /* Calculate width and height of buttons */
  buttons_width = 0;
  buttons_height = 0;
  i = jtp_defwin.border_top[1] + prompt_height + top_separator_height + 
      menuitems_height + bottom_separator_height;
  j = 0; /* Buttons will be centered when the total window width is known */
  if (menuwindow->buttons)
  {
    jtp_list_reset(menuwindow->buttons);
    tempbutton = (jtp_button *)jtp_list_current(menuwindow->buttons);
    while (tempbutton)
    {
      tempbutton->width = jtp_text_length(tempbutton->text, JTP_FONT_BUTTON) + 11;
      tempbutton->height = jtp_text_height(tempbutton->text, JTP_FONT_BUTTON) + 10;
      tempbutton->x = j;
      tempbutton->y = i;
      if (buttons_height < tempbutton->height) buttons_height = tempbutton->height;
      buttons_width += tempbutton->width + 4;
      j += tempbutton->width + 4;
      
      jtp_list_advance(menuwindow->buttons);
      tempbutton = (jtp_button *)jtp_list_current(menuwindow->buttons);
    }
  }
  
  /* Calculate total width and height from components */
  menuwindow->menu->items_height = menuitems_height;
  totalheight = prompt_height + top_separator_height + menuitems_height + 
                bottom_separator_height + buttons_height;
  totalwidth = prompt_width;
  if (menuitems_width > totalwidth) totalwidth = menuitems_width;
  if (buttons_width > totalwidth) totalwidth = buttons_width;
  totalwidth += jtp_defwin.border_left[3] + jtp_defwin.border_right[3];
  totalheight += jtp_defwin.border_top[1] + jtp_defwin.border_bottom[1];
  
  menuwindow->width = totalwidth;
  menuwindow->height = totalheight;

  /* If the scrollbar is needed, calculate its position */
  if (menuwindow->menu->need_scrollbar)
  {
    menuwindow->menu->scrollup_y = menuwindow->menu->items_y;
    menuwindow->menu->scrolldown_y = menuwindow->menu->items_y + menuitems_height - jtp_defwin.scrollbutton_down[1];
    menuwindow->menu->scrollbar_x = totalwidth - jtp_defwin.border_right[3] - jtp_defwin.scrollbar[3];
  }

  /* Center the buttons in the available space */
  j = (totalwidth - jtp_defwin.border_left[3] - jtp_defwin.border_right[3] - buttons_width)/ 2
      + jtp_defwin.border_left[3];
  if (menuwindow->buttons)
  {
    jtp_list_reset(menuwindow->buttons);
    tempbutton = (jtp_button *)jtp_list_current(menuwindow->buttons);
    while (tempbutton)
    {
      tempbutton->x += j;
      jtp_list_advance(menuwindow->buttons);
      tempbutton = (jtp_button *)jtp_list_current(menuwindow->buttons);
    }
  }
  

  /* Calculate window position */
  menuwindow->x = (jtp_screen.width - totalwidth)/2;
  menuwindow->y = (jtp_screen.height - totalheight)/2;
}




int jtp_get_menu_selection(jtp_window *menuwindow)
{
  int selectedbutton;
  jtp_menuitem * tempmenuitem, * tempmenuitem2, * firstitem;
  jtp_menuitem * lastitem;
  jtp_button * tempbutton;
  unsigned char * menubackground;
  unsigned char * tempimage;
  int pressedkey;
  char widget_found;
  double cur_time;
  int backpack_type_selection = 0;
  int n_menuitems, target_item = 0;

  if ((!menuwindow) || (!menuwindow->menu) || (!menuwindow->buttons))
    return(1);

  if (jtp_is_spellbook_being_viewed)
  {
    jtp_view_spellbook(menuwindow);
    return(1);
  }

  /*
   * If this is a 'Remove what types' menu, we need to support the backpack
   * screen shortcuts, so we need to automatically select which types of
   * items to remove. This is a really awkward solution.
   */
  if ((menuwindow->menu->prompt) &&
      (jtp_backpack_shortcut_action == jtp_translate_command(JTP_NHCMD_REMOVE_ITEM)) &&  /* 'Inactive' allowed. This is an exception to the normal rule. */
      (!strcmp(menuwindow->menu->prompt, "What type of things do you want to take off?")))
  {
    selectedbutton = 1;
    /* Set all menu items to 'not selected' */
    jtp_list_reset(menuwindow->menu->items);
    tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    while (tempmenuitem2)
    {
      tempmenuitem2->selected = FALSE;
      jtp_list_advance(menuwindow->menu->items);
      tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);              
    }

    /* Set 'all types' to selected */
    jtp_list_reset(menuwindow->menu->items);
    tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    tempmenuitem->selected = TRUE;
    tempmenuitem->count = -1;

    return(selectedbutton);
  }

  /*
   * If this is a 'Remove what' or 'Cast what' menu, we need to support
   * the backpack/spellbook screen shortcuts, so we need to automatically
   * select which item to remove/spell to cast.
   * This is a really awkward solution.
   */
  if ((menuwindow->menu->prompt) &&
      (jtp_backpack_shortcut_action == jtp_translate_command(JTP_NHCMD_REMOVE_ITEM)) &&  /* 'Inactive' allowed. This is an exception to the normal rule. */
      (!strcmp(menuwindow->menu->prompt, "What do you want to take off?")))
    backpack_type_selection = 1;

  if ((menuwindow->menu->prompt) &&
      (jtp_backpack_shortcut_action == jtp_translate_command(JTP_NHCMD_CAST_SPELL)) &&  /* 'Inactive' allowed. This is an exception to the normal rule. */
      (!strcmp(menuwindow->menu->prompt, "Choose which spell to cast")))
    backpack_type_selection = 1;

  if (backpack_type_selection)
  {
    /* Set all menu items to 'not selected' */
    jtp_list_reset(menuwindow->menu->items);
    tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    while (tempmenuitem2)
    {
      tempmenuitem2->selected = FALSE;
      jtp_list_advance(menuwindow->menu->items);
      tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    }

    /* Find the correct item by its shortcut accelerator, and select it */
    jtp_list_reset(menuwindow->menu->items);
    tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    while (tempmenuitem2)
    {
      if (tempmenuitem2->accelerator == jtp_shortcut_query_response)
      {
        tempmenuitem2->selected = TRUE;
        tempmenuitem2->count = -1;
      }
      jtp_list_advance(menuwindow->menu->items);
      tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    }

    /* The shortcut has now been used, so make sure it is not used twice */
    jtp_is_backpack_shortcut_active = 0;
    jtp_is_shortcut_active = 0;
    jtp_shortcut_query_response = 0;
    jtp_backpack_shortcut_action = 0;

    selectedbutton = 1;
    return(selectedbutton);
  }
  
  /* Find number of menu items in the menu */
  n_menuitems = 0;
  jtp_list_reset(menuwindow->menu->items);
  tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
  while (tempmenuitem)
  {
    n_menuitems++;
    jtp_list_advance(menuwindow->menu->items);
    tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
  }

  /* Store background graphics and draw window components */
  menubackground = jtp_draw_window(menuwindow->x, menuwindow->y, 
                                   menuwindow->width, menuwindow->height);
  if (!menubackground)
    jtp_messagebox("Error: Could not get menu background");

  jtp_list_reset(menuwindow->menu->items);
  firstitem = jtp_list_current(menuwindow->menu->items);
  jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);

  jtp_draw_buttons(menuwindow->x, menuwindow->y, menuwindow->buttons);

  jtp_refresh(&jtp_screen);
  /* If the palette is faded out for some reason, restore it */
  jtp_updatepal(0, 255);

  selectedbutton = -1;
  while (selectedbutton < 0)
  {
    jtp_keymouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_LEFT);
    pressedkey = jtp_getch();

    cur_time = jtp_clocktick();

    widget_found = 0;
    jtp_list_reset(menuwindow->buttons);
    tempbutton = (jtp_button *)jtp_list_current(menuwindow->buttons);
    while ((tempbutton) && (selectedbutton < 0))
    {
      if ((jtp_mouseb == JTP_MBUTTON_LEFT) &&
          (jtp_in_area(jtp_mousex, jtp_mousey, 
                       menuwindow->x + tempbutton->x, 
                       menuwindow->y + tempbutton->y,
                       menuwindow->x + tempbutton->x + tempbutton->width - 1,
                       menuwindow->y + tempbutton->y + tempbutton->height - 1)))
        widget_found = 1;
      else if ((pressedkey) && (pressedkey == tempbutton->accelerator))
        widget_found = 1;
      if (widget_found)
      {
        /* Wait until mouse button is released */
        jtp_press_button(menuwindow->x + tempbutton->x + 1, 
                         menuwindow->y + tempbutton->y + 1,
                         menuwindow->x + tempbutton->x + tempbutton->width-2,
                         menuwindow->y + tempbutton->y + tempbutton->height-2,
                         jtp_mcursor[JTP_CURSOR_NORMAL]);
        selectedbutton = tempbutton->id;
      }        
      
      jtp_list_advance(menuwindow->buttons);
      tempbutton = (jtp_button *)jtp_list_current(menuwindow->buttons);
    }
    
    
    jtp_list_reset(menuwindow->menu->items);
    tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    while ((tempmenuitem) && (tempmenuitem != firstitem))
    {
      jtp_list_advance(menuwindow->menu->items);
      tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    }  
    
    widget_found = 0;

    switch (pressedkey)
    {
    case MENU_FIRST_PAGE:
    case MENU_LAST_PAGE:
    case MENU_NEXT_PAGE:
    case MENU_PREVIOUS_PAGE:
      /* handled below */
      break;
    case MENU_SELECT_ALL:
      if (menuwindow->menu->selectiontype == PICK_ANY)
      {
        /* Set all menu items to 'not selected' */
        jtp_list_reset(menuwindow->menu->items);
        tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        while (tempmenuitem2)
        {
          if (tempmenuitem2->count != JTP_NOT_SELECTABLE)
            tempmenuitem2->selected = TRUE;
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);              
        }
        jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
        jtp_refresh(&jtp_screen);
        widget_found = 1;
      }
      break;
    case MENU_UNSELECT_ALL:
      if (menuwindow->menu->selectiontype == PICK_ANY)
      {
        /* Set all menu items to 'not selected' */
        jtp_list_reset(menuwindow->menu->items);
        tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        while (tempmenuitem2)
        {
          if (tempmenuitem2->count != JTP_NOT_SELECTABLE)
            tempmenuitem2->selected = FALSE;
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        }
        jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
        jtp_refresh(&jtp_screen);
        widget_found = 1;
      }
      break;
    case MENU_INVERT_ALL:
      if (menuwindow->menu->selectiontype == PICK_ANY)
      {
        /* Set all menu items to 'not selected' */
        jtp_list_reset(menuwindow->menu->items);
        tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        while (tempmenuitem2)
        {
          if (tempmenuitem2->count != JTP_NOT_SELECTABLE)
            tempmenuitem2->selected = !tempmenuitem2->selected;
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        }
        jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
        jtp_refresh(&jtp_screen);
        widget_found = 1;
      }
      break;
    case MENU_SELECT_PAGE:
      if (menuwindow->menu->selectiontype == PICK_ANY)
      {
        /* Set all menu items to 'not selected' */
        tempmenuitem2 = firstitem;
        while (tempmenuitem2)
        {
          if (tempmenuitem2->count != JTP_NOT_SELECTABLE)
            tempmenuitem2->selected = TRUE;
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
          if (tempmenuitem2 != NULL && (tempmenuitem2->y - firstitem->y) >= menuwindow->menu->items_height)
            break;
        }
        jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
        jtp_refresh(&jtp_screen);
        widget_found = 1;
      }
      break;
    case MENU_UNSELECT_PAGE:
      if (menuwindow->menu->selectiontype == PICK_ANY)
      {
        /* Set all menu items to 'not selected' */
        tempmenuitem2 = firstitem;
        while (tempmenuitem2)
        {
          if (tempmenuitem2->count != JTP_NOT_SELECTABLE)
            tempmenuitem2->selected = FALSE;
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
          if (tempmenuitem2 != NULL && (tempmenuitem2->y - firstitem->y) >= menuwindow->menu->items_height)
            break;
        }
        jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
        jtp_refresh(&jtp_screen);
        widget_found = 1;
      }
      break;
    case MENU_INVERT_PAGE:
      if (menuwindow->menu->selectiontype == PICK_ANY)
      {
        /* Set all menu items to 'not selected' */
        tempmenuitem2 = firstitem;
        while (tempmenuitem2)
        {
          if (tempmenuitem2->count != JTP_NOT_SELECTABLE)
            tempmenuitem2->selected = !tempmenuitem2->selected;
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
          if (tempmenuitem2 != NULL && (tempmenuitem2->y - firstitem->y) >= menuwindow->menu->items_height)
            break;
        }
        jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
        jtp_refresh(&jtp_screen);
        widget_found = 1;
      }
      break;
    case MENU_SEARCH:
      if (menuwindow->menu->selectiontype == PICK_ANY || menuwindow->menu->selectiontype == PICK_ONE)
      {
      	char buf[BUFSZ];
      	
      	if (jtp_get_input(-1, -1, "Search for:", buf) && *buf)
      	{
      	  lastitem = NULL;
          jtp_list_reset(menuwindow->menu->items);
          tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
          while (tempmenuitem2)
          {
            if (tempmenuitem2->count != JTP_NOT_SELECTABLE)
            {
              if (strstr(tempmenuitem2->text, buf))
              {
                tempmenuitem2->selected = TRUE;
                if (lastitem == NULL)
                  lastitem = tempmenuitem2;
                if (menuwindow->menu->selectiontype == PICK_ONE)
                  break;
              } else if (menuwindow->menu->selectiontype == PICK_ANY)
              {
                tempmenuitem2->selected = FALSE;
              }
            }
            jtp_list_advance(menuwindow->menu->items);
            tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
          }
          if (lastitem != NULL)
          {
            firstitem = lastitem;
            tempimage = jtp_draw_window(menuwindow->x, menuwindow->y, 
                                    menuwindow->width, menuwindow->height);
            free(tempimage);
          }
          jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
          jtp_refresh(&jtp_screen);
      	}
      	widget_found = 1;
      }
      break;
    }
    
    while ((selectedbutton < 0) && (!widget_found) && (tempmenuitem) && 
           (tempmenuitem->y - firstitem->y + tempmenuitem->height < JTP_MAX_MENUITEMS_HEIGHT))
    {
      
      if ((jtp_mouseb == JTP_MBUTTON_LEFT) && 
          (jtp_in_area(jtp_mousex, jtp_mousey, 
                       menuwindow->x + tempmenuitem->x, 
                       menuwindow->y + menuwindow->menu->items_y + 
                         tempmenuitem->y - firstitem->y,
                       menuwindow->x + tempmenuitem->x + tempmenuitem->width - 1,
                       menuwindow->y + menuwindow->menu->items_y + 
                         tempmenuitem->y - firstitem->y + tempmenuitem->height - 1)))
        widget_found = 1;
      else if ((pressedkey) && (pressedkey == tempmenuitem->accelerator))
        widget_found = 1;
        
      if (widget_found)
      {
        /* Wait until mouse button is released */
        jtp_repeatmouse(jtp_mcursor[JTP_CURSOR_NORMAL], JTP_MBUTTON_NONE);

        if (tempmenuitem->count != JTP_NOT_SELECTABLE)
        {        
          switch (menuwindow->menu->selectiontype)
          {
            case PICK_NONE: break;
            case PICK_ONE:
              /* Set all menu items to 'not selected' */
              jtp_list_reset(menuwindow->menu->items);
              tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
              while (tempmenuitem2)
              {
                tempmenuitem2->selected = FALSE;
                jtp_list_advance(menuwindow->menu->items);
                tempmenuitem2 = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);              
              }
              tempmenuitem->selected = TRUE;
              tempmenuitem->count = -1;
              break;
            case PICK_ANY: 
              if (tempmenuitem->selected == FALSE) tempmenuitem->selected = TRUE;
              else tempmenuitem->selected = FALSE;
              tempmenuitem->count = -1;
              break;
            default: break;
          }
        
          /* Redraw changed menu (background not redrawn since menuitem position is constant) */
          jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
          jtp_refresh(&jtp_screen);
        }
                
      }
      
      jtp_list_advance(menuwindow->menu->items);
      tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
    }

    if (cur_time-jtp_last_scroll_time > jtp_min_scroll_delay)
    {
      widget_found = 0;

      /* Click on the scroll up button */
      if ((selectedbutton < 0) && (menuwindow->menu->need_scrollbar) &&
          (jtp_in_area(jtp_mousex, jtp_mousey, 
                       menuwindow->x + menuwindow->menu->scrollbar_x,
                       menuwindow->y + menuwindow->menu->scrollup_y,
                       menuwindow->x + menuwindow->menu->scrollbar_x +
                         jtp_defwin.scrollbutton_up[3] - 1,
                       menuwindow->y + menuwindow->menu->scrollup_y +
                         jtp_defwin.scrollbutton_up[1] - 1)))
      {
        widget_found = 1; target_item = 1;
      }
      else if (pressedkey == JTP_KEY_MENU_SCROLLUP)
      {
        widget_found = 1; target_item = 1;
      }
      else if (pressedkey == JTP_MOUSEWHEEL_UP)
      {
        widget_found = 1; target_item = 3;
      }
      else if (pressedkey == JTP_KEY_MENU_SCROLLPAGEUP || pressedkey == MENU_PREVIOUS_PAGE)
      {
        widget_found = 1; target_item = 10;
      }
      else if (pressedkey == JTP_KEY_HOME || pressedkey == MENU_FIRST_PAGE)
      {
        widget_found = 1; target_item = 9999;
      }

      if (widget_found == 1)
      {
        /* Find the menuitem that comes 'target_item' steps before 'firstitem' */
        jtp_list_reset(menuwindow->menu->items);
        tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        while ((tempmenuitem) && (tempmenuitem != firstitem))
        {
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        }
        while (target_item > 0)
        {
          jtp_list_retreat(menuwindow->menu->items);
          if (menuwindow->menu->items->previous == menuwindow->menu->items->header)
            break;
          target_item--;
        }
        firstitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        
        /* Redraw whole window */
        tempimage = jtp_draw_window(menuwindow->x, menuwindow->y, 
                                    menuwindow->width, menuwindow->height);
        free(tempimage);
        if (!menubackground) jtp_messagebox("Error: Could not get menu background");
        jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);    
        jtp_draw_buttons(menuwindow->x, menuwindow->y, menuwindow->buttons);
        jtp_refresh(&jtp_screen);
        jtp_last_scroll_time = cur_time;
        widget_found = 2; /* Found and processed */
      }

      /* Click on the scroll down button */
      if ((selectedbutton < 0) && (!widget_found) && (menuwindow->menu->need_scrollbar) &&
          (jtp_in_area(jtp_mousex, jtp_mousey, 
                       menuwindow->x + menuwindow->menu->scrollbar_x,
                       menuwindow->y + menuwindow->menu->scrolldown_y,
                       menuwindow->x + menuwindow->menu->scrollbar_x +
                         jtp_defwin.scrollbutton_down[3] - 1,
                       menuwindow->y + menuwindow->menu->scrolldown_y +
                         jtp_defwin.scrollbutton_down[1] - 1)))
      {
        widget_found = 1; target_item = 1;
      }
      else if (pressedkey == JTP_KEY_MENU_SCROLLDOWN)
      {
        widget_found = 1; target_item = 1;
      }
      else if (pressedkey == JTP_MOUSEWHEEL_DOWN)
      {
        widget_found = 1; target_item = 3;
      }
      else if (pressedkey == JTP_KEY_MENU_SCROLLPAGEDOWN || pressedkey == MENU_NEXT_PAGE)
      {
        widget_found = 1; target_item = 10;
      }
      else if (pressedkey == JTP_KEY_END || pressedkey == MENU_LAST_PAGE)
      {
        widget_found = 1; target_item = 9999;
      }

      if (widget_found == 1)
      {
        jtp_list_reset(menuwindow->menu->items);
        tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        while (tempmenuitem)
        {
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        }
        jtp_list_retreat(menuwindow->menu->items);
        lastitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        /* Find the menuitem that comes 'target_item' steps after 'firstitem' */
        jtp_list_reset(menuwindow->menu->items);
        tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        while ((tempmenuitem) && (tempmenuitem != firstitem))
        {
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        }
        while (target_item > 0)
        {
          if ((lastitem->y - ((jtp_menuitem *)jtp_list_current(menuwindow->menu->items))->y + lastitem->height) <= menuwindow->menu->items_height)
            target_item = 0;
          else
            jtp_list_advance(menuwindow->menu->items);
          /* Don't go past the end */
          if (!(jtp_menuitem *)jtp_list_current(menuwindow->menu->items))
          {
            jtp_list_retreat(menuwindow->menu->items);
            target_item = 0;
          }
          target_item--;
        }
        if ((jtp_menuitem *)jtp_list_current(menuwindow->menu->items))
          firstitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
  
        /* Redraw whole window */
        tempimage = jtp_draw_window(menuwindow->x, menuwindow->y, 
                                    menuwindow->width, menuwindow->height);
        free(tempimage);
        jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
        jtp_draw_buttons(menuwindow->x, menuwindow->y, menuwindow->buttons);
        jtp_refresh(&jtp_screen);
        jtp_last_scroll_time = cur_time;
        widget_found = 2; /* Found and processed */
      }

      /* Click on the scrollbar itself */
      if ((selectedbutton < 0) && (!widget_found) && (menuwindow->menu->need_scrollbar) &&
          (jtp_in_area(jtp_mousex, jtp_mousey, 
                       menuwindow->x + menuwindow->menu->scrollbar_x,
                       menuwindow->y + menuwindow->menu->scrollup_y +
                         jtp_defwin.scrollbutton_up[1],
                       menuwindow->x + menuwindow->menu->scrollbar_x +
                         jtp_defwin.scrollbutton_down[3] - 1,
                       menuwindow->y + menuwindow->menu->scrolldown_y - 1)))
        widget_found = 1;

      if (widget_found == 1)
      {
        target_item = jtp_mousey - menuwindow->y - menuwindow->menu->scrollup_y -
                      jtp_defwin.scrollbutton_up[1];
        target_item *= (n_menuitems-1);
        target_item /= menuwindow->menu->scrolldown_y - 1 - menuwindow->menu->scrollup_y -
                       jtp_defwin.scrollbutton_up[1];
        /* Find the target menuitem */
        jtp_list_reset(menuwindow->menu->items);
        tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
        while ((tempmenuitem) && (target_item > 0))
        {
          jtp_list_advance(menuwindow->menu->items);
          tempmenuitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
          target_item--;
        }
        if ((jtp_menuitem *)jtp_list_current(menuwindow->menu->items))
          firstitem = (jtp_menuitem *)jtp_list_current(menuwindow->menu->items);
  
        /* Redraw whole window */
        tempimage = jtp_draw_window(menuwindow->x, menuwindow->y, 
                                    menuwindow->width, menuwindow->height);
        free(tempimage);
        jtp_draw_menu(menuwindow->x, menuwindow->y, menuwindow->menu, firstitem);
        jtp_draw_buttons(menuwindow->x, menuwindow->y, menuwindow->buttons);
        jtp_refresh(&jtp_screen);
        jtp_last_scroll_time = cur_time;
        widget_found = 2; /* Found and processed */
      }
    }
  }

  /* Restore the window background */
  jtp_set_draw_region(0, 0, jtp_screen.width-1, jtp_screen.height-1);
  jtp_put_img(menuwindow->x, menuwindow->y, menubackground);
  jtp_refresh_region(menuwindow->x, menuwindow->y, 
                     menuwindow->x + menuwindow->width - 1,
                     menuwindow->y + menuwindow->height - 1, &jtp_screen);
  
  /* Clean up and exit */
  free(menubackground);
  return(selectedbutton);
}
